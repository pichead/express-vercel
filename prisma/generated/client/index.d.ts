
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model admin
 * 
 */
export type admin = $Result.DefaultSelection<Prisma.$adminPayload>
/**
 * Model user
 * 
 */
export type user = $Result.DefaultSelection<Prisma.$userPayload>
/**
 * Model user_credit_transaction
 * 
 */
export type user_credit_transaction = $Result.DefaultSelection<Prisma.$user_credit_transactionPayload>
/**
 * Model user_point_transaction
 * 
 */
export type user_point_transaction = $Result.DefaultSelection<Prisma.$user_point_transactionPayload>
/**
 * Model payment_transaction
 * 
 */
export type payment_transaction = $Result.DefaultSelection<Prisma.$payment_transactionPayload>
/**
 * Model address
 * 
 */
export type address = $Result.DefaultSelection<Prisma.$addressPayload>
/**
 * Model brand
 * 
 */
export type brand = $Result.DefaultSelection<Prisma.$brandPayload>
/**
 * Model tag
 * 
 */
export type tag = $Result.DefaultSelection<Prisma.$tagPayload>
/**
 * Model category
 * 
 */
export type category = $Result.DefaultSelection<Prisma.$categoryPayload>
/**
 * Model sub_category
 * 
 */
export type sub_category = $Result.DefaultSelection<Prisma.$sub_categoryPayload>
/**
 * Model product_review
 * 
 */
export type product_review = $Result.DefaultSelection<Prisma.$product_reviewPayload>
/**
 * Model review_image
 * 
 */
export type review_image = $Result.DefaultSelection<Prisma.$review_imagePayload>
/**
 * Model product
 * 
 */
export type product = $Result.DefaultSelection<Prisma.$productPayload>
/**
 * Model product_tag
 * 
 */
export type product_tag = $Result.DefaultSelection<Prisma.$product_tagPayload>
/**
 * Model product_wholesale
 * 
 */
export type product_wholesale = $Result.DefaultSelection<Prisma.$product_wholesalePayload>
/**
 * Model product_option_first
 * 
 */
export type product_option_first = $Result.DefaultSelection<Prisma.$product_option_firstPayload>
/**
 * Model product_option_second
 * 
 */
export type product_option_second = $Result.DefaultSelection<Prisma.$product_option_secondPayload>
/**
 * Model product_price
 * 
 */
export type product_price = $Result.DefaultSelection<Prisma.$product_pricePayload>
/**
 * Model product_detail
 * 
 */
export type product_detail = $Result.DefaultSelection<Prisma.$product_detailPayload>
/**
 * Model product_image
 * 
 */
export type product_image = $Result.DefaultSelection<Prisma.$product_imagePayload>
/**
 * Model product_spec
 * 
 */
export type product_spec = $Result.DefaultSelection<Prisma.$product_specPayload>
/**
 * Model cart
 * 
 */
export type cart = $Result.DefaultSelection<Prisma.$cartPayload>
/**
 * Model order
 * 
 */
export type order = $Result.DefaultSelection<Prisma.$orderPayload>
/**
 * Model order_product
 * 
 */
export type order_product = $Result.DefaultSelection<Prisma.$order_productPayload>
/**
 * Model setting
 * 
 */
export type setting = $Result.DefaultSelection<Prisma.$settingPayload>
/**
 * Model setting_service
 * 
 */
export type setting_service = $Result.DefaultSelection<Prisma.$setting_servicePayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Admins
 * const admins = await prisma.admin.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Admins
   * const admins = await prisma.admin.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.admin`: Exposes CRUD operations for the **admin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Admins
    * const admins = await prisma.admin.findMany()
    * ```
    */
  get admin(): Prisma.adminDelegate<ExtArgs>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **user** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.userDelegate<ExtArgs>;

  /**
   * `prisma.user_credit_transaction`: Exposes CRUD operations for the **user_credit_transaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more User_credit_transactions
    * const user_credit_transactions = await prisma.user_credit_transaction.findMany()
    * ```
    */
  get user_credit_transaction(): Prisma.user_credit_transactionDelegate<ExtArgs>;

  /**
   * `prisma.user_point_transaction`: Exposes CRUD operations for the **user_point_transaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more User_point_transactions
    * const user_point_transactions = await prisma.user_point_transaction.findMany()
    * ```
    */
  get user_point_transaction(): Prisma.user_point_transactionDelegate<ExtArgs>;

  /**
   * `prisma.payment_transaction`: Exposes CRUD operations for the **payment_transaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payment_transactions
    * const payment_transactions = await prisma.payment_transaction.findMany()
    * ```
    */
  get payment_transaction(): Prisma.payment_transactionDelegate<ExtArgs>;

  /**
   * `prisma.address`: Exposes CRUD operations for the **address** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Addresses
    * const addresses = await prisma.address.findMany()
    * ```
    */
  get address(): Prisma.addressDelegate<ExtArgs>;

  /**
   * `prisma.brand`: Exposes CRUD operations for the **brand** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Brands
    * const brands = await prisma.brand.findMany()
    * ```
    */
  get brand(): Prisma.brandDelegate<ExtArgs>;

  /**
   * `prisma.tag`: Exposes CRUD operations for the **tag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tags
    * const tags = await prisma.tag.findMany()
    * ```
    */
  get tag(): Prisma.tagDelegate<ExtArgs>;

  /**
   * `prisma.category`: Exposes CRUD operations for the **category** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categories
    * const categories = await prisma.category.findMany()
    * ```
    */
  get category(): Prisma.categoryDelegate<ExtArgs>;

  /**
   * `prisma.sub_category`: Exposes CRUD operations for the **sub_category** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sub_categories
    * const sub_categories = await prisma.sub_category.findMany()
    * ```
    */
  get sub_category(): Prisma.sub_categoryDelegate<ExtArgs>;

  /**
   * `prisma.product_review`: Exposes CRUD operations for the **product_review** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Product_reviews
    * const product_reviews = await prisma.product_review.findMany()
    * ```
    */
  get product_review(): Prisma.product_reviewDelegate<ExtArgs>;

  /**
   * `prisma.review_image`: Exposes CRUD operations for the **review_image** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Review_images
    * const review_images = await prisma.review_image.findMany()
    * ```
    */
  get review_image(): Prisma.review_imageDelegate<ExtArgs>;

  /**
   * `prisma.product`: Exposes CRUD operations for the **product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.product.findMany()
    * ```
    */
  get product(): Prisma.productDelegate<ExtArgs>;

  /**
   * `prisma.product_tag`: Exposes CRUD operations for the **product_tag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Product_tags
    * const product_tags = await prisma.product_tag.findMany()
    * ```
    */
  get product_tag(): Prisma.product_tagDelegate<ExtArgs>;

  /**
   * `prisma.product_wholesale`: Exposes CRUD operations for the **product_wholesale** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Product_wholesales
    * const product_wholesales = await prisma.product_wholesale.findMany()
    * ```
    */
  get product_wholesale(): Prisma.product_wholesaleDelegate<ExtArgs>;

  /**
   * `prisma.product_option_first`: Exposes CRUD operations for the **product_option_first** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Product_option_firsts
    * const product_option_firsts = await prisma.product_option_first.findMany()
    * ```
    */
  get product_option_first(): Prisma.product_option_firstDelegate<ExtArgs>;

  /**
   * `prisma.product_option_second`: Exposes CRUD operations for the **product_option_second** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Product_option_seconds
    * const product_option_seconds = await prisma.product_option_second.findMany()
    * ```
    */
  get product_option_second(): Prisma.product_option_secondDelegate<ExtArgs>;

  /**
   * `prisma.product_price`: Exposes CRUD operations for the **product_price** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Product_prices
    * const product_prices = await prisma.product_price.findMany()
    * ```
    */
  get product_price(): Prisma.product_priceDelegate<ExtArgs>;

  /**
   * `prisma.product_detail`: Exposes CRUD operations for the **product_detail** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Product_details
    * const product_details = await prisma.product_detail.findMany()
    * ```
    */
  get product_detail(): Prisma.product_detailDelegate<ExtArgs>;

  /**
   * `prisma.product_image`: Exposes CRUD operations for the **product_image** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Product_images
    * const product_images = await prisma.product_image.findMany()
    * ```
    */
  get product_image(): Prisma.product_imageDelegate<ExtArgs>;

  /**
   * `prisma.product_spec`: Exposes CRUD operations for the **product_spec** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Product_specs
    * const product_specs = await prisma.product_spec.findMany()
    * ```
    */
  get product_spec(): Prisma.product_specDelegate<ExtArgs>;

  /**
   * `prisma.cart`: Exposes CRUD operations for the **cart** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Carts
    * const carts = await prisma.cart.findMany()
    * ```
    */
  get cart(): Prisma.cartDelegate<ExtArgs>;

  /**
   * `prisma.order`: Exposes CRUD operations for the **order** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Orders
    * const orders = await prisma.order.findMany()
    * ```
    */
  get order(): Prisma.orderDelegate<ExtArgs>;

  /**
   * `prisma.order_product`: Exposes CRUD operations for the **order_product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Order_products
    * const order_products = await prisma.order_product.findMany()
    * ```
    */
  get order_product(): Prisma.order_productDelegate<ExtArgs>;

  /**
   * `prisma.setting`: Exposes CRUD operations for the **setting** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Settings
    * const settings = await prisma.setting.findMany()
    * ```
    */
  get setting(): Prisma.settingDelegate<ExtArgs>;

  /**
   * `prisma.setting_service`: Exposes CRUD operations for the **setting_service** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Setting_services
    * const setting_services = await prisma.setting_service.findMany()
    * ```
    */
  get setting_service(): Prisma.setting_serviceDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.9.1
   * Query Engine version: 23fdc5965b1e05fc54e5f26ed3de66776b93de64
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | { toJSON(): unknown }

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    admin: 'admin',
    user: 'user',
    user_credit_transaction: 'user_credit_transaction',
    user_point_transaction: 'user_point_transaction',
    payment_transaction: 'payment_transaction',
    address: 'address',
    brand: 'brand',
    tag: 'tag',
    category: 'category',
    sub_category: 'sub_category',
    product_review: 'product_review',
    review_image: 'review_image',
    product: 'product',
    product_tag: 'product_tag',
    product_wholesale: 'product_wholesale',
    product_option_first: 'product_option_first',
    product_option_second: 'product_option_second',
    product_price: 'product_price',
    product_detail: 'product_detail',
    product_image: 'product_image',
    product_spec: 'product_spec',
    cart: 'cart',
    order: 'order',
    order_product: 'order_product',
    setting: 'setting',
    setting_service: 'setting_service'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'admin' | 'user' | 'user_credit_transaction' | 'user_point_transaction' | 'payment_transaction' | 'address' | 'brand' | 'tag' | 'category' | 'sub_category' | 'product_review' | 'review_image' | 'product' | 'product_tag' | 'product_wholesale' | 'product_option_first' | 'product_option_second' | 'product_price' | 'product_detail' | 'product_image' | 'product_spec' | 'cart' | 'order' | 'order_product' | 'setting' | 'setting_service'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      admin: {
        payload: Prisma.$adminPayload<ExtArgs>
        fields: Prisma.adminFieldRefs
        operations: {
          findUnique: {
            args: Prisma.adminFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$adminPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.adminFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$adminPayload>
          }
          findFirst: {
            args: Prisma.adminFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$adminPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.adminFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$adminPayload>
          }
          findMany: {
            args: Prisma.adminFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$adminPayload>[]
          }
          create: {
            args: Prisma.adminCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$adminPayload>
          }
          createMany: {
            args: Prisma.adminCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.adminDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$adminPayload>
          }
          update: {
            args: Prisma.adminUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$adminPayload>
          }
          deleteMany: {
            args: Prisma.adminDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.adminUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.adminUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$adminPayload>
          }
          aggregate: {
            args: Prisma.AdminAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAdmin>
          }
          groupBy: {
            args: Prisma.adminGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AdminGroupByOutputType>[]
          }
          count: {
            args: Prisma.adminCountArgs<ExtArgs>,
            result: $Utils.Optional<AdminCountAggregateOutputType> | number
          }
        }
      }
      user: {
        payload: Prisma.$userPayload<ExtArgs>
        fields: Prisma.userFieldRefs
        operations: {
          findUnique: {
            args: Prisma.userFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$userPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.userFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          findFirst: {
            args: Prisma.userFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$userPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.userFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          findMany: {
            args: Prisma.userFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$userPayload>[]
          }
          create: {
            args: Prisma.userCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          createMany: {
            args: Prisma.userCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.userDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          update: {
            args: Prisma.userUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          deleteMany: {
            args: Prisma.userDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.userUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.userUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.userGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.userCountArgs<ExtArgs>,
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      user_credit_transaction: {
        payload: Prisma.$user_credit_transactionPayload<ExtArgs>
        fields: Prisma.user_credit_transactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.user_credit_transactionFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$user_credit_transactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.user_credit_transactionFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$user_credit_transactionPayload>
          }
          findFirst: {
            args: Prisma.user_credit_transactionFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$user_credit_transactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.user_credit_transactionFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$user_credit_transactionPayload>
          }
          findMany: {
            args: Prisma.user_credit_transactionFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$user_credit_transactionPayload>[]
          }
          create: {
            args: Prisma.user_credit_transactionCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$user_credit_transactionPayload>
          }
          createMany: {
            args: Prisma.user_credit_transactionCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.user_credit_transactionDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$user_credit_transactionPayload>
          }
          update: {
            args: Prisma.user_credit_transactionUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$user_credit_transactionPayload>
          }
          deleteMany: {
            args: Prisma.user_credit_transactionDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.user_credit_transactionUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.user_credit_transactionUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$user_credit_transactionPayload>
          }
          aggregate: {
            args: Prisma.User_credit_transactionAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUser_credit_transaction>
          }
          groupBy: {
            args: Prisma.user_credit_transactionGroupByArgs<ExtArgs>,
            result: $Utils.Optional<User_credit_transactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.user_credit_transactionCountArgs<ExtArgs>,
            result: $Utils.Optional<User_credit_transactionCountAggregateOutputType> | number
          }
        }
      }
      user_point_transaction: {
        payload: Prisma.$user_point_transactionPayload<ExtArgs>
        fields: Prisma.user_point_transactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.user_point_transactionFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$user_point_transactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.user_point_transactionFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$user_point_transactionPayload>
          }
          findFirst: {
            args: Prisma.user_point_transactionFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$user_point_transactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.user_point_transactionFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$user_point_transactionPayload>
          }
          findMany: {
            args: Prisma.user_point_transactionFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$user_point_transactionPayload>[]
          }
          create: {
            args: Prisma.user_point_transactionCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$user_point_transactionPayload>
          }
          createMany: {
            args: Prisma.user_point_transactionCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.user_point_transactionDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$user_point_transactionPayload>
          }
          update: {
            args: Prisma.user_point_transactionUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$user_point_transactionPayload>
          }
          deleteMany: {
            args: Prisma.user_point_transactionDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.user_point_transactionUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.user_point_transactionUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$user_point_transactionPayload>
          }
          aggregate: {
            args: Prisma.User_point_transactionAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUser_point_transaction>
          }
          groupBy: {
            args: Prisma.user_point_transactionGroupByArgs<ExtArgs>,
            result: $Utils.Optional<User_point_transactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.user_point_transactionCountArgs<ExtArgs>,
            result: $Utils.Optional<User_point_transactionCountAggregateOutputType> | number
          }
        }
      }
      payment_transaction: {
        payload: Prisma.$payment_transactionPayload<ExtArgs>
        fields: Prisma.payment_transactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.payment_transactionFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$payment_transactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.payment_transactionFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$payment_transactionPayload>
          }
          findFirst: {
            args: Prisma.payment_transactionFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$payment_transactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.payment_transactionFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$payment_transactionPayload>
          }
          findMany: {
            args: Prisma.payment_transactionFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$payment_transactionPayload>[]
          }
          create: {
            args: Prisma.payment_transactionCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$payment_transactionPayload>
          }
          createMany: {
            args: Prisma.payment_transactionCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.payment_transactionDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$payment_transactionPayload>
          }
          update: {
            args: Prisma.payment_transactionUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$payment_transactionPayload>
          }
          deleteMany: {
            args: Prisma.payment_transactionDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.payment_transactionUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.payment_transactionUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$payment_transactionPayload>
          }
          aggregate: {
            args: Prisma.Payment_transactionAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePayment_transaction>
          }
          groupBy: {
            args: Prisma.payment_transactionGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Payment_transactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.payment_transactionCountArgs<ExtArgs>,
            result: $Utils.Optional<Payment_transactionCountAggregateOutputType> | number
          }
        }
      }
      address: {
        payload: Prisma.$addressPayload<ExtArgs>
        fields: Prisma.addressFieldRefs
        operations: {
          findUnique: {
            args: Prisma.addressFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$addressPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.addressFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$addressPayload>
          }
          findFirst: {
            args: Prisma.addressFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$addressPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.addressFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$addressPayload>
          }
          findMany: {
            args: Prisma.addressFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$addressPayload>[]
          }
          create: {
            args: Prisma.addressCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$addressPayload>
          }
          createMany: {
            args: Prisma.addressCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.addressDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$addressPayload>
          }
          update: {
            args: Prisma.addressUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$addressPayload>
          }
          deleteMany: {
            args: Prisma.addressDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.addressUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.addressUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$addressPayload>
          }
          aggregate: {
            args: Prisma.AddressAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAddress>
          }
          groupBy: {
            args: Prisma.addressGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AddressGroupByOutputType>[]
          }
          count: {
            args: Prisma.addressCountArgs<ExtArgs>,
            result: $Utils.Optional<AddressCountAggregateOutputType> | number
          }
        }
      }
      brand: {
        payload: Prisma.$brandPayload<ExtArgs>
        fields: Prisma.brandFieldRefs
        operations: {
          findUnique: {
            args: Prisma.brandFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$brandPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.brandFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$brandPayload>
          }
          findFirst: {
            args: Prisma.brandFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$brandPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.brandFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$brandPayload>
          }
          findMany: {
            args: Prisma.brandFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$brandPayload>[]
          }
          create: {
            args: Prisma.brandCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$brandPayload>
          }
          createMany: {
            args: Prisma.brandCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.brandDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$brandPayload>
          }
          update: {
            args: Prisma.brandUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$brandPayload>
          }
          deleteMany: {
            args: Prisma.brandDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.brandUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.brandUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$brandPayload>
          }
          aggregate: {
            args: Prisma.BrandAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBrand>
          }
          groupBy: {
            args: Prisma.brandGroupByArgs<ExtArgs>,
            result: $Utils.Optional<BrandGroupByOutputType>[]
          }
          count: {
            args: Prisma.brandCountArgs<ExtArgs>,
            result: $Utils.Optional<BrandCountAggregateOutputType> | number
          }
        }
      }
      tag: {
        payload: Prisma.$tagPayload<ExtArgs>
        fields: Prisma.tagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tagFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tagFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tagPayload>
          }
          findFirst: {
            args: Prisma.tagFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tagFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tagPayload>
          }
          findMany: {
            args: Prisma.tagFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tagPayload>[]
          }
          create: {
            args: Prisma.tagCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tagPayload>
          }
          createMany: {
            args: Prisma.tagCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.tagDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tagPayload>
          }
          update: {
            args: Prisma.tagUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tagPayload>
          }
          deleteMany: {
            args: Prisma.tagDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.tagUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.tagUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tagPayload>
          }
          aggregate: {
            args: Prisma.TagAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTag>
          }
          groupBy: {
            args: Prisma.tagGroupByArgs<ExtArgs>,
            result: $Utils.Optional<TagGroupByOutputType>[]
          }
          count: {
            args: Prisma.tagCountArgs<ExtArgs>,
            result: $Utils.Optional<TagCountAggregateOutputType> | number
          }
        }
      }
      category: {
        payload: Prisma.$categoryPayload<ExtArgs>
        fields: Prisma.categoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.categoryFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$categoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.categoryFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$categoryPayload>
          }
          findFirst: {
            args: Prisma.categoryFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$categoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.categoryFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$categoryPayload>
          }
          findMany: {
            args: Prisma.categoryFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$categoryPayload>[]
          }
          create: {
            args: Prisma.categoryCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$categoryPayload>
          }
          createMany: {
            args: Prisma.categoryCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.categoryDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$categoryPayload>
          }
          update: {
            args: Prisma.categoryUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$categoryPayload>
          }
          deleteMany: {
            args: Prisma.categoryDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.categoryUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.categoryUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$categoryPayload>
          }
          aggregate: {
            args: Prisma.CategoryAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCategory>
          }
          groupBy: {
            args: Prisma.categoryGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.categoryCountArgs<ExtArgs>,
            result: $Utils.Optional<CategoryCountAggregateOutputType> | number
          }
        }
      }
      sub_category: {
        payload: Prisma.$sub_categoryPayload<ExtArgs>
        fields: Prisma.sub_categoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.sub_categoryFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$sub_categoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.sub_categoryFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$sub_categoryPayload>
          }
          findFirst: {
            args: Prisma.sub_categoryFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$sub_categoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.sub_categoryFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$sub_categoryPayload>
          }
          findMany: {
            args: Prisma.sub_categoryFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$sub_categoryPayload>[]
          }
          create: {
            args: Prisma.sub_categoryCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$sub_categoryPayload>
          }
          createMany: {
            args: Prisma.sub_categoryCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.sub_categoryDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$sub_categoryPayload>
          }
          update: {
            args: Prisma.sub_categoryUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$sub_categoryPayload>
          }
          deleteMany: {
            args: Prisma.sub_categoryDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.sub_categoryUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.sub_categoryUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$sub_categoryPayload>
          }
          aggregate: {
            args: Prisma.Sub_categoryAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSub_category>
          }
          groupBy: {
            args: Prisma.sub_categoryGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Sub_categoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.sub_categoryCountArgs<ExtArgs>,
            result: $Utils.Optional<Sub_categoryCountAggregateOutputType> | number
          }
        }
      }
      product_review: {
        payload: Prisma.$product_reviewPayload<ExtArgs>
        fields: Prisma.product_reviewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.product_reviewFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$product_reviewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.product_reviewFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$product_reviewPayload>
          }
          findFirst: {
            args: Prisma.product_reviewFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$product_reviewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.product_reviewFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$product_reviewPayload>
          }
          findMany: {
            args: Prisma.product_reviewFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$product_reviewPayload>[]
          }
          create: {
            args: Prisma.product_reviewCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$product_reviewPayload>
          }
          createMany: {
            args: Prisma.product_reviewCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.product_reviewDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$product_reviewPayload>
          }
          update: {
            args: Prisma.product_reviewUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$product_reviewPayload>
          }
          deleteMany: {
            args: Prisma.product_reviewDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.product_reviewUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.product_reviewUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$product_reviewPayload>
          }
          aggregate: {
            args: Prisma.Product_reviewAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateProduct_review>
          }
          groupBy: {
            args: Prisma.product_reviewGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Product_reviewGroupByOutputType>[]
          }
          count: {
            args: Prisma.product_reviewCountArgs<ExtArgs>,
            result: $Utils.Optional<Product_reviewCountAggregateOutputType> | number
          }
        }
      }
      review_image: {
        payload: Prisma.$review_imagePayload<ExtArgs>
        fields: Prisma.review_imageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.review_imageFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$review_imagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.review_imageFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$review_imagePayload>
          }
          findFirst: {
            args: Prisma.review_imageFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$review_imagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.review_imageFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$review_imagePayload>
          }
          findMany: {
            args: Prisma.review_imageFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$review_imagePayload>[]
          }
          create: {
            args: Prisma.review_imageCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$review_imagePayload>
          }
          createMany: {
            args: Prisma.review_imageCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.review_imageDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$review_imagePayload>
          }
          update: {
            args: Prisma.review_imageUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$review_imagePayload>
          }
          deleteMany: {
            args: Prisma.review_imageDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.review_imageUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.review_imageUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$review_imagePayload>
          }
          aggregate: {
            args: Prisma.Review_imageAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateReview_image>
          }
          groupBy: {
            args: Prisma.review_imageGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Review_imageGroupByOutputType>[]
          }
          count: {
            args: Prisma.review_imageCountArgs<ExtArgs>,
            result: $Utils.Optional<Review_imageCountAggregateOutputType> | number
          }
        }
      }
      product: {
        payload: Prisma.$productPayload<ExtArgs>
        fields: Prisma.productFieldRefs
        operations: {
          findUnique: {
            args: Prisma.productFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$productPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.productFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$productPayload>
          }
          findFirst: {
            args: Prisma.productFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$productPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.productFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$productPayload>
          }
          findMany: {
            args: Prisma.productFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$productPayload>[]
          }
          create: {
            args: Prisma.productCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$productPayload>
          }
          createMany: {
            args: Prisma.productCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.productDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$productPayload>
          }
          update: {
            args: Prisma.productUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$productPayload>
          }
          deleteMany: {
            args: Prisma.productDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.productUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.productUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$productPayload>
          }
          aggregate: {
            args: Prisma.ProductAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateProduct>
          }
          groupBy: {
            args: Prisma.productGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.productCountArgs<ExtArgs>,
            result: $Utils.Optional<ProductCountAggregateOutputType> | number
          }
        }
      }
      product_tag: {
        payload: Prisma.$product_tagPayload<ExtArgs>
        fields: Prisma.product_tagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.product_tagFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$product_tagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.product_tagFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$product_tagPayload>
          }
          findFirst: {
            args: Prisma.product_tagFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$product_tagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.product_tagFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$product_tagPayload>
          }
          findMany: {
            args: Prisma.product_tagFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$product_tagPayload>[]
          }
          create: {
            args: Prisma.product_tagCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$product_tagPayload>
          }
          createMany: {
            args: Prisma.product_tagCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.product_tagDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$product_tagPayload>
          }
          update: {
            args: Prisma.product_tagUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$product_tagPayload>
          }
          deleteMany: {
            args: Prisma.product_tagDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.product_tagUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.product_tagUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$product_tagPayload>
          }
          aggregate: {
            args: Prisma.Product_tagAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateProduct_tag>
          }
          groupBy: {
            args: Prisma.product_tagGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Product_tagGroupByOutputType>[]
          }
          count: {
            args: Prisma.product_tagCountArgs<ExtArgs>,
            result: $Utils.Optional<Product_tagCountAggregateOutputType> | number
          }
        }
      }
      product_wholesale: {
        payload: Prisma.$product_wholesalePayload<ExtArgs>
        fields: Prisma.product_wholesaleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.product_wholesaleFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$product_wholesalePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.product_wholesaleFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$product_wholesalePayload>
          }
          findFirst: {
            args: Prisma.product_wholesaleFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$product_wholesalePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.product_wholesaleFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$product_wholesalePayload>
          }
          findMany: {
            args: Prisma.product_wholesaleFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$product_wholesalePayload>[]
          }
          create: {
            args: Prisma.product_wholesaleCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$product_wholesalePayload>
          }
          createMany: {
            args: Prisma.product_wholesaleCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.product_wholesaleDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$product_wholesalePayload>
          }
          update: {
            args: Prisma.product_wholesaleUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$product_wholesalePayload>
          }
          deleteMany: {
            args: Prisma.product_wholesaleDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.product_wholesaleUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.product_wholesaleUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$product_wholesalePayload>
          }
          aggregate: {
            args: Prisma.Product_wholesaleAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateProduct_wholesale>
          }
          groupBy: {
            args: Prisma.product_wholesaleGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Product_wholesaleGroupByOutputType>[]
          }
          count: {
            args: Prisma.product_wholesaleCountArgs<ExtArgs>,
            result: $Utils.Optional<Product_wholesaleCountAggregateOutputType> | number
          }
        }
      }
      product_option_first: {
        payload: Prisma.$product_option_firstPayload<ExtArgs>
        fields: Prisma.product_option_firstFieldRefs
        operations: {
          findUnique: {
            args: Prisma.product_option_firstFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$product_option_firstPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.product_option_firstFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$product_option_firstPayload>
          }
          findFirst: {
            args: Prisma.product_option_firstFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$product_option_firstPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.product_option_firstFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$product_option_firstPayload>
          }
          findMany: {
            args: Prisma.product_option_firstFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$product_option_firstPayload>[]
          }
          create: {
            args: Prisma.product_option_firstCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$product_option_firstPayload>
          }
          createMany: {
            args: Prisma.product_option_firstCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.product_option_firstDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$product_option_firstPayload>
          }
          update: {
            args: Prisma.product_option_firstUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$product_option_firstPayload>
          }
          deleteMany: {
            args: Prisma.product_option_firstDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.product_option_firstUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.product_option_firstUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$product_option_firstPayload>
          }
          aggregate: {
            args: Prisma.Product_option_firstAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateProduct_option_first>
          }
          groupBy: {
            args: Prisma.product_option_firstGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Product_option_firstGroupByOutputType>[]
          }
          count: {
            args: Prisma.product_option_firstCountArgs<ExtArgs>,
            result: $Utils.Optional<Product_option_firstCountAggregateOutputType> | number
          }
        }
      }
      product_option_second: {
        payload: Prisma.$product_option_secondPayload<ExtArgs>
        fields: Prisma.product_option_secondFieldRefs
        operations: {
          findUnique: {
            args: Prisma.product_option_secondFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$product_option_secondPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.product_option_secondFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$product_option_secondPayload>
          }
          findFirst: {
            args: Prisma.product_option_secondFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$product_option_secondPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.product_option_secondFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$product_option_secondPayload>
          }
          findMany: {
            args: Prisma.product_option_secondFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$product_option_secondPayload>[]
          }
          create: {
            args: Prisma.product_option_secondCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$product_option_secondPayload>
          }
          createMany: {
            args: Prisma.product_option_secondCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.product_option_secondDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$product_option_secondPayload>
          }
          update: {
            args: Prisma.product_option_secondUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$product_option_secondPayload>
          }
          deleteMany: {
            args: Prisma.product_option_secondDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.product_option_secondUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.product_option_secondUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$product_option_secondPayload>
          }
          aggregate: {
            args: Prisma.Product_option_secondAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateProduct_option_second>
          }
          groupBy: {
            args: Prisma.product_option_secondGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Product_option_secondGroupByOutputType>[]
          }
          count: {
            args: Prisma.product_option_secondCountArgs<ExtArgs>,
            result: $Utils.Optional<Product_option_secondCountAggregateOutputType> | number
          }
        }
      }
      product_price: {
        payload: Prisma.$product_pricePayload<ExtArgs>
        fields: Prisma.product_priceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.product_priceFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$product_pricePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.product_priceFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$product_pricePayload>
          }
          findFirst: {
            args: Prisma.product_priceFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$product_pricePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.product_priceFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$product_pricePayload>
          }
          findMany: {
            args: Prisma.product_priceFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$product_pricePayload>[]
          }
          create: {
            args: Prisma.product_priceCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$product_pricePayload>
          }
          createMany: {
            args: Prisma.product_priceCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.product_priceDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$product_pricePayload>
          }
          update: {
            args: Prisma.product_priceUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$product_pricePayload>
          }
          deleteMany: {
            args: Prisma.product_priceDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.product_priceUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.product_priceUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$product_pricePayload>
          }
          aggregate: {
            args: Prisma.Product_priceAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateProduct_price>
          }
          groupBy: {
            args: Prisma.product_priceGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Product_priceGroupByOutputType>[]
          }
          count: {
            args: Prisma.product_priceCountArgs<ExtArgs>,
            result: $Utils.Optional<Product_priceCountAggregateOutputType> | number
          }
        }
      }
      product_detail: {
        payload: Prisma.$product_detailPayload<ExtArgs>
        fields: Prisma.product_detailFieldRefs
        operations: {
          findUnique: {
            args: Prisma.product_detailFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$product_detailPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.product_detailFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$product_detailPayload>
          }
          findFirst: {
            args: Prisma.product_detailFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$product_detailPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.product_detailFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$product_detailPayload>
          }
          findMany: {
            args: Prisma.product_detailFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$product_detailPayload>[]
          }
          create: {
            args: Prisma.product_detailCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$product_detailPayload>
          }
          createMany: {
            args: Prisma.product_detailCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.product_detailDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$product_detailPayload>
          }
          update: {
            args: Prisma.product_detailUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$product_detailPayload>
          }
          deleteMany: {
            args: Prisma.product_detailDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.product_detailUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.product_detailUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$product_detailPayload>
          }
          aggregate: {
            args: Prisma.Product_detailAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateProduct_detail>
          }
          groupBy: {
            args: Prisma.product_detailGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Product_detailGroupByOutputType>[]
          }
          count: {
            args: Prisma.product_detailCountArgs<ExtArgs>,
            result: $Utils.Optional<Product_detailCountAggregateOutputType> | number
          }
        }
      }
      product_image: {
        payload: Prisma.$product_imagePayload<ExtArgs>
        fields: Prisma.product_imageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.product_imageFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$product_imagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.product_imageFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$product_imagePayload>
          }
          findFirst: {
            args: Prisma.product_imageFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$product_imagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.product_imageFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$product_imagePayload>
          }
          findMany: {
            args: Prisma.product_imageFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$product_imagePayload>[]
          }
          create: {
            args: Prisma.product_imageCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$product_imagePayload>
          }
          createMany: {
            args: Prisma.product_imageCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.product_imageDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$product_imagePayload>
          }
          update: {
            args: Prisma.product_imageUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$product_imagePayload>
          }
          deleteMany: {
            args: Prisma.product_imageDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.product_imageUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.product_imageUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$product_imagePayload>
          }
          aggregate: {
            args: Prisma.Product_imageAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateProduct_image>
          }
          groupBy: {
            args: Prisma.product_imageGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Product_imageGroupByOutputType>[]
          }
          count: {
            args: Prisma.product_imageCountArgs<ExtArgs>,
            result: $Utils.Optional<Product_imageCountAggregateOutputType> | number
          }
        }
      }
      product_spec: {
        payload: Prisma.$product_specPayload<ExtArgs>
        fields: Prisma.product_specFieldRefs
        operations: {
          findUnique: {
            args: Prisma.product_specFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$product_specPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.product_specFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$product_specPayload>
          }
          findFirst: {
            args: Prisma.product_specFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$product_specPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.product_specFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$product_specPayload>
          }
          findMany: {
            args: Prisma.product_specFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$product_specPayload>[]
          }
          create: {
            args: Prisma.product_specCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$product_specPayload>
          }
          createMany: {
            args: Prisma.product_specCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.product_specDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$product_specPayload>
          }
          update: {
            args: Prisma.product_specUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$product_specPayload>
          }
          deleteMany: {
            args: Prisma.product_specDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.product_specUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.product_specUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$product_specPayload>
          }
          aggregate: {
            args: Prisma.Product_specAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateProduct_spec>
          }
          groupBy: {
            args: Prisma.product_specGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Product_specGroupByOutputType>[]
          }
          count: {
            args: Prisma.product_specCountArgs<ExtArgs>,
            result: $Utils.Optional<Product_specCountAggregateOutputType> | number
          }
        }
      }
      cart: {
        payload: Prisma.$cartPayload<ExtArgs>
        fields: Prisma.cartFieldRefs
        operations: {
          findUnique: {
            args: Prisma.cartFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$cartPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.cartFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$cartPayload>
          }
          findFirst: {
            args: Prisma.cartFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$cartPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.cartFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$cartPayload>
          }
          findMany: {
            args: Prisma.cartFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$cartPayload>[]
          }
          create: {
            args: Prisma.cartCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$cartPayload>
          }
          createMany: {
            args: Prisma.cartCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.cartDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$cartPayload>
          }
          update: {
            args: Prisma.cartUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$cartPayload>
          }
          deleteMany: {
            args: Prisma.cartDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.cartUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.cartUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$cartPayload>
          }
          aggregate: {
            args: Prisma.CartAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCart>
          }
          groupBy: {
            args: Prisma.cartGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CartGroupByOutputType>[]
          }
          count: {
            args: Prisma.cartCountArgs<ExtArgs>,
            result: $Utils.Optional<CartCountAggregateOutputType> | number
          }
        }
      }
      order: {
        payload: Prisma.$orderPayload<ExtArgs>
        fields: Prisma.orderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.orderFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$orderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.orderFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$orderPayload>
          }
          findFirst: {
            args: Prisma.orderFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$orderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.orderFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$orderPayload>
          }
          findMany: {
            args: Prisma.orderFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$orderPayload>[]
          }
          create: {
            args: Prisma.orderCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$orderPayload>
          }
          createMany: {
            args: Prisma.orderCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.orderDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$orderPayload>
          }
          update: {
            args: Prisma.orderUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$orderPayload>
          }
          deleteMany: {
            args: Prisma.orderDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.orderUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.orderUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$orderPayload>
          }
          aggregate: {
            args: Prisma.OrderAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateOrder>
          }
          groupBy: {
            args: Prisma.orderGroupByArgs<ExtArgs>,
            result: $Utils.Optional<OrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.orderCountArgs<ExtArgs>,
            result: $Utils.Optional<OrderCountAggregateOutputType> | number
          }
        }
      }
      order_product: {
        payload: Prisma.$order_productPayload<ExtArgs>
        fields: Prisma.order_productFieldRefs
        operations: {
          findUnique: {
            args: Prisma.order_productFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$order_productPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.order_productFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$order_productPayload>
          }
          findFirst: {
            args: Prisma.order_productFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$order_productPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.order_productFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$order_productPayload>
          }
          findMany: {
            args: Prisma.order_productFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$order_productPayload>[]
          }
          create: {
            args: Prisma.order_productCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$order_productPayload>
          }
          createMany: {
            args: Prisma.order_productCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.order_productDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$order_productPayload>
          }
          update: {
            args: Prisma.order_productUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$order_productPayload>
          }
          deleteMany: {
            args: Prisma.order_productDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.order_productUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.order_productUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$order_productPayload>
          }
          aggregate: {
            args: Prisma.Order_productAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateOrder_product>
          }
          groupBy: {
            args: Prisma.order_productGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Order_productGroupByOutputType>[]
          }
          count: {
            args: Prisma.order_productCountArgs<ExtArgs>,
            result: $Utils.Optional<Order_productCountAggregateOutputType> | number
          }
        }
      }
      setting: {
        payload: Prisma.$settingPayload<ExtArgs>
        fields: Prisma.settingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.settingFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$settingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.settingFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$settingPayload>
          }
          findFirst: {
            args: Prisma.settingFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$settingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.settingFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$settingPayload>
          }
          findMany: {
            args: Prisma.settingFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$settingPayload>[]
          }
          create: {
            args: Prisma.settingCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$settingPayload>
          }
          createMany: {
            args: Prisma.settingCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.settingDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$settingPayload>
          }
          update: {
            args: Prisma.settingUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$settingPayload>
          }
          deleteMany: {
            args: Prisma.settingDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.settingUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.settingUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$settingPayload>
          }
          aggregate: {
            args: Prisma.SettingAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSetting>
          }
          groupBy: {
            args: Prisma.settingGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SettingGroupByOutputType>[]
          }
          count: {
            args: Prisma.settingCountArgs<ExtArgs>,
            result: $Utils.Optional<SettingCountAggregateOutputType> | number
          }
        }
      }
      setting_service: {
        payload: Prisma.$setting_servicePayload<ExtArgs>
        fields: Prisma.setting_serviceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.setting_serviceFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$setting_servicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.setting_serviceFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$setting_servicePayload>
          }
          findFirst: {
            args: Prisma.setting_serviceFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$setting_servicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.setting_serviceFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$setting_servicePayload>
          }
          findMany: {
            args: Prisma.setting_serviceFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$setting_servicePayload>[]
          }
          create: {
            args: Prisma.setting_serviceCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$setting_servicePayload>
          }
          createMany: {
            args: Prisma.setting_serviceCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.setting_serviceDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$setting_servicePayload>
          }
          update: {
            args: Prisma.setting_serviceUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$setting_servicePayload>
          }
          deleteMany: {
            args: Prisma.setting_serviceDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.setting_serviceUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.setting_serviceUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$setting_servicePayload>
          }
          aggregate: {
            args: Prisma.Setting_serviceAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSetting_service>
          }
          groupBy: {
            args: Prisma.setting_serviceGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Setting_serviceGroupByOutputType>[]
          }
          count: {
            args: Prisma.setting_serviceCountArgs<ExtArgs>,
            result: $Utils.Optional<Setting_serviceCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type AdminCountOutputType
   */

  export type AdminCountOutputType = {
    user_credit_transaction: number
    user_point_transaction: number
    product_review: number
    product: number
  }

  export type AdminCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user_credit_transaction?: boolean | AdminCountOutputTypeCountUser_credit_transactionArgs
    user_point_transaction?: boolean | AdminCountOutputTypeCountUser_point_transactionArgs
    product_review?: boolean | AdminCountOutputTypeCountProduct_reviewArgs
    product?: boolean | AdminCountOutputTypeCountProductArgs
  }

  // Custom InputTypes

  /**
   * AdminCountOutputType without action
   */
  export type AdminCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminCountOutputType
     */
    select?: AdminCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * AdminCountOutputType without action
   */
  export type AdminCountOutputTypeCountUser_credit_transactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: user_credit_transactionWhereInput
  }


  /**
   * AdminCountOutputType without action
   */
  export type AdminCountOutputTypeCountUser_point_transactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: user_point_transactionWhereInput
  }


  /**
   * AdminCountOutputType without action
   */
  export type AdminCountOutputTypeCountProduct_reviewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: product_reviewWhereInput
  }


  /**
   * AdminCountOutputType without action
   */
  export type AdminCountOutputTypeCountProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: productWhereInput
  }



  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    address: number
    user_credit_transaction: number
    payment_transaction: number
    user_point_transaction: number
    product_review: number
    cart: number
    order: number
    order_product: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    address?: boolean | UserCountOutputTypeCountAddressArgs
    user_credit_transaction?: boolean | UserCountOutputTypeCountUser_credit_transactionArgs
    payment_transaction?: boolean | UserCountOutputTypeCountPayment_transactionArgs
    user_point_transaction?: boolean | UserCountOutputTypeCountUser_point_transactionArgs
    product_review?: boolean | UserCountOutputTypeCountProduct_reviewArgs
    cart?: boolean | UserCountOutputTypeCountCartArgs
    order?: boolean | UserCountOutputTypeCountOrderArgs
    order_product?: boolean | UserCountOutputTypeCountOrder_productArgs
  }

  // Custom InputTypes

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAddressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: addressWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUser_credit_transactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: user_credit_transactionWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPayment_transactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: payment_transactionWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUser_point_transactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: user_point_transactionWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProduct_reviewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: product_reviewWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCartArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: cartWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOrderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: orderWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOrder_productArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: order_productWhereInput
  }



  /**
   * Count Type AddressCountOutputType
   */

  export type AddressCountOutputType = {
    order: number
  }

  export type AddressCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | AddressCountOutputTypeCountOrderArgs
  }

  // Custom InputTypes

  /**
   * AddressCountOutputType without action
   */
  export type AddressCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddressCountOutputType
     */
    select?: AddressCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * AddressCountOutputType without action
   */
  export type AddressCountOutputTypeCountOrderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: orderWhereInput
  }



  /**
   * Count Type BrandCountOutputType
   */

  export type BrandCountOutputType = {
    product: number
  }

  export type BrandCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | BrandCountOutputTypeCountProductArgs
  }

  // Custom InputTypes

  /**
   * BrandCountOutputType without action
   */
  export type BrandCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BrandCountOutputType
     */
    select?: BrandCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * BrandCountOutputType without action
   */
  export type BrandCountOutputTypeCountProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: productWhereInput
  }



  /**
   * Count Type TagCountOutputType
   */

  export type TagCountOutputType = {
    product_tag: number
  }

  export type TagCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product_tag?: boolean | TagCountOutputTypeCountProduct_tagArgs
  }

  // Custom InputTypes

  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagCountOutputType
     */
    select?: TagCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeCountProduct_tagArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: product_tagWhereInput
  }



  /**
   * Count Type CategoryCountOutputType
   */

  export type CategoryCountOutputType = {
    sub_category: number
  }

  export type CategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sub_category?: boolean | CategoryCountOutputTypeCountSub_categoryArgs
  }

  // Custom InputTypes

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryCountOutputType
     */
    select?: CategoryCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountSub_categoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: sub_categoryWhereInput
  }



  /**
   * Count Type ProductCountOutputType
   */

  export type ProductCountOutputType = {
    product_image: number
    product_spec: number
    product_detail: number
    product_option_first: number
    product_option_second: number
    product_price: number
    product_wholesale: number
    product_review: number
    product_tag: number
    cart: number
    order_product: number
  }

  export type ProductCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product_image?: boolean | ProductCountOutputTypeCountProduct_imageArgs
    product_spec?: boolean | ProductCountOutputTypeCountProduct_specArgs
    product_detail?: boolean | ProductCountOutputTypeCountProduct_detailArgs
    product_option_first?: boolean | ProductCountOutputTypeCountProduct_option_firstArgs
    product_option_second?: boolean | ProductCountOutputTypeCountProduct_option_secondArgs
    product_price?: boolean | ProductCountOutputTypeCountProduct_priceArgs
    product_wholesale?: boolean | ProductCountOutputTypeCountProduct_wholesaleArgs
    product_review?: boolean | ProductCountOutputTypeCountProduct_reviewArgs
    product_tag?: boolean | ProductCountOutputTypeCountProduct_tagArgs
    cart?: boolean | ProductCountOutputTypeCountCartArgs
    order_product?: boolean | ProductCountOutputTypeCountOrder_productArgs
  }

  // Custom InputTypes

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCountOutputType
     */
    select?: ProductCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountProduct_imageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: product_imageWhereInput
  }


  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountProduct_specArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: product_specWhereInput
  }


  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountProduct_detailArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: product_detailWhereInput
  }


  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountProduct_option_firstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: product_option_firstWhereInput
  }


  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountProduct_option_secondArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: product_option_secondWhereInput
  }


  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountProduct_priceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: product_priceWhereInput
  }


  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountProduct_wholesaleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: product_wholesaleWhereInput
  }


  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountProduct_reviewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: product_reviewWhereInput
  }


  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountProduct_tagArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: product_tagWhereInput
  }


  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountCartArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: cartWhereInput
  }


  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountOrder_productArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: order_productWhereInput
  }



  /**
   * Count Type Product_option_firstCountOutputType
   */

  export type Product_option_firstCountOutputType = {
    product_price: number
  }

  export type Product_option_firstCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product_price?: boolean | Product_option_firstCountOutputTypeCountProduct_priceArgs
  }

  // Custom InputTypes

  /**
   * Product_option_firstCountOutputType without action
   */
  export type Product_option_firstCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product_option_firstCountOutputType
     */
    select?: Product_option_firstCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * Product_option_firstCountOutputType without action
   */
  export type Product_option_firstCountOutputTypeCountProduct_priceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: product_priceWhereInput
  }



  /**
   * Count Type Product_option_secondCountOutputType
   */

  export type Product_option_secondCountOutputType = {
    product_price: number
  }

  export type Product_option_secondCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product_price?: boolean | Product_option_secondCountOutputTypeCountProduct_priceArgs
  }

  // Custom InputTypes

  /**
   * Product_option_secondCountOutputType without action
   */
  export type Product_option_secondCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product_option_secondCountOutputType
     */
    select?: Product_option_secondCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * Product_option_secondCountOutputType without action
   */
  export type Product_option_secondCountOutputTypeCountProduct_priceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: product_priceWhereInput
  }



  /**
   * Count Type Product_priceCountOutputType
   */

  export type Product_priceCountOutputType = {
    cart: number
    order_product: number
  }

  export type Product_priceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cart?: boolean | Product_priceCountOutputTypeCountCartArgs
    order_product?: boolean | Product_priceCountOutputTypeCountOrder_productArgs
  }

  // Custom InputTypes

  /**
   * Product_priceCountOutputType without action
   */
  export type Product_priceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product_priceCountOutputType
     */
    select?: Product_priceCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * Product_priceCountOutputType without action
   */
  export type Product_priceCountOutputTypeCountCartArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: cartWhereInput
  }


  /**
   * Product_priceCountOutputType without action
   */
  export type Product_priceCountOutputTypeCountOrder_productArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: order_productWhereInput
  }



  /**
   * Count Type OrderCountOutputType
   */

  export type OrderCountOutputType = {
    order_product: number
  }

  export type OrderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order_product?: boolean | OrderCountOutputTypeCountOrder_productArgs
  }

  // Custom InputTypes

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderCountOutputType
     */
    select?: OrderCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountOrder_productArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: order_productWhereInput
  }



  /**
   * Models
   */

  /**
   * Model admin
   */

  export type AggregateAdmin = {
    _count: AdminCountAggregateOutputType | null
    _avg: AdminAvgAggregateOutputType | null
    _sum: AdminSumAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  export type AdminAvgAggregateOutputType = {
    id: number | null
  }

  export type AdminSumAggregateOutputType = {
    id: number | null
  }

  export type AdminMinAggregateOutputType = {
    id: number | null
    userName: string | null
    fname: string | null
    lname: string | null
    fullname: string | null
    role: string | null
    email: string | null
    avatarPath: string | null
    avatarSrc: string | null
    phone: string | null
    refreshToken: string | null
    password: string | null
    passwordRt: string | null
    ipv4: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdminMaxAggregateOutputType = {
    id: number | null
    userName: string | null
    fname: string | null
    lname: string | null
    fullname: string | null
    role: string | null
    email: string | null
    avatarPath: string | null
    avatarSrc: string | null
    phone: string | null
    refreshToken: string | null
    password: string | null
    passwordRt: string | null
    ipv4: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdminCountAggregateOutputType = {
    id: number
    userName: number
    fname: number
    lname: number
    fullname: number
    role: number
    permission: number
    email: number
    avatarPath: number
    avatarSrc: number
    phone: number
    refreshToken: number
    password: number
    passwordRt: number
    ipv4: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AdminAvgAggregateInputType = {
    id?: true
  }

  export type AdminSumAggregateInputType = {
    id?: true
  }

  export type AdminMinAggregateInputType = {
    id?: true
    userName?: true
    fname?: true
    lname?: true
    fullname?: true
    role?: true
    email?: true
    avatarPath?: true
    avatarSrc?: true
    phone?: true
    refreshToken?: true
    password?: true
    passwordRt?: true
    ipv4?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdminMaxAggregateInputType = {
    id?: true
    userName?: true
    fname?: true
    lname?: true
    fullname?: true
    role?: true
    email?: true
    avatarPath?: true
    avatarSrc?: true
    phone?: true
    refreshToken?: true
    password?: true
    passwordRt?: true
    ipv4?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdminCountAggregateInputType = {
    id?: true
    userName?: true
    fname?: true
    lname?: true
    fullname?: true
    role?: true
    permission?: true
    email?: true
    avatarPath?: true
    avatarSrc?: true
    phone?: true
    refreshToken?: true
    password?: true
    passwordRt?: true
    ipv4?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AdminAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which admin to aggregate.
     */
    where?: adminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of admins to fetch.
     */
    orderBy?: adminOrderByWithRelationInput | adminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: adminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned admins
    **/
    _count?: true | AdminCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdminAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdminSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminMaxAggregateInputType
  }

  export type GetAdminAggregateType<T extends AdminAggregateArgs> = {
        [P in keyof T & keyof AggregateAdmin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdmin[P]>
      : GetScalarType<T[P], AggregateAdmin[P]>
  }




  export type adminGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: adminWhereInput
    orderBy?: adminOrderByWithAggregationInput | adminOrderByWithAggregationInput[]
    by: AdminScalarFieldEnum[] | AdminScalarFieldEnum
    having?: adminScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminCountAggregateInputType | true
    _avg?: AdminAvgAggregateInputType
    _sum?: AdminSumAggregateInputType
    _min?: AdminMinAggregateInputType
    _max?: AdminMaxAggregateInputType
  }

  export type AdminGroupByOutputType = {
    id: number
    userName: string
    fname: string | null
    lname: string | null
    fullname: string | null
    role: string
    permission: JsonValue | null
    email: string
    avatarPath: string | null
    avatarSrc: string | null
    phone: string
    refreshToken: string | null
    password: string
    passwordRt: string | null
    ipv4: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: AdminCountAggregateOutputType | null
    _avg: AdminAvgAggregateOutputType | null
    _sum: AdminSumAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  type GetAdminGroupByPayload<T extends adminGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminGroupByOutputType[P]>
            : GetScalarType<T[P], AdminGroupByOutputType[P]>
        }
      >
    >


  export type adminSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userName?: boolean
    fname?: boolean
    lname?: boolean
    fullname?: boolean
    role?: boolean
    permission?: boolean
    email?: boolean
    avatarPath?: boolean
    avatarSrc?: boolean
    phone?: boolean
    refreshToken?: boolean
    password?: boolean
    passwordRt?: boolean
    ipv4?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user_credit_transaction?: boolean | admin$user_credit_transactionArgs<ExtArgs>
    user_point_transaction?: boolean | admin$user_point_transactionArgs<ExtArgs>
    product_review?: boolean | admin$product_reviewArgs<ExtArgs>
    product?: boolean | admin$productArgs<ExtArgs>
    _count?: boolean | AdminCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["admin"]>

  export type adminSelectScalar = {
    id?: boolean
    userName?: boolean
    fname?: boolean
    lname?: boolean
    fullname?: boolean
    role?: boolean
    permission?: boolean
    email?: boolean
    avatarPath?: boolean
    avatarSrc?: boolean
    phone?: boolean
    refreshToken?: boolean
    password?: boolean
    passwordRt?: boolean
    ipv4?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type adminInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user_credit_transaction?: boolean | admin$user_credit_transactionArgs<ExtArgs>
    user_point_transaction?: boolean | admin$user_point_transactionArgs<ExtArgs>
    product_review?: boolean | admin$product_reviewArgs<ExtArgs>
    product?: boolean | admin$productArgs<ExtArgs>
    _count?: boolean | AdminCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $adminPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "admin"
    objects: {
      user_credit_transaction: Prisma.$user_credit_transactionPayload<ExtArgs>[]
      user_point_transaction: Prisma.$user_point_transactionPayload<ExtArgs>[]
      product_review: Prisma.$product_reviewPayload<ExtArgs>[]
      product: Prisma.$productPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userName: string
      fname: string | null
      lname: string | null
      fullname: string | null
      role: string
      permission: Prisma.JsonValue | null
      email: string
      avatarPath: string | null
      avatarSrc: string | null
      phone: string
      refreshToken: string | null
      password: string
      passwordRt: string | null
      ipv4: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["admin"]>
    composites: {}
  }


  type adminGetPayload<S extends boolean | null | undefined | adminDefaultArgs> = $Result.GetResult<Prisma.$adminPayload, S>

  type adminCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<adminFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AdminCountAggregateInputType | true
    }

  export interface adminDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['admin'], meta: { name: 'admin' } }
    /**
     * Find zero or one Admin that matches the filter.
     * @param {adminFindUniqueArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends adminFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, adminFindUniqueArgs<ExtArgs>>
    ): Prisma__adminClient<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Admin that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {adminFindUniqueOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends adminFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, adminFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__adminClient<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Admin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {adminFindFirstArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends adminFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, adminFindFirstArgs<ExtArgs>>
    ): Prisma__adminClient<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Admin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {adminFindFirstOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends adminFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, adminFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__adminClient<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Admins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {adminFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Admins
     * const admins = await prisma.admin.findMany()
     * 
     * // Get first 10 Admins
     * const admins = await prisma.admin.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminWithIdOnly = await prisma.admin.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends adminFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, adminFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Admin.
     * @param {adminCreateArgs} args - Arguments to create a Admin.
     * @example
     * // Create one Admin
     * const Admin = await prisma.admin.create({
     *   data: {
     *     // ... data to create a Admin
     *   }
     * })
     * 
    **/
    create<T extends adminCreateArgs<ExtArgs>>(
      args: SelectSubset<T, adminCreateArgs<ExtArgs>>
    ): Prisma__adminClient<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Admins.
     *     @param {adminCreateManyArgs} args - Arguments to create many Admins.
     *     @example
     *     // Create many Admins
     *     const admin = await prisma.admin.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends adminCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, adminCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Admin.
     * @param {adminDeleteArgs} args - Arguments to delete one Admin.
     * @example
     * // Delete one Admin
     * const Admin = await prisma.admin.delete({
     *   where: {
     *     // ... filter to delete one Admin
     *   }
     * })
     * 
    **/
    delete<T extends adminDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, adminDeleteArgs<ExtArgs>>
    ): Prisma__adminClient<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Admin.
     * @param {adminUpdateArgs} args - Arguments to update one Admin.
     * @example
     * // Update one Admin
     * const admin = await prisma.admin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends adminUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, adminUpdateArgs<ExtArgs>>
    ): Prisma__adminClient<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Admins.
     * @param {adminDeleteManyArgs} args - Arguments to filter Admins to delete.
     * @example
     * // Delete a few Admins
     * const { count } = await prisma.admin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends adminDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, adminDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {adminUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Admins
     * const admin = await prisma.admin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends adminUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, adminUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Admin.
     * @param {adminUpsertArgs} args - Arguments to update or create a Admin.
     * @example
     * // Update or create a Admin
     * const admin = await prisma.admin.upsert({
     *   create: {
     *     // ... data to create a Admin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Admin we want to update
     *   }
     * })
    **/
    upsert<T extends adminUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, adminUpsertArgs<ExtArgs>>
    ): Prisma__adminClient<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {adminCountArgs} args - Arguments to filter Admins to count.
     * @example
     * // Count the number of Admins
     * const count = await prisma.admin.count({
     *   where: {
     *     // ... the filter for the Admins we want to count
     *   }
     * })
    **/
    count<T extends adminCountArgs>(
      args?: Subset<T, adminCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminAggregateArgs>(args: Subset<T, AdminAggregateArgs>): Prisma.PrismaPromise<GetAdminAggregateType<T>>

    /**
     * Group by Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {adminGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends adminGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: adminGroupByArgs['orderBy'] }
        : { orderBy?: adminGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, adminGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the admin model
   */
  readonly fields: adminFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for admin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__adminClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user_credit_transaction<T extends admin$user_credit_transactionArgs<ExtArgs> = {}>(args?: Subset<T, admin$user_credit_transactionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_credit_transactionPayload<ExtArgs>, T, 'findMany'> | Null>;

    user_point_transaction<T extends admin$user_point_transactionArgs<ExtArgs> = {}>(args?: Subset<T, admin$user_point_transactionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_point_transactionPayload<ExtArgs>, T, 'findMany'> | Null>;

    product_review<T extends admin$product_reviewArgs<ExtArgs> = {}>(args?: Subset<T, admin$product_reviewArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$product_reviewPayload<ExtArgs>, T, 'findMany'> | Null>;

    product<T extends admin$productArgs<ExtArgs> = {}>(args?: Subset<T, admin$productArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$productPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the admin model
   */ 
  interface adminFieldRefs {
    readonly id: FieldRef<"admin", 'Int'>
    readonly userName: FieldRef<"admin", 'String'>
    readonly fname: FieldRef<"admin", 'String'>
    readonly lname: FieldRef<"admin", 'String'>
    readonly fullname: FieldRef<"admin", 'String'>
    readonly role: FieldRef<"admin", 'String'>
    readonly permission: FieldRef<"admin", 'Json'>
    readonly email: FieldRef<"admin", 'String'>
    readonly avatarPath: FieldRef<"admin", 'String'>
    readonly avatarSrc: FieldRef<"admin", 'String'>
    readonly phone: FieldRef<"admin", 'String'>
    readonly refreshToken: FieldRef<"admin", 'String'>
    readonly password: FieldRef<"admin", 'String'>
    readonly passwordRt: FieldRef<"admin", 'String'>
    readonly ipv4: FieldRef<"admin", 'String'>
    readonly isActive: FieldRef<"admin", 'Boolean'>
    readonly createdAt: FieldRef<"admin", 'DateTime'>
    readonly updatedAt: FieldRef<"admin", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * admin findUnique
   */
  export type adminFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: adminInclude<ExtArgs> | null
    /**
     * Filter, which admin to fetch.
     */
    where: adminWhereUniqueInput
  }


  /**
   * admin findUniqueOrThrow
   */
  export type adminFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: adminInclude<ExtArgs> | null
    /**
     * Filter, which admin to fetch.
     */
    where: adminWhereUniqueInput
  }


  /**
   * admin findFirst
   */
  export type adminFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: adminInclude<ExtArgs> | null
    /**
     * Filter, which admin to fetch.
     */
    where?: adminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of admins to fetch.
     */
    orderBy?: adminOrderByWithRelationInput | adminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for admins.
     */
    cursor?: adminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of admins.
     */
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }


  /**
   * admin findFirstOrThrow
   */
  export type adminFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: adminInclude<ExtArgs> | null
    /**
     * Filter, which admin to fetch.
     */
    where?: adminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of admins to fetch.
     */
    orderBy?: adminOrderByWithRelationInput | adminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for admins.
     */
    cursor?: adminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of admins.
     */
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }


  /**
   * admin findMany
   */
  export type adminFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: adminInclude<ExtArgs> | null
    /**
     * Filter, which admins to fetch.
     */
    where?: adminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of admins to fetch.
     */
    orderBy?: adminOrderByWithRelationInput | adminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing admins.
     */
    cursor?: adminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` admins.
     */
    skip?: number
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }


  /**
   * admin create
   */
  export type adminCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: adminInclude<ExtArgs> | null
    /**
     * The data needed to create a admin.
     */
    data: XOR<adminCreateInput, adminUncheckedCreateInput>
  }


  /**
   * admin createMany
   */
  export type adminCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many admins.
     */
    data: adminCreateManyInput | adminCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * admin update
   */
  export type adminUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: adminInclude<ExtArgs> | null
    /**
     * The data needed to update a admin.
     */
    data: XOR<adminUpdateInput, adminUncheckedUpdateInput>
    /**
     * Choose, which admin to update.
     */
    where: adminWhereUniqueInput
  }


  /**
   * admin updateMany
   */
  export type adminUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update admins.
     */
    data: XOR<adminUpdateManyMutationInput, adminUncheckedUpdateManyInput>
    /**
     * Filter which admins to update
     */
    where?: adminWhereInput
  }


  /**
   * admin upsert
   */
  export type adminUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: adminInclude<ExtArgs> | null
    /**
     * The filter to search for the admin to update in case it exists.
     */
    where: adminWhereUniqueInput
    /**
     * In case the admin found by the `where` argument doesn't exist, create a new admin with this data.
     */
    create: XOR<adminCreateInput, adminUncheckedCreateInput>
    /**
     * In case the admin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<adminUpdateInput, adminUncheckedUpdateInput>
  }


  /**
   * admin delete
   */
  export type adminDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: adminInclude<ExtArgs> | null
    /**
     * Filter which admin to delete.
     */
    where: adminWhereUniqueInput
  }


  /**
   * admin deleteMany
   */
  export type adminDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which admins to delete
     */
    where?: adminWhereInput
  }


  /**
   * admin.user_credit_transaction
   */
  export type admin$user_credit_transactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_credit_transaction
     */
    select?: user_credit_transactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_credit_transactionInclude<ExtArgs> | null
    where?: user_credit_transactionWhereInput
    orderBy?: user_credit_transactionOrderByWithRelationInput | user_credit_transactionOrderByWithRelationInput[]
    cursor?: user_credit_transactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: User_credit_transactionScalarFieldEnum | User_credit_transactionScalarFieldEnum[]
  }


  /**
   * admin.user_point_transaction
   */
  export type admin$user_point_transactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_point_transaction
     */
    select?: user_point_transactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_point_transactionInclude<ExtArgs> | null
    where?: user_point_transactionWhereInput
    orderBy?: user_point_transactionOrderByWithRelationInput | user_point_transactionOrderByWithRelationInput[]
    cursor?: user_point_transactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: User_point_transactionScalarFieldEnum | User_point_transactionScalarFieldEnum[]
  }


  /**
   * admin.product_review
   */
  export type admin$product_reviewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_review
     */
    select?: product_reviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: product_reviewInclude<ExtArgs> | null
    where?: product_reviewWhereInput
    orderBy?: product_reviewOrderByWithRelationInput | product_reviewOrderByWithRelationInput[]
    cursor?: product_reviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Product_reviewScalarFieldEnum | Product_reviewScalarFieldEnum[]
  }


  /**
   * admin.product
   */
  export type admin$productArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: productInclude<ExtArgs> | null
    where?: productWhereInput
    orderBy?: productOrderByWithRelationInput | productOrderByWithRelationInput[]
    cursor?: productWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }


  /**
   * admin without action
   */
  export type adminDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: adminInclude<ExtArgs> | null
  }



  /**
   * Model user
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
    credit: number | null
    point: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
    credit: number | null
    point: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    avatarPath: string | null
    avatarSrc: string | null
    fname: string | null
    lname: string | null
    fullname: string | null
    email: string | null
    phone: string | null
    credit: number | null
    point: number | null
    lineId: string | null
    baned: boolean | null
    ipv4: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    avatarPath: string | null
    avatarSrc: string | null
    fname: string | null
    lname: string | null
    fullname: string | null
    email: string | null
    phone: string | null
    credit: number | null
    point: number | null
    lineId: string | null
    baned: boolean | null
    ipv4: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    avatarPath: number
    avatarSrc: number
    fname: number
    lname: number
    fullname: number
    email: number
    phone: number
    credit: number
    point: number
    lineId: number
    baned: number
    ipv4: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
    credit?: true
    point?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
    credit?: true
    point?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    avatarPath?: true
    avatarSrc?: true
    fname?: true
    lname?: true
    fullname?: true
    email?: true
    phone?: true
    credit?: true
    point?: true
    lineId?: true
    baned?: true
    ipv4?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    avatarPath?: true
    avatarSrc?: true
    fname?: true
    lname?: true
    fullname?: true
    email?: true
    phone?: true
    credit?: true
    point?: true
    lineId?: true
    baned?: true
    ipv4?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    avatarPath?: true
    avatarSrc?: true
    fname?: true
    lname?: true
    fullname?: true
    email?: true
    phone?: true
    credit?: true
    point?: true
    lineId?: true
    baned?: true
    ipv4?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user to aggregate.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type userGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: userWhereInput
    orderBy?: userOrderByWithAggregationInput | userOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: userScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    avatarPath: string | null
    avatarSrc: string | null
    fname: string | null
    lname: string | null
    fullname: string | null
    email: string
    phone: string
    credit: number
    point: number
    lineId: string | null
    baned: boolean
    ipv4: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends userGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type userSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    avatarPath?: boolean
    avatarSrc?: boolean
    fname?: boolean
    lname?: boolean
    fullname?: boolean
    email?: boolean
    phone?: boolean
    credit?: boolean
    point?: boolean
    lineId?: boolean
    baned?: boolean
    ipv4?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    address?: boolean | user$addressArgs<ExtArgs>
    user_credit_transaction?: boolean | user$user_credit_transactionArgs<ExtArgs>
    payment_transaction?: boolean | user$payment_transactionArgs<ExtArgs>
    user_point_transaction?: boolean | user$user_point_transactionArgs<ExtArgs>
    product_review?: boolean | user$product_reviewArgs<ExtArgs>
    cart?: boolean | user$cartArgs<ExtArgs>
    order?: boolean | user$orderArgs<ExtArgs>
    order_product?: boolean | user$order_productArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type userSelectScalar = {
    id?: boolean
    avatarPath?: boolean
    avatarSrc?: boolean
    fname?: boolean
    lname?: boolean
    fullname?: boolean
    email?: boolean
    phone?: boolean
    credit?: boolean
    point?: boolean
    lineId?: boolean
    baned?: boolean
    ipv4?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type userInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    address?: boolean | user$addressArgs<ExtArgs>
    user_credit_transaction?: boolean | user$user_credit_transactionArgs<ExtArgs>
    payment_transaction?: boolean | user$payment_transactionArgs<ExtArgs>
    user_point_transaction?: boolean | user$user_point_transactionArgs<ExtArgs>
    product_review?: boolean | user$product_reviewArgs<ExtArgs>
    cart?: boolean | user$cartArgs<ExtArgs>
    order?: boolean | user$orderArgs<ExtArgs>
    order_product?: boolean | user$order_productArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $userPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "user"
    objects: {
      address: Prisma.$addressPayload<ExtArgs>[]
      user_credit_transaction: Prisma.$user_credit_transactionPayload<ExtArgs>[]
      payment_transaction: Prisma.$payment_transactionPayload<ExtArgs>[]
      user_point_transaction: Prisma.$user_point_transactionPayload<ExtArgs>[]
      product_review: Prisma.$product_reviewPayload<ExtArgs>[]
      cart: Prisma.$cartPayload<ExtArgs>[]
      order: Prisma.$orderPayload<ExtArgs>[]
      order_product: Prisma.$order_productPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      avatarPath: string | null
      avatarSrc: string | null
      fname: string | null
      lname: string | null
      fullname: string | null
      email: string
      phone: string
      credit: number
      point: number
      lineId: string | null
      baned: boolean
      ipv4: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }


  type userGetPayload<S extends boolean | null | undefined | userDefaultArgs> = $Result.GetResult<Prisma.$userPayload, S>

  type userCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<userFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface userDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['user'], meta: { name: 'user' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {userFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends userFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, userFindUniqueArgs<ExtArgs>>
    ): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {userFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends userFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, userFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends userFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, userFindFirstArgs<ExtArgs>>
    ): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends userFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, userFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends userFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, userFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a User.
     * @param {userCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends userCreateArgs<ExtArgs>>(
      args: SelectSubset<T, userCreateArgs<ExtArgs>>
    ): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Users.
     *     @param {userCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends userCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, userCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {userDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends userDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, userDeleteArgs<ExtArgs>>
    ): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one User.
     * @param {userUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends userUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, userUpdateArgs<ExtArgs>>
    ): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {userDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends userDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, userDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends userUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, userUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {userUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends userUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, userUpsertArgs<ExtArgs>>
    ): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends userCountArgs>(
      args?: Subset<T, userCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends userGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: userGroupByArgs['orderBy'] }
        : { orderBy?: userGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, userGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the user model
   */
  readonly fields: userFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for user.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__userClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    address<T extends user$addressArgs<ExtArgs> = {}>(args?: Subset<T, user$addressArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$addressPayload<ExtArgs>, T, 'findMany'> | Null>;

    user_credit_transaction<T extends user$user_credit_transactionArgs<ExtArgs> = {}>(args?: Subset<T, user$user_credit_transactionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_credit_transactionPayload<ExtArgs>, T, 'findMany'> | Null>;

    payment_transaction<T extends user$payment_transactionArgs<ExtArgs> = {}>(args?: Subset<T, user$payment_transactionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$payment_transactionPayload<ExtArgs>, T, 'findMany'> | Null>;

    user_point_transaction<T extends user$user_point_transactionArgs<ExtArgs> = {}>(args?: Subset<T, user$user_point_transactionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_point_transactionPayload<ExtArgs>, T, 'findMany'> | Null>;

    product_review<T extends user$product_reviewArgs<ExtArgs> = {}>(args?: Subset<T, user$product_reviewArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$product_reviewPayload<ExtArgs>, T, 'findMany'> | Null>;

    cart<T extends user$cartArgs<ExtArgs> = {}>(args?: Subset<T, user$cartArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$cartPayload<ExtArgs>, T, 'findMany'> | Null>;

    order<T extends user$orderArgs<ExtArgs> = {}>(args?: Subset<T, user$orderArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$orderPayload<ExtArgs>, T, 'findMany'> | Null>;

    order_product<T extends user$order_productArgs<ExtArgs> = {}>(args?: Subset<T, user$order_productArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$order_productPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the user model
   */ 
  interface userFieldRefs {
    readonly id: FieldRef<"user", 'Int'>
    readonly avatarPath: FieldRef<"user", 'String'>
    readonly avatarSrc: FieldRef<"user", 'String'>
    readonly fname: FieldRef<"user", 'String'>
    readonly lname: FieldRef<"user", 'String'>
    readonly fullname: FieldRef<"user", 'String'>
    readonly email: FieldRef<"user", 'String'>
    readonly phone: FieldRef<"user", 'String'>
    readonly credit: FieldRef<"user", 'Float'>
    readonly point: FieldRef<"user", 'Float'>
    readonly lineId: FieldRef<"user", 'String'>
    readonly baned: FieldRef<"user", 'Boolean'>
    readonly ipv4: FieldRef<"user", 'String'>
    readonly isActive: FieldRef<"user", 'Boolean'>
    readonly createdAt: FieldRef<"user", 'DateTime'>
    readonly updatedAt: FieldRef<"user", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * user findUnique
   */
  export type userFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where: userWhereUniqueInput
  }


  /**
   * user findUniqueOrThrow
   */
  export type userFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where: userWhereUniqueInput
  }


  /**
   * user findFirst
   */
  export type userFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * user findFirstOrThrow
   */
  export type userFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * user findMany
   */
  export type userFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * user create
   */
  export type userCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
    /**
     * The data needed to create a user.
     */
    data: XOR<userCreateInput, userUncheckedCreateInput>
  }


  /**
   * user createMany
   */
  export type userCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many users.
     */
    data: userCreateManyInput | userCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * user update
   */
  export type userUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
    /**
     * The data needed to update a user.
     */
    data: XOR<userUpdateInput, userUncheckedUpdateInput>
    /**
     * Choose, which user to update.
     */
    where: userWhereUniqueInput
  }


  /**
   * user updateMany
   */
  export type userUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update users.
     */
    data: XOR<userUpdateManyMutationInput, userUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: userWhereInput
  }


  /**
   * user upsert
   */
  export type userUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
    /**
     * The filter to search for the user to update in case it exists.
     */
    where: userWhereUniqueInput
    /**
     * In case the user found by the `where` argument doesn't exist, create a new user with this data.
     */
    create: XOR<userCreateInput, userUncheckedCreateInput>
    /**
     * In case the user was found with the provided `where` argument, update it with this data.
     */
    update: XOR<userUpdateInput, userUncheckedUpdateInput>
  }


  /**
   * user delete
   */
  export type userDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter which user to delete.
     */
    where: userWhereUniqueInput
  }


  /**
   * user deleteMany
   */
  export type userDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to delete
     */
    where?: userWhereInput
  }


  /**
   * user.address
   */
  export type user$addressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the address
     */
    select?: addressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: addressInclude<ExtArgs> | null
    where?: addressWhereInput
    orderBy?: addressOrderByWithRelationInput | addressOrderByWithRelationInput[]
    cursor?: addressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[]
  }


  /**
   * user.user_credit_transaction
   */
  export type user$user_credit_transactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_credit_transaction
     */
    select?: user_credit_transactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_credit_transactionInclude<ExtArgs> | null
    where?: user_credit_transactionWhereInput
    orderBy?: user_credit_transactionOrderByWithRelationInput | user_credit_transactionOrderByWithRelationInput[]
    cursor?: user_credit_transactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: User_credit_transactionScalarFieldEnum | User_credit_transactionScalarFieldEnum[]
  }


  /**
   * user.payment_transaction
   */
  export type user$payment_transactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_transaction
     */
    select?: payment_transactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: payment_transactionInclude<ExtArgs> | null
    where?: payment_transactionWhereInput
    orderBy?: payment_transactionOrderByWithRelationInput | payment_transactionOrderByWithRelationInput[]
    cursor?: payment_transactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Payment_transactionScalarFieldEnum | Payment_transactionScalarFieldEnum[]
  }


  /**
   * user.user_point_transaction
   */
  export type user$user_point_transactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_point_transaction
     */
    select?: user_point_transactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_point_transactionInclude<ExtArgs> | null
    where?: user_point_transactionWhereInput
    orderBy?: user_point_transactionOrderByWithRelationInput | user_point_transactionOrderByWithRelationInput[]
    cursor?: user_point_transactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: User_point_transactionScalarFieldEnum | User_point_transactionScalarFieldEnum[]
  }


  /**
   * user.product_review
   */
  export type user$product_reviewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_review
     */
    select?: product_reviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: product_reviewInclude<ExtArgs> | null
    where?: product_reviewWhereInput
    orderBy?: product_reviewOrderByWithRelationInput | product_reviewOrderByWithRelationInput[]
    cursor?: product_reviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Product_reviewScalarFieldEnum | Product_reviewScalarFieldEnum[]
  }


  /**
   * user.cart
   */
  export type user$cartArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cart
     */
    select?: cartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: cartInclude<ExtArgs> | null
    where?: cartWhereInput
    orderBy?: cartOrderByWithRelationInput | cartOrderByWithRelationInput[]
    cursor?: cartWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CartScalarFieldEnum | CartScalarFieldEnum[]
  }


  /**
   * user.order
   */
  export type user$orderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order
     */
    select?: orderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: orderInclude<ExtArgs> | null
    where?: orderWhereInput
    orderBy?: orderOrderByWithRelationInput | orderOrderByWithRelationInput[]
    cursor?: orderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }


  /**
   * user.order_product
   */
  export type user$order_productArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_product
     */
    select?: order_productSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: order_productInclude<ExtArgs> | null
    where?: order_productWhereInput
    orderBy?: order_productOrderByWithRelationInput | order_productOrderByWithRelationInput[]
    cursor?: order_productWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Order_productScalarFieldEnum | Order_productScalarFieldEnum[]
  }


  /**
   * user without action
   */
  export type userDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
  }



  /**
   * Model user_credit_transaction
   */

  export type AggregateUser_credit_transaction = {
    _count: User_credit_transactionCountAggregateOutputType | null
    _avg: User_credit_transactionAvgAggregateOutputType | null
    _sum: User_credit_transactionSumAggregateOutputType | null
    _min: User_credit_transactionMinAggregateOutputType | null
    _max: User_credit_transactionMaxAggregateOutputType | null
  }

  export type User_credit_transactionAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    adminId: number | null
    beforeUpdate: number | null
    afterUpdate: number | null
    credit: number | null
  }

  export type User_credit_transactionSumAggregateOutputType = {
    id: number | null
    userId: number | null
    adminId: number | null
    beforeUpdate: number | null
    afterUpdate: number | null
    credit: number | null
  }

  export type User_credit_transactionMinAggregateOutputType = {
    id: number | null
    userId: number | null
    adminId: number | null
    updateBy: string | null
    updateType: string | null
    beforeUpdate: number | null
    afterUpdate: number | null
    credit: number | null
    remark: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type User_credit_transactionMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    adminId: number | null
    updateBy: string | null
    updateType: string | null
    beforeUpdate: number | null
    afterUpdate: number | null
    credit: number | null
    remark: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type User_credit_transactionCountAggregateOutputType = {
    id: number
    userId: number
    adminId: number
    updateBy: number
    updateType: number
    beforeUpdate: number
    afterUpdate: number
    credit: number
    remark: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type User_credit_transactionAvgAggregateInputType = {
    id?: true
    userId?: true
    adminId?: true
    beforeUpdate?: true
    afterUpdate?: true
    credit?: true
  }

  export type User_credit_transactionSumAggregateInputType = {
    id?: true
    userId?: true
    adminId?: true
    beforeUpdate?: true
    afterUpdate?: true
    credit?: true
  }

  export type User_credit_transactionMinAggregateInputType = {
    id?: true
    userId?: true
    adminId?: true
    updateBy?: true
    updateType?: true
    beforeUpdate?: true
    afterUpdate?: true
    credit?: true
    remark?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type User_credit_transactionMaxAggregateInputType = {
    id?: true
    userId?: true
    adminId?: true
    updateBy?: true
    updateType?: true
    beforeUpdate?: true
    afterUpdate?: true
    credit?: true
    remark?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type User_credit_transactionCountAggregateInputType = {
    id?: true
    userId?: true
    adminId?: true
    updateBy?: true
    updateType?: true
    beforeUpdate?: true
    afterUpdate?: true
    credit?: true
    remark?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type User_credit_transactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_credit_transaction to aggregate.
     */
    where?: user_credit_transactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_credit_transactions to fetch.
     */
    orderBy?: user_credit_transactionOrderByWithRelationInput | user_credit_transactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: user_credit_transactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_credit_transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_credit_transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned user_credit_transactions
    **/
    _count?: true | User_credit_transactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: User_credit_transactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: User_credit_transactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: User_credit_transactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: User_credit_transactionMaxAggregateInputType
  }

  export type GetUser_credit_transactionAggregateType<T extends User_credit_transactionAggregateArgs> = {
        [P in keyof T & keyof AggregateUser_credit_transaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser_credit_transaction[P]>
      : GetScalarType<T[P], AggregateUser_credit_transaction[P]>
  }




  export type user_credit_transactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: user_credit_transactionWhereInput
    orderBy?: user_credit_transactionOrderByWithAggregationInput | user_credit_transactionOrderByWithAggregationInput[]
    by: User_credit_transactionScalarFieldEnum[] | User_credit_transactionScalarFieldEnum
    having?: user_credit_transactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: User_credit_transactionCountAggregateInputType | true
    _avg?: User_credit_transactionAvgAggregateInputType
    _sum?: User_credit_transactionSumAggregateInputType
    _min?: User_credit_transactionMinAggregateInputType
    _max?: User_credit_transactionMaxAggregateInputType
  }

  export type User_credit_transactionGroupByOutputType = {
    id: number
    userId: number
    adminId: number | null
    updateBy: string
    updateType: string
    beforeUpdate: number
    afterUpdate: number
    credit: number
    remark: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: User_credit_transactionCountAggregateOutputType | null
    _avg: User_credit_transactionAvgAggregateOutputType | null
    _sum: User_credit_transactionSumAggregateOutputType | null
    _min: User_credit_transactionMinAggregateOutputType | null
    _max: User_credit_transactionMaxAggregateOutputType | null
  }

  type GetUser_credit_transactionGroupByPayload<T extends user_credit_transactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<User_credit_transactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof User_credit_transactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], User_credit_transactionGroupByOutputType[P]>
            : GetScalarType<T[P], User_credit_transactionGroupByOutputType[P]>
        }
      >
    >


  export type user_credit_transactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    adminId?: boolean
    updateBy?: boolean
    updateType?: boolean
    beforeUpdate?: boolean
    afterUpdate?: boolean
    credit?: boolean
    remark?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
    admin?: boolean | user_credit_transaction$adminArgs<ExtArgs>
  }, ExtArgs["result"]["user_credit_transaction"]>

  export type user_credit_transactionSelectScalar = {
    id?: boolean
    userId?: boolean
    adminId?: boolean
    updateBy?: boolean
    updateType?: boolean
    beforeUpdate?: boolean
    afterUpdate?: boolean
    credit?: boolean
    remark?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type user_credit_transactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
    admin?: boolean | user_credit_transaction$adminArgs<ExtArgs>
  }


  export type $user_credit_transactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "user_credit_transaction"
    objects: {
      user: Prisma.$userPayload<ExtArgs>
      admin: Prisma.$adminPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      adminId: number | null
      updateBy: string
      updateType: string
      beforeUpdate: number
      afterUpdate: number
      credit: number
      remark: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user_credit_transaction"]>
    composites: {}
  }


  type user_credit_transactionGetPayload<S extends boolean | null | undefined | user_credit_transactionDefaultArgs> = $Result.GetResult<Prisma.$user_credit_transactionPayload, S>

  type user_credit_transactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<user_credit_transactionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: User_credit_transactionCountAggregateInputType | true
    }

  export interface user_credit_transactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['user_credit_transaction'], meta: { name: 'user_credit_transaction' } }
    /**
     * Find zero or one User_credit_transaction that matches the filter.
     * @param {user_credit_transactionFindUniqueArgs} args - Arguments to find a User_credit_transaction
     * @example
     * // Get one User_credit_transaction
     * const user_credit_transaction = await prisma.user_credit_transaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends user_credit_transactionFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, user_credit_transactionFindUniqueArgs<ExtArgs>>
    ): Prisma__user_credit_transactionClient<$Result.GetResult<Prisma.$user_credit_transactionPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one User_credit_transaction that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {user_credit_transactionFindUniqueOrThrowArgs} args - Arguments to find a User_credit_transaction
     * @example
     * // Get one User_credit_transaction
     * const user_credit_transaction = await prisma.user_credit_transaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends user_credit_transactionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, user_credit_transactionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__user_credit_transactionClient<$Result.GetResult<Prisma.$user_credit_transactionPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first User_credit_transaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_credit_transactionFindFirstArgs} args - Arguments to find a User_credit_transaction
     * @example
     * // Get one User_credit_transaction
     * const user_credit_transaction = await prisma.user_credit_transaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends user_credit_transactionFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, user_credit_transactionFindFirstArgs<ExtArgs>>
    ): Prisma__user_credit_transactionClient<$Result.GetResult<Prisma.$user_credit_transactionPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first User_credit_transaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_credit_transactionFindFirstOrThrowArgs} args - Arguments to find a User_credit_transaction
     * @example
     * // Get one User_credit_transaction
     * const user_credit_transaction = await prisma.user_credit_transaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends user_credit_transactionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, user_credit_transactionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__user_credit_transactionClient<$Result.GetResult<Prisma.$user_credit_transactionPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more User_credit_transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_credit_transactionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all User_credit_transactions
     * const user_credit_transactions = await prisma.user_credit_transaction.findMany()
     * 
     * // Get first 10 User_credit_transactions
     * const user_credit_transactions = await prisma.user_credit_transaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const user_credit_transactionWithIdOnly = await prisma.user_credit_transaction.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends user_credit_transactionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, user_credit_transactionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_credit_transactionPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a User_credit_transaction.
     * @param {user_credit_transactionCreateArgs} args - Arguments to create a User_credit_transaction.
     * @example
     * // Create one User_credit_transaction
     * const User_credit_transaction = await prisma.user_credit_transaction.create({
     *   data: {
     *     // ... data to create a User_credit_transaction
     *   }
     * })
     * 
    **/
    create<T extends user_credit_transactionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, user_credit_transactionCreateArgs<ExtArgs>>
    ): Prisma__user_credit_transactionClient<$Result.GetResult<Prisma.$user_credit_transactionPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many User_credit_transactions.
     *     @param {user_credit_transactionCreateManyArgs} args - Arguments to create many User_credit_transactions.
     *     @example
     *     // Create many User_credit_transactions
     *     const user_credit_transaction = await prisma.user_credit_transaction.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends user_credit_transactionCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, user_credit_transactionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User_credit_transaction.
     * @param {user_credit_transactionDeleteArgs} args - Arguments to delete one User_credit_transaction.
     * @example
     * // Delete one User_credit_transaction
     * const User_credit_transaction = await prisma.user_credit_transaction.delete({
     *   where: {
     *     // ... filter to delete one User_credit_transaction
     *   }
     * })
     * 
    **/
    delete<T extends user_credit_transactionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, user_credit_transactionDeleteArgs<ExtArgs>>
    ): Prisma__user_credit_transactionClient<$Result.GetResult<Prisma.$user_credit_transactionPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one User_credit_transaction.
     * @param {user_credit_transactionUpdateArgs} args - Arguments to update one User_credit_transaction.
     * @example
     * // Update one User_credit_transaction
     * const user_credit_transaction = await prisma.user_credit_transaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends user_credit_transactionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, user_credit_transactionUpdateArgs<ExtArgs>>
    ): Prisma__user_credit_transactionClient<$Result.GetResult<Prisma.$user_credit_transactionPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more User_credit_transactions.
     * @param {user_credit_transactionDeleteManyArgs} args - Arguments to filter User_credit_transactions to delete.
     * @example
     * // Delete a few User_credit_transactions
     * const { count } = await prisma.user_credit_transaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends user_credit_transactionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, user_credit_transactionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more User_credit_transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_credit_transactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many User_credit_transactions
     * const user_credit_transaction = await prisma.user_credit_transaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends user_credit_transactionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, user_credit_transactionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User_credit_transaction.
     * @param {user_credit_transactionUpsertArgs} args - Arguments to update or create a User_credit_transaction.
     * @example
     * // Update or create a User_credit_transaction
     * const user_credit_transaction = await prisma.user_credit_transaction.upsert({
     *   create: {
     *     // ... data to create a User_credit_transaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User_credit_transaction we want to update
     *   }
     * })
    **/
    upsert<T extends user_credit_transactionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, user_credit_transactionUpsertArgs<ExtArgs>>
    ): Prisma__user_credit_transactionClient<$Result.GetResult<Prisma.$user_credit_transactionPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of User_credit_transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_credit_transactionCountArgs} args - Arguments to filter User_credit_transactions to count.
     * @example
     * // Count the number of User_credit_transactions
     * const count = await prisma.user_credit_transaction.count({
     *   where: {
     *     // ... the filter for the User_credit_transactions we want to count
     *   }
     * })
    **/
    count<T extends user_credit_transactionCountArgs>(
      args?: Subset<T, user_credit_transactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], User_credit_transactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User_credit_transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_credit_transactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends User_credit_transactionAggregateArgs>(args: Subset<T, User_credit_transactionAggregateArgs>): Prisma.PrismaPromise<GetUser_credit_transactionAggregateType<T>>

    /**
     * Group by User_credit_transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_credit_transactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends user_credit_transactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: user_credit_transactionGroupByArgs['orderBy'] }
        : { orderBy?: user_credit_transactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, user_credit_transactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUser_credit_transactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the user_credit_transaction model
   */
  readonly fields: user_credit_transactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for user_credit_transaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__user_credit_transactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    admin<T extends user_credit_transaction$adminArgs<ExtArgs> = {}>(args?: Subset<T, user_credit_transaction$adminArgs<ExtArgs>>): Prisma__adminClient<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the user_credit_transaction model
   */ 
  interface user_credit_transactionFieldRefs {
    readonly id: FieldRef<"user_credit_transaction", 'Int'>
    readonly userId: FieldRef<"user_credit_transaction", 'Int'>
    readonly adminId: FieldRef<"user_credit_transaction", 'Int'>
    readonly updateBy: FieldRef<"user_credit_transaction", 'String'>
    readonly updateType: FieldRef<"user_credit_transaction", 'String'>
    readonly beforeUpdate: FieldRef<"user_credit_transaction", 'Float'>
    readonly afterUpdate: FieldRef<"user_credit_transaction", 'Float'>
    readonly credit: FieldRef<"user_credit_transaction", 'Float'>
    readonly remark: FieldRef<"user_credit_transaction", 'String'>
    readonly isActive: FieldRef<"user_credit_transaction", 'Boolean'>
    readonly createdAt: FieldRef<"user_credit_transaction", 'DateTime'>
    readonly updatedAt: FieldRef<"user_credit_transaction", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * user_credit_transaction findUnique
   */
  export type user_credit_transactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_credit_transaction
     */
    select?: user_credit_transactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_credit_transactionInclude<ExtArgs> | null
    /**
     * Filter, which user_credit_transaction to fetch.
     */
    where: user_credit_transactionWhereUniqueInput
  }


  /**
   * user_credit_transaction findUniqueOrThrow
   */
  export type user_credit_transactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_credit_transaction
     */
    select?: user_credit_transactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_credit_transactionInclude<ExtArgs> | null
    /**
     * Filter, which user_credit_transaction to fetch.
     */
    where: user_credit_transactionWhereUniqueInput
  }


  /**
   * user_credit_transaction findFirst
   */
  export type user_credit_transactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_credit_transaction
     */
    select?: user_credit_transactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_credit_transactionInclude<ExtArgs> | null
    /**
     * Filter, which user_credit_transaction to fetch.
     */
    where?: user_credit_transactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_credit_transactions to fetch.
     */
    orderBy?: user_credit_transactionOrderByWithRelationInput | user_credit_transactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_credit_transactions.
     */
    cursor?: user_credit_transactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_credit_transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_credit_transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_credit_transactions.
     */
    distinct?: User_credit_transactionScalarFieldEnum | User_credit_transactionScalarFieldEnum[]
  }


  /**
   * user_credit_transaction findFirstOrThrow
   */
  export type user_credit_transactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_credit_transaction
     */
    select?: user_credit_transactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_credit_transactionInclude<ExtArgs> | null
    /**
     * Filter, which user_credit_transaction to fetch.
     */
    where?: user_credit_transactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_credit_transactions to fetch.
     */
    orderBy?: user_credit_transactionOrderByWithRelationInput | user_credit_transactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_credit_transactions.
     */
    cursor?: user_credit_transactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_credit_transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_credit_transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_credit_transactions.
     */
    distinct?: User_credit_transactionScalarFieldEnum | User_credit_transactionScalarFieldEnum[]
  }


  /**
   * user_credit_transaction findMany
   */
  export type user_credit_transactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_credit_transaction
     */
    select?: user_credit_transactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_credit_transactionInclude<ExtArgs> | null
    /**
     * Filter, which user_credit_transactions to fetch.
     */
    where?: user_credit_transactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_credit_transactions to fetch.
     */
    orderBy?: user_credit_transactionOrderByWithRelationInput | user_credit_transactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing user_credit_transactions.
     */
    cursor?: user_credit_transactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_credit_transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_credit_transactions.
     */
    skip?: number
    distinct?: User_credit_transactionScalarFieldEnum | User_credit_transactionScalarFieldEnum[]
  }


  /**
   * user_credit_transaction create
   */
  export type user_credit_transactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_credit_transaction
     */
    select?: user_credit_transactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_credit_transactionInclude<ExtArgs> | null
    /**
     * The data needed to create a user_credit_transaction.
     */
    data: XOR<user_credit_transactionCreateInput, user_credit_transactionUncheckedCreateInput>
  }


  /**
   * user_credit_transaction createMany
   */
  export type user_credit_transactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many user_credit_transactions.
     */
    data: user_credit_transactionCreateManyInput | user_credit_transactionCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * user_credit_transaction update
   */
  export type user_credit_transactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_credit_transaction
     */
    select?: user_credit_transactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_credit_transactionInclude<ExtArgs> | null
    /**
     * The data needed to update a user_credit_transaction.
     */
    data: XOR<user_credit_transactionUpdateInput, user_credit_transactionUncheckedUpdateInput>
    /**
     * Choose, which user_credit_transaction to update.
     */
    where: user_credit_transactionWhereUniqueInput
  }


  /**
   * user_credit_transaction updateMany
   */
  export type user_credit_transactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update user_credit_transactions.
     */
    data: XOR<user_credit_transactionUpdateManyMutationInput, user_credit_transactionUncheckedUpdateManyInput>
    /**
     * Filter which user_credit_transactions to update
     */
    where?: user_credit_transactionWhereInput
  }


  /**
   * user_credit_transaction upsert
   */
  export type user_credit_transactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_credit_transaction
     */
    select?: user_credit_transactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_credit_transactionInclude<ExtArgs> | null
    /**
     * The filter to search for the user_credit_transaction to update in case it exists.
     */
    where: user_credit_transactionWhereUniqueInput
    /**
     * In case the user_credit_transaction found by the `where` argument doesn't exist, create a new user_credit_transaction with this data.
     */
    create: XOR<user_credit_transactionCreateInput, user_credit_transactionUncheckedCreateInput>
    /**
     * In case the user_credit_transaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<user_credit_transactionUpdateInput, user_credit_transactionUncheckedUpdateInput>
  }


  /**
   * user_credit_transaction delete
   */
  export type user_credit_transactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_credit_transaction
     */
    select?: user_credit_transactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_credit_transactionInclude<ExtArgs> | null
    /**
     * Filter which user_credit_transaction to delete.
     */
    where: user_credit_transactionWhereUniqueInput
  }


  /**
   * user_credit_transaction deleteMany
   */
  export type user_credit_transactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_credit_transactions to delete
     */
    where?: user_credit_transactionWhereInput
  }


  /**
   * user_credit_transaction.admin
   */
  export type user_credit_transaction$adminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: adminInclude<ExtArgs> | null
    where?: adminWhereInput
  }


  /**
   * user_credit_transaction without action
   */
  export type user_credit_transactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_credit_transaction
     */
    select?: user_credit_transactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_credit_transactionInclude<ExtArgs> | null
  }



  /**
   * Model user_point_transaction
   */

  export type AggregateUser_point_transaction = {
    _count: User_point_transactionCountAggregateOutputType | null
    _avg: User_point_transactionAvgAggregateOutputType | null
    _sum: User_point_transactionSumAggregateOutputType | null
    _min: User_point_transactionMinAggregateOutputType | null
    _max: User_point_transactionMaxAggregateOutputType | null
  }

  export type User_point_transactionAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    adminId: number | null
    beforeUpdate: number | null
    afterUpdate: number | null
    point: number | null
  }

  export type User_point_transactionSumAggregateOutputType = {
    id: number | null
    userId: number | null
    adminId: number | null
    beforeUpdate: number | null
    afterUpdate: number | null
    point: number | null
  }

  export type User_point_transactionMinAggregateOutputType = {
    id: number | null
    userId: number | null
    adminId: number | null
    updateBy: string | null
    updateType: string | null
    beforeUpdate: number | null
    afterUpdate: number | null
    point: number | null
    remark: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type User_point_transactionMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    adminId: number | null
    updateBy: string | null
    updateType: string | null
    beforeUpdate: number | null
    afterUpdate: number | null
    point: number | null
    remark: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type User_point_transactionCountAggregateOutputType = {
    id: number
    userId: number
    adminId: number
    updateBy: number
    updateType: number
    beforeUpdate: number
    afterUpdate: number
    point: number
    remark: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type User_point_transactionAvgAggregateInputType = {
    id?: true
    userId?: true
    adminId?: true
    beforeUpdate?: true
    afterUpdate?: true
    point?: true
  }

  export type User_point_transactionSumAggregateInputType = {
    id?: true
    userId?: true
    adminId?: true
    beforeUpdate?: true
    afterUpdate?: true
    point?: true
  }

  export type User_point_transactionMinAggregateInputType = {
    id?: true
    userId?: true
    adminId?: true
    updateBy?: true
    updateType?: true
    beforeUpdate?: true
    afterUpdate?: true
    point?: true
    remark?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type User_point_transactionMaxAggregateInputType = {
    id?: true
    userId?: true
    adminId?: true
    updateBy?: true
    updateType?: true
    beforeUpdate?: true
    afterUpdate?: true
    point?: true
    remark?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type User_point_transactionCountAggregateInputType = {
    id?: true
    userId?: true
    adminId?: true
    updateBy?: true
    updateType?: true
    beforeUpdate?: true
    afterUpdate?: true
    point?: true
    remark?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type User_point_transactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_point_transaction to aggregate.
     */
    where?: user_point_transactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_point_transactions to fetch.
     */
    orderBy?: user_point_transactionOrderByWithRelationInput | user_point_transactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: user_point_transactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_point_transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_point_transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned user_point_transactions
    **/
    _count?: true | User_point_transactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: User_point_transactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: User_point_transactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: User_point_transactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: User_point_transactionMaxAggregateInputType
  }

  export type GetUser_point_transactionAggregateType<T extends User_point_transactionAggregateArgs> = {
        [P in keyof T & keyof AggregateUser_point_transaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser_point_transaction[P]>
      : GetScalarType<T[P], AggregateUser_point_transaction[P]>
  }




  export type user_point_transactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: user_point_transactionWhereInput
    orderBy?: user_point_transactionOrderByWithAggregationInput | user_point_transactionOrderByWithAggregationInput[]
    by: User_point_transactionScalarFieldEnum[] | User_point_transactionScalarFieldEnum
    having?: user_point_transactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: User_point_transactionCountAggregateInputType | true
    _avg?: User_point_transactionAvgAggregateInputType
    _sum?: User_point_transactionSumAggregateInputType
    _min?: User_point_transactionMinAggregateInputType
    _max?: User_point_transactionMaxAggregateInputType
  }

  export type User_point_transactionGroupByOutputType = {
    id: number
    userId: number
    adminId: number | null
    updateBy: string
    updateType: string
    beforeUpdate: number
    afterUpdate: number
    point: number
    remark: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: User_point_transactionCountAggregateOutputType | null
    _avg: User_point_transactionAvgAggregateOutputType | null
    _sum: User_point_transactionSumAggregateOutputType | null
    _min: User_point_transactionMinAggregateOutputType | null
    _max: User_point_transactionMaxAggregateOutputType | null
  }

  type GetUser_point_transactionGroupByPayload<T extends user_point_transactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<User_point_transactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof User_point_transactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], User_point_transactionGroupByOutputType[P]>
            : GetScalarType<T[P], User_point_transactionGroupByOutputType[P]>
        }
      >
    >


  export type user_point_transactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    adminId?: boolean
    updateBy?: boolean
    updateType?: boolean
    beforeUpdate?: boolean
    afterUpdate?: boolean
    point?: boolean
    remark?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
    admin?: boolean | user_point_transaction$adminArgs<ExtArgs>
  }, ExtArgs["result"]["user_point_transaction"]>

  export type user_point_transactionSelectScalar = {
    id?: boolean
    userId?: boolean
    adminId?: boolean
    updateBy?: boolean
    updateType?: boolean
    beforeUpdate?: boolean
    afterUpdate?: boolean
    point?: boolean
    remark?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type user_point_transactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
    admin?: boolean | user_point_transaction$adminArgs<ExtArgs>
  }


  export type $user_point_transactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "user_point_transaction"
    objects: {
      user: Prisma.$userPayload<ExtArgs>
      admin: Prisma.$adminPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      adminId: number | null
      updateBy: string
      updateType: string
      beforeUpdate: number
      afterUpdate: number
      point: number
      remark: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user_point_transaction"]>
    composites: {}
  }


  type user_point_transactionGetPayload<S extends boolean | null | undefined | user_point_transactionDefaultArgs> = $Result.GetResult<Prisma.$user_point_transactionPayload, S>

  type user_point_transactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<user_point_transactionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: User_point_transactionCountAggregateInputType | true
    }

  export interface user_point_transactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['user_point_transaction'], meta: { name: 'user_point_transaction' } }
    /**
     * Find zero or one User_point_transaction that matches the filter.
     * @param {user_point_transactionFindUniqueArgs} args - Arguments to find a User_point_transaction
     * @example
     * // Get one User_point_transaction
     * const user_point_transaction = await prisma.user_point_transaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends user_point_transactionFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, user_point_transactionFindUniqueArgs<ExtArgs>>
    ): Prisma__user_point_transactionClient<$Result.GetResult<Prisma.$user_point_transactionPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one User_point_transaction that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {user_point_transactionFindUniqueOrThrowArgs} args - Arguments to find a User_point_transaction
     * @example
     * // Get one User_point_transaction
     * const user_point_transaction = await prisma.user_point_transaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends user_point_transactionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, user_point_transactionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__user_point_transactionClient<$Result.GetResult<Prisma.$user_point_transactionPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first User_point_transaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_point_transactionFindFirstArgs} args - Arguments to find a User_point_transaction
     * @example
     * // Get one User_point_transaction
     * const user_point_transaction = await prisma.user_point_transaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends user_point_transactionFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, user_point_transactionFindFirstArgs<ExtArgs>>
    ): Prisma__user_point_transactionClient<$Result.GetResult<Prisma.$user_point_transactionPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first User_point_transaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_point_transactionFindFirstOrThrowArgs} args - Arguments to find a User_point_transaction
     * @example
     * // Get one User_point_transaction
     * const user_point_transaction = await prisma.user_point_transaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends user_point_transactionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, user_point_transactionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__user_point_transactionClient<$Result.GetResult<Prisma.$user_point_transactionPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more User_point_transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_point_transactionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all User_point_transactions
     * const user_point_transactions = await prisma.user_point_transaction.findMany()
     * 
     * // Get first 10 User_point_transactions
     * const user_point_transactions = await prisma.user_point_transaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const user_point_transactionWithIdOnly = await prisma.user_point_transaction.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends user_point_transactionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, user_point_transactionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_point_transactionPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a User_point_transaction.
     * @param {user_point_transactionCreateArgs} args - Arguments to create a User_point_transaction.
     * @example
     * // Create one User_point_transaction
     * const User_point_transaction = await prisma.user_point_transaction.create({
     *   data: {
     *     // ... data to create a User_point_transaction
     *   }
     * })
     * 
    **/
    create<T extends user_point_transactionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, user_point_transactionCreateArgs<ExtArgs>>
    ): Prisma__user_point_transactionClient<$Result.GetResult<Prisma.$user_point_transactionPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many User_point_transactions.
     *     @param {user_point_transactionCreateManyArgs} args - Arguments to create many User_point_transactions.
     *     @example
     *     // Create many User_point_transactions
     *     const user_point_transaction = await prisma.user_point_transaction.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends user_point_transactionCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, user_point_transactionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User_point_transaction.
     * @param {user_point_transactionDeleteArgs} args - Arguments to delete one User_point_transaction.
     * @example
     * // Delete one User_point_transaction
     * const User_point_transaction = await prisma.user_point_transaction.delete({
     *   where: {
     *     // ... filter to delete one User_point_transaction
     *   }
     * })
     * 
    **/
    delete<T extends user_point_transactionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, user_point_transactionDeleteArgs<ExtArgs>>
    ): Prisma__user_point_transactionClient<$Result.GetResult<Prisma.$user_point_transactionPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one User_point_transaction.
     * @param {user_point_transactionUpdateArgs} args - Arguments to update one User_point_transaction.
     * @example
     * // Update one User_point_transaction
     * const user_point_transaction = await prisma.user_point_transaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends user_point_transactionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, user_point_transactionUpdateArgs<ExtArgs>>
    ): Prisma__user_point_transactionClient<$Result.GetResult<Prisma.$user_point_transactionPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more User_point_transactions.
     * @param {user_point_transactionDeleteManyArgs} args - Arguments to filter User_point_transactions to delete.
     * @example
     * // Delete a few User_point_transactions
     * const { count } = await prisma.user_point_transaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends user_point_transactionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, user_point_transactionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more User_point_transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_point_transactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many User_point_transactions
     * const user_point_transaction = await prisma.user_point_transaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends user_point_transactionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, user_point_transactionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User_point_transaction.
     * @param {user_point_transactionUpsertArgs} args - Arguments to update or create a User_point_transaction.
     * @example
     * // Update or create a User_point_transaction
     * const user_point_transaction = await prisma.user_point_transaction.upsert({
     *   create: {
     *     // ... data to create a User_point_transaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User_point_transaction we want to update
     *   }
     * })
    **/
    upsert<T extends user_point_transactionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, user_point_transactionUpsertArgs<ExtArgs>>
    ): Prisma__user_point_transactionClient<$Result.GetResult<Prisma.$user_point_transactionPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of User_point_transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_point_transactionCountArgs} args - Arguments to filter User_point_transactions to count.
     * @example
     * // Count the number of User_point_transactions
     * const count = await prisma.user_point_transaction.count({
     *   where: {
     *     // ... the filter for the User_point_transactions we want to count
     *   }
     * })
    **/
    count<T extends user_point_transactionCountArgs>(
      args?: Subset<T, user_point_transactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], User_point_transactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User_point_transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_point_transactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends User_point_transactionAggregateArgs>(args: Subset<T, User_point_transactionAggregateArgs>): Prisma.PrismaPromise<GetUser_point_transactionAggregateType<T>>

    /**
     * Group by User_point_transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_point_transactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends user_point_transactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: user_point_transactionGroupByArgs['orderBy'] }
        : { orderBy?: user_point_transactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, user_point_transactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUser_point_transactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the user_point_transaction model
   */
  readonly fields: user_point_transactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for user_point_transaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__user_point_transactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    admin<T extends user_point_transaction$adminArgs<ExtArgs> = {}>(args?: Subset<T, user_point_transaction$adminArgs<ExtArgs>>): Prisma__adminClient<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the user_point_transaction model
   */ 
  interface user_point_transactionFieldRefs {
    readonly id: FieldRef<"user_point_transaction", 'Int'>
    readonly userId: FieldRef<"user_point_transaction", 'Int'>
    readonly adminId: FieldRef<"user_point_transaction", 'Int'>
    readonly updateBy: FieldRef<"user_point_transaction", 'String'>
    readonly updateType: FieldRef<"user_point_transaction", 'String'>
    readonly beforeUpdate: FieldRef<"user_point_transaction", 'Float'>
    readonly afterUpdate: FieldRef<"user_point_transaction", 'Float'>
    readonly point: FieldRef<"user_point_transaction", 'Float'>
    readonly remark: FieldRef<"user_point_transaction", 'String'>
    readonly isActive: FieldRef<"user_point_transaction", 'Boolean'>
    readonly createdAt: FieldRef<"user_point_transaction", 'DateTime'>
    readonly updatedAt: FieldRef<"user_point_transaction", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * user_point_transaction findUnique
   */
  export type user_point_transactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_point_transaction
     */
    select?: user_point_transactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_point_transactionInclude<ExtArgs> | null
    /**
     * Filter, which user_point_transaction to fetch.
     */
    where: user_point_transactionWhereUniqueInput
  }


  /**
   * user_point_transaction findUniqueOrThrow
   */
  export type user_point_transactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_point_transaction
     */
    select?: user_point_transactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_point_transactionInclude<ExtArgs> | null
    /**
     * Filter, which user_point_transaction to fetch.
     */
    where: user_point_transactionWhereUniqueInput
  }


  /**
   * user_point_transaction findFirst
   */
  export type user_point_transactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_point_transaction
     */
    select?: user_point_transactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_point_transactionInclude<ExtArgs> | null
    /**
     * Filter, which user_point_transaction to fetch.
     */
    where?: user_point_transactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_point_transactions to fetch.
     */
    orderBy?: user_point_transactionOrderByWithRelationInput | user_point_transactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_point_transactions.
     */
    cursor?: user_point_transactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_point_transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_point_transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_point_transactions.
     */
    distinct?: User_point_transactionScalarFieldEnum | User_point_transactionScalarFieldEnum[]
  }


  /**
   * user_point_transaction findFirstOrThrow
   */
  export type user_point_transactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_point_transaction
     */
    select?: user_point_transactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_point_transactionInclude<ExtArgs> | null
    /**
     * Filter, which user_point_transaction to fetch.
     */
    where?: user_point_transactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_point_transactions to fetch.
     */
    orderBy?: user_point_transactionOrderByWithRelationInput | user_point_transactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_point_transactions.
     */
    cursor?: user_point_transactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_point_transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_point_transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_point_transactions.
     */
    distinct?: User_point_transactionScalarFieldEnum | User_point_transactionScalarFieldEnum[]
  }


  /**
   * user_point_transaction findMany
   */
  export type user_point_transactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_point_transaction
     */
    select?: user_point_transactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_point_transactionInclude<ExtArgs> | null
    /**
     * Filter, which user_point_transactions to fetch.
     */
    where?: user_point_transactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_point_transactions to fetch.
     */
    orderBy?: user_point_transactionOrderByWithRelationInput | user_point_transactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing user_point_transactions.
     */
    cursor?: user_point_transactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_point_transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_point_transactions.
     */
    skip?: number
    distinct?: User_point_transactionScalarFieldEnum | User_point_transactionScalarFieldEnum[]
  }


  /**
   * user_point_transaction create
   */
  export type user_point_transactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_point_transaction
     */
    select?: user_point_transactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_point_transactionInclude<ExtArgs> | null
    /**
     * The data needed to create a user_point_transaction.
     */
    data: XOR<user_point_transactionCreateInput, user_point_transactionUncheckedCreateInput>
  }


  /**
   * user_point_transaction createMany
   */
  export type user_point_transactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many user_point_transactions.
     */
    data: user_point_transactionCreateManyInput | user_point_transactionCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * user_point_transaction update
   */
  export type user_point_transactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_point_transaction
     */
    select?: user_point_transactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_point_transactionInclude<ExtArgs> | null
    /**
     * The data needed to update a user_point_transaction.
     */
    data: XOR<user_point_transactionUpdateInput, user_point_transactionUncheckedUpdateInput>
    /**
     * Choose, which user_point_transaction to update.
     */
    where: user_point_transactionWhereUniqueInput
  }


  /**
   * user_point_transaction updateMany
   */
  export type user_point_transactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update user_point_transactions.
     */
    data: XOR<user_point_transactionUpdateManyMutationInput, user_point_transactionUncheckedUpdateManyInput>
    /**
     * Filter which user_point_transactions to update
     */
    where?: user_point_transactionWhereInput
  }


  /**
   * user_point_transaction upsert
   */
  export type user_point_transactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_point_transaction
     */
    select?: user_point_transactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_point_transactionInclude<ExtArgs> | null
    /**
     * The filter to search for the user_point_transaction to update in case it exists.
     */
    where: user_point_transactionWhereUniqueInput
    /**
     * In case the user_point_transaction found by the `where` argument doesn't exist, create a new user_point_transaction with this data.
     */
    create: XOR<user_point_transactionCreateInput, user_point_transactionUncheckedCreateInput>
    /**
     * In case the user_point_transaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<user_point_transactionUpdateInput, user_point_transactionUncheckedUpdateInput>
  }


  /**
   * user_point_transaction delete
   */
  export type user_point_transactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_point_transaction
     */
    select?: user_point_transactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_point_transactionInclude<ExtArgs> | null
    /**
     * Filter which user_point_transaction to delete.
     */
    where: user_point_transactionWhereUniqueInput
  }


  /**
   * user_point_transaction deleteMany
   */
  export type user_point_transactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_point_transactions to delete
     */
    where?: user_point_transactionWhereInput
  }


  /**
   * user_point_transaction.admin
   */
  export type user_point_transaction$adminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: adminInclude<ExtArgs> | null
    where?: adminWhereInput
  }


  /**
   * user_point_transaction without action
   */
  export type user_point_transactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_point_transaction
     */
    select?: user_point_transactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_point_transactionInclude<ExtArgs> | null
  }



  /**
   * Model payment_transaction
   */

  export type AggregatePayment_transaction = {
    _count: Payment_transactionCountAggregateOutputType | null
    _avg: Payment_transactionAvgAggregateOutputType | null
    _sum: Payment_transactionSumAggregateOutputType | null
    _min: Payment_transactionMinAggregateOutputType | null
    _max: Payment_transactionMaxAggregateOutputType | null
  }

  export type Payment_transactionAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    price: number | null
  }

  export type Payment_transactionSumAggregateOutputType = {
    id: number | null
    userId: number | null
    price: number | null
  }

  export type Payment_transactionMinAggregateOutputType = {
    id: number | null
    userId: number | null
    price: number | null
    refCode: string | null
    status: string | null
    base64: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Payment_transactionMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    price: number | null
    refCode: string | null
    status: string | null
    base64: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Payment_transactionCountAggregateOutputType = {
    id: number
    userId: number
    price: number
    refCode: number
    status: number
    base64: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Payment_transactionAvgAggregateInputType = {
    id?: true
    userId?: true
    price?: true
  }

  export type Payment_transactionSumAggregateInputType = {
    id?: true
    userId?: true
    price?: true
  }

  export type Payment_transactionMinAggregateInputType = {
    id?: true
    userId?: true
    price?: true
    refCode?: true
    status?: true
    base64?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Payment_transactionMaxAggregateInputType = {
    id?: true
    userId?: true
    price?: true
    refCode?: true
    status?: true
    base64?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Payment_transactionCountAggregateInputType = {
    id?: true
    userId?: true
    price?: true
    refCode?: true
    status?: true
    base64?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Payment_transactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which payment_transaction to aggregate.
     */
    where?: payment_transactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payment_transactions to fetch.
     */
    orderBy?: payment_transactionOrderByWithRelationInput | payment_transactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: payment_transactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payment_transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payment_transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned payment_transactions
    **/
    _count?: true | Payment_transactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Payment_transactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Payment_transactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Payment_transactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Payment_transactionMaxAggregateInputType
  }

  export type GetPayment_transactionAggregateType<T extends Payment_transactionAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment_transaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment_transaction[P]>
      : GetScalarType<T[P], AggregatePayment_transaction[P]>
  }




  export type payment_transactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: payment_transactionWhereInput
    orderBy?: payment_transactionOrderByWithAggregationInput | payment_transactionOrderByWithAggregationInput[]
    by: Payment_transactionScalarFieldEnum[] | Payment_transactionScalarFieldEnum
    having?: payment_transactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Payment_transactionCountAggregateInputType | true
    _avg?: Payment_transactionAvgAggregateInputType
    _sum?: Payment_transactionSumAggregateInputType
    _min?: Payment_transactionMinAggregateInputType
    _max?: Payment_transactionMaxAggregateInputType
  }

  export type Payment_transactionGroupByOutputType = {
    id: number
    userId: number
    price: number
    refCode: string
    status: string
    base64: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: Payment_transactionCountAggregateOutputType | null
    _avg: Payment_transactionAvgAggregateOutputType | null
    _sum: Payment_transactionSumAggregateOutputType | null
    _min: Payment_transactionMinAggregateOutputType | null
    _max: Payment_transactionMaxAggregateOutputType | null
  }

  type GetPayment_transactionGroupByPayload<T extends payment_transactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Payment_transactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Payment_transactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Payment_transactionGroupByOutputType[P]>
            : GetScalarType<T[P], Payment_transactionGroupByOutputType[P]>
        }
      >
    >


  export type payment_transactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    price?: boolean
    refCode?: boolean
    status?: boolean
    base64?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment_transaction"]>

  export type payment_transactionSelectScalar = {
    id?: boolean
    userId?: boolean
    price?: boolean
    refCode?: boolean
    status?: boolean
    base64?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type payment_transactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
  }


  export type $payment_transactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "payment_transaction"
    objects: {
      user: Prisma.$userPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      price: number
      refCode: string
      status: string
      base64: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["payment_transaction"]>
    composites: {}
  }


  type payment_transactionGetPayload<S extends boolean | null | undefined | payment_transactionDefaultArgs> = $Result.GetResult<Prisma.$payment_transactionPayload, S>

  type payment_transactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<payment_transactionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Payment_transactionCountAggregateInputType | true
    }

  export interface payment_transactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['payment_transaction'], meta: { name: 'payment_transaction' } }
    /**
     * Find zero or one Payment_transaction that matches the filter.
     * @param {payment_transactionFindUniqueArgs} args - Arguments to find a Payment_transaction
     * @example
     * // Get one Payment_transaction
     * const payment_transaction = await prisma.payment_transaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends payment_transactionFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, payment_transactionFindUniqueArgs<ExtArgs>>
    ): Prisma__payment_transactionClient<$Result.GetResult<Prisma.$payment_transactionPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Payment_transaction that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {payment_transactionFindUniqueOrThrowArgs} args - Arguments to find a Payment_transaction
     * @example
     * // Get one Payment_transaction
     * const payment_transaction = await prisma.payment_transaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends payment_transactionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, payment_transactionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__payment_transactionClient<$Result.GetResult<Prisma.$payment_transactionPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Payment_transaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_transactionFindFirstArgs} args - Arguments to find a Payment_transaction
     * @example
     * // Get one Payment_transaction
     * const payment_transaction = await prisma.payment_transaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends payment_transactionFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, payment_transactionFindFirstArgs<ExtArgs>>
    ): Prisma__payment_transactionClient<$Result.GetResult<Prisma.$payment_transactionPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Payment_transaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_transactionFindFirstOrThrowArgs} args - Arguments to find a Payment_transaction
     * @example
     * // Get one Payment_transaction
     * const payment_transaction = await prisma.payment_transaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends payment_transactionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, payment_transactionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__payment_transactionClient<$Result.GetResult<Prisma.$payment_transactionPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Payment_transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_transactionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payment_transactions
     * const payment_transactions = await prisma.payment_transaction.findMany()
     * 
     * // Get first 10 Payment_transactions
     * const payment_transactions = await prisma.payment_transaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const payment_transactionWithIdOnly = await prisma.payment_transaction.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends payment_transactionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, payment_transactionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$payment_transactionPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Payment_transaction.
     * @param {payment_transactionCreateArgs} args - Arguments to create a Payment_transaction.
     * @example
     * // Create one Payment_transaction
     * const Payment_transaction = await prisma.payment_transaction.create({
     *   data: {
     *     // ... data to create a Payment_transaction
     *   }
     * })
     * 
    **/
    create<T extends payment_transactionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, payment_transactionCreateArgs<ExtArgs>>
    ): Prisma__payment_transactionClient<$Result.GetResult<Prisma.$payment_transactionPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Payment_transactions.
     *     @param {payment_transactionCreateManyArgs} args - Arguments to create many Payment_transactions.
     *     @example
     *     // Create many Payment_transactions
     *     const payment_transaction = await prisma.payment_transaction.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends payment_transactionCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, payment_transactionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Payment_transaction.
     * @param {payment_transactionDeleteArgs} args - Arguments to delete one Payment_transaction.
     * @example
     * // Delete one Payment_transaction
     * const Payment_transaction = await prisma.payment_transaction.delete({
     *   where: {
     *     // ... filter to delete one Payment_transaction
     *   }
     * })
     * 
    **/
    delete<T extends payment_transactionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, payment_transactionDeleteArgs<ExtArgs>>
    ): Prisma__payment_transactionClient<$Result.GetResult<Prisma.$payment_transactionPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Payment_transaction.
     * @param {payment_transactionUpdateArgs} args - Arguments to update one Payment_transaction.
     * @example
     * // Update one Payment_transaction
     * const payment_transaction = await prisma.payment_transaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends payment_transactionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, payment_transactionUpdateArgs<ExtArgs>>
    ): Prisma__payment_transactionClient<$Result.GetResult<Prisma.$payment_transactionPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Payment_transactions.
     * @param {payment_transactionDeleteManyArgs} args - Arguments to filter Payment_transactions to delete.
     * @example
     * // Delete a few Payment_transactions
     * const { count } = await prisma.payment_transaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends payment_transactionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, payment_transactionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payment_transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_transactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payment_transactions
     * const payment_transaction = await prisma.payment_transaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends payment_transactionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, payment_transactionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Payment_transaction.
     * @param {payment_transactionUpsertArgs} args - Arguments to update or create a Payment_transaction.
     * @example
     * // Update or create a Payment_transaction
     * const payment_transaction = await prisma.payment_transaction.upsert({
     *   create: {
     *     // ... data to create a Payment_transaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment_transaction we want to update
     *   }
     * })
    **/
    upsert<T extends payment_transactionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, payment_transactionUpsertArgs<ExtArgs>>
    ): Prisma__payment_transactionClient<$Result.GetResult<Prisma.$payment_transactionPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Payment_transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_transactionCountArgs} args - Arguments to filter Payment_transactions to count.
     * @example
     * // Count the number of Payment_transactions
     * const count = await prisma.payment_transaction.count({
     *   where: {
     *     // ... the filter for the Payment_transactions we want to count
     *   }
     * })
    **/
    count<T extends payment_transactionCountArgs>(
      args?: Subset<T, payment_transactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Payment_transactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment_transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Payment_transactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Payment_transactionAggregateArgs>(args: Subset<T, Payment_transactionAggregateArgs>): Prisma.PrismaPromise<GetPayment_transactionAggregateType<T>>

    /**
     * Group by Payment_transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_transactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends payment_transactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: payment_transactionGroupByArgs['orderBy'] }
        : { orderBy?: payment_transactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, payment_transactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPayment_transactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the payment_transaction model
   */
  readonly fields: payment_transactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for payment_transaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__payment_transactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the payment_transaction model
   */ 
  interface payment_transactionFieldRefs {
    readonly id: FieldRef<"payment_transaction", 'Int'>
    readonly userId: FieldRef<"payment_transaction", 'Int'>
    readonly price: FieldRef<"payment_transaction", 'Float'>
    readonly refCode: FieldRef<"payment_transaction", 'String'>
    readonly status: FieldRef<"payment_transaction", 'String'>
    readonly base64: FieldRef<"payment_transaction", 'String'>
    readonly isActive: FieldRef<"payment_transaction", 'Boolean'>
    readonly createdAt: FieldRef<"payment_transaction", 'DateTime'>
    readonly updatedAt: FieldRef<"payment_transaction", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * payment_transaction findUnique
   */
  export type payment_transactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_transaction
     */
    select?: payment_transactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: payment_transactionInclude<ExtArgs> | null
    /**
     * Filter, which payment_transaction to fetch.
     */
    where: payment_transactionWhereUniqueInput
  }


  /**
   * payment_transaction findUniqueOrThrow
   */
  export type payment_transactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_transaction
     */
    select?: payment_transactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: payment_transactionInclude<ExtArgs> | null
    /**
     * Filter, which payment_transaction to fetch.
     */
    where: payment_transactionWhereUniqueInput
  }


  /**
   * payment_transaction findFirst
   */
  export type payment_transactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_transaction
     */
    select?: payment_transactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: payment_transactionInclude<ExtArgs> | null
    /**
     * Filter, which payment_transaction to fetch.
     */
    where?: payment_transactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payment_transactions to fetch.
     */
    orderBy?: payment_transactionOrderByWithRelationInput | payment_transactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for payment_transactions.
     */
    cursor?: payment_transactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payment_transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payment_transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of payment_transactions.
     */
    distinct?: Payment_transactionScalarFieldEnum | Payment_transactionScalarFieldEnum[]
  }


  /**
   * payment_transaction findFirstOrThrow
   */
  export type payment_transactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_transaction
     */
    select?: payment_transactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: payment_transactionInclude<ExtArgs> | null
    /**
     * Filter, which payment_transaction to fetch.
     */
    where?: payment_transactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payment_transactions to fetch.
     */
    orderBy?: payment_transactionOrderByWithRelationInput | payment_transactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for payment_transactions.
     */
    cursor?: payment_transactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payment_transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payment_transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of payment_transactions.
     */
    distinct?: Payment_transactionScalarFieldEnum | Payment_transactionScalarFieldEnum[]
  }


  /**
   * payment_transaction findMany
   */
  export type payment_transactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_transaction
     */
    select?: payment_transactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: payment_transactionInclude<ExtArgs> | null
    /**
     * Filter, which payment_transactions to fetch.
     */
    where?: payment_transactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payment_transactions to fetch.
     */
    orderBy?: payment_transactionOrderByWithRelationInput | payment_transactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing payment_transactions.
     */
    cursor?: payment_transactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payment_transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payment_transactions.
     */
    skip?: number
    distinct?: Payment_transactionScalarFieldEnum | Payment_transactionScalarFieldEnum[]
  }


  /**
   * payment_transaction create
   */
  export type payment_transactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_transaction
     */
    select?: payment_transactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: payment_transactionInclude<ExtArgs> | null
    /**
     * The data needed to create a payment_transaction.
     */
    data: XOR<payment_transactionCreateInput, payment_transactionUncheckedCreateInput>
  }


  /**
   * payment_transaction createMany
   */
  export type payment_transactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many payment_transactions.
     */
    data: payment_transactionCreateManyInput | payment_transactionCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * payment_transaction update
   */
  export type payment_transactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_transaction
     */
    select?: payment_transactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: payment_transactionInclude<ExtArgs> | null
    /**
     * The data needed to update a payment_transaction.
     */
    data: XOR<payment_transactionUpdateInput, payment_transactionUncheckedUpdateInput>
    /**
     * Choose, which payment_transaction to update.
     */
    where: payment_transactionWhereUniqueInput
  }


  /**
   * payment_transaction updateMany
   */
  export type payment_transactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update payment_transactions.
     */
    data: XOR<payment_transactionUpdateManyMutationInput, payment_transactionUncheckedUpdateManyInput>
    /**
     * Filter which payment_transactions to update
     */
    where?: payment_transactionWhereInput
  }


  /**
   * payment_transaction upsert
   */
  export type payment_transactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_transaction
     */
    select?: payment_transactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: payment_transactionInclude<ExtArgs> | null
    /**
     * The filter to search for the payment_transaction to update in case it exists.
     */
    where: payment_transactionWhereUniqueInput
    /**
     * In case the payment_transaction found by the `where` argument doesn't exist, create a new payment_transaction with this data.
     */
    create: XOR<payment_transactionCreateInput, payment_transactionUncheckedCreateInput>
    /**
     * In case the payment_transaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<payment_transactionUpdateInput, payment_transactionUncheckedUpdateInput>
  }


  /**
   * payment_transaction delete
   */
  export type payment_transactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_transaction
     */
    select?: payment_transactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: payment_transactionInclude<ExtArgs> | null
    /**
     * Filter which payment_transaction to delete.
     */
    where: payment_transactionWhereUniqueInput
  }


  /**
   * payment_transaction deleteMany
   */
  export type payment_transactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which payment_transactions to delete
     */
    where?: payment_transactionWhereInput
  }


  /**
   * payment_transaction without action
   */
  export type payment_transactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_transaction
     */
    select?: payment_transactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: payment_transactionInclude<ExtArgs> | null
  }



  /**
   * Model address
   */

  export type AggregateAddress = {
    _count: AddressCountAggregateOutputType | null
    _avg: AddressAvgAggregateOutputType | null
    _sum: AddressSumAggregateOutputType | null
    _min: AddressMinAggregateOutputType | null
    _max: AddressMaxAggregateOutputType | null
  }

  export type AddressAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type AddressSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type AddressMinAggregateOutputType = {
    id: number | null
    userId: number | null
    default: boolean | null
    addressName: string | null
    details: string | null
    remarks: string | null
    receiverFname: string | null
    receiverLname: string | null
    receiverFullname: string | null
    receiverPhone: string | null
    houseNo: string | null
    villageNo: string | null
    road: string | null
    province: string | null
    district: string | null
    subDistrict: string | null
    postCode: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AddressMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    default: boolean | null
    addressName: string | null
    details: string | null
    remarks: string | null
    receiverFname: string | null
    receiverLname: string | null
    receiverFullname: string | null
    receiverPhone: string | null
    houseNo: string | null
    villageNo: string | null
    road: string | null
    province: string | null
    district: string | null
    subDistrict: string | null
    postCode: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AddressCountAggregateOutputType = {
    id: number
    userId: number
    default: number
    addressName: number
    details: number
    remarks: number
    receiverFname: number
    receiverLname: number
    receiverFullname: number
    receiverPhone: number
    houseNo: number
    villageNo: number
    road: number
    province: number
    district: number
    subDistrict: number
    postCode: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AddressAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type AddressSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type AddressMinAggregateInputType = {
    id?: true
    userId?: true
    default?: true
    addressName?: true
    details?: true
    remarks?: true
    receiverFname?: true
    receiverLname?: true
    receiverFullname?: true
    receiverPhone?: true
    houseNo?: true
    villageNo?: true
    road?: true
    province?: true
    district?: true
    subDistrict?: true
    postCode?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AddressMaxAggregateInputType = {
    id?: true
    userId?: true
    default?: true
    addressName?: true
    details?: true
    remarks?: true
    receiverFname?: true
    receiverLname?: true
    receiverFullname?: true
    receiverPhone?: true
    houseNo?: true
    villageNo?: true
    road?: true
    province?: true
    district?: true
    subDistrict?: true
    postCode?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AddressCountAggregateInputType = {
    id?: true
    userId?: true
    default?: true
    addressName?: true
    details?: true
    remarks?: true
    receiverFname?: true
    receiverLname?: true
    receiverFullname?: true
    receiverPhone?: true
    houseNo?: true
    villageNo?: true
    road?: true
    province?: true
    district?: true
    subDistrict?: true
    postCode?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AddressAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which address to aggregate.
     */
    where?: addressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of addresses to fetch.
     */
    orderBy?: addressOrderByWithRelationInput | addressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: addressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned addresses
    **/
    _count?: true | AddressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AddressAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AddressSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AddressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AddressMaxAggregateInputType
  }

  export type GetAddressAggregateType<T extends AddressAggregateArgs> = {
        [P in keyof T & keyof AggregateAddress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAddress[P]>
      : GetScalarType<T[P], AggregateAddress[P]>
  }




  export type addressGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: addressWhereInput
    orderBy?: addressOrderByWithAggregationInput | addressOrderByWithAggregationInput[]
    by: AddressScalarFieldEnum[] | AddressScalarFieldEnum
    having?: addressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AddressCountAggregateInputType | true
    _avg?: AddressAvgAggregateInputType
    _sum?: AddressSumAggregateInputType
    _min?: AddressMinAggregateInputType
    _max?: AddressMaxAggregateInputType
  }

  export type AddressGroupByOutputType = {
    id: number
    userId: number
    default: boolean
    addressName: string
    details: string | null
    remarks: string | null
    receiverFname: string
    receiverLname: string
    receiverFullname: string
    receiverPhone: string
    houseNo: string
    villageNo: string | null
    road: string | null
    province: string
    district: string
    subDistrict: string
    postCode: string
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: AddressCountAggregateOutputType | null
    _avg: AddressAvgAggregateOutputType | null
    _sum: AddressSumAggregateOutputType | null
    _min: AddressMinAggregateOutputType | null
    _max: AddressMaxAggregateOutputType | null
  }

  type GetAddressGroupByPayload<T extends addressGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AddressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AddressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AddressGroupByOutputType[P]>
            : GetScalarType<T[P], AddressGroupByOutputType[P]>
        }
      >
    >


  export type addressSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    default?: boolean
    addressName?: boolean
    details?: boolean
    remarks?: boolean
    receiverFname?: boolean
    receiverLname?: boolean
    receiverFullname?: boolean
    receiverPhone?: boolean
    houseNo?: boolean
    villageNo?: boolean
    road?: boolean
    province?: boolean
    district?: boolean
    subDistrict?: boolean
    postCode?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
    order?: boolean | address$orderArgs<ExtArgs>
    _count?: boolean | AddressCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["address"]>

  export type addressSelectScalar = {
    id?: boolean
    userId?: boolean
    default?: boolean
    addressName?: boolean
    details?: boolean
    remarks?: boolean
    receiverFname?: boolean
    receiverLname?: boolean
    receiverFullname?: boolean
    receiverPhone?: boolean
    houseNo?: boolean
    villageNo?: boolean
    road?: boolean
    province?: boolean
    district?: boolean
    subDistrict?: boolean
    postCode?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type addressInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
    order?: boolean | address$orderArgs<ExtArgs>
    _count?: boolean | AddressCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $addressPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "address"
    objects: {
      user: Prisma.$userPayload<ExtArgs>
      order: Prisma.$orderPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      default: boolean
      addressName: string
      details: string | null
      remarks: string | null
      receiverFname: string
      receiverLname: string
      receiverFullname: string
      receiverPhone: string
      houseNo: string
      villageNo: string | null
      road: string | null
      province: string
      district: string
      subDistrict: string
      postCode: string
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["address"]>
    composites: {}
  }


  type addressGetPayload<S extends boolean | null | undefined | addressDefaultArgs> = $Result.GetResult<Prisma.$addressPayload, S>

  type addressCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<addressFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AddressCountAggregateInputType | true
    }

  export interface addressDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['address'], meta: { name: 'address' } }
    /**
     * Find zero or one Address that matches the filter.
     * @param {addressFindUniqueArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends addressFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, addressFindUniqueArgs<ExtArgs>>
    ): Prisma__addressClient<$Result.GetResult<Prisma.$addressPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Address that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {addressFindUniqueOrThrowArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends addressFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, addressFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__addressClient<$Result.GetResult<Prisma.$addressPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Address that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {addressFindFirstArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends addressFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, addressFindFirstArgs<ExtArgs>>
    ): Prisma__addressClient<$Result.GetResult<Prisma.$addressPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Address that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {addressFindFirstOrThrowArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends addressFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, addressFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__addressClient<$Result.GetResult<Prisma.$addressPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Addresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {addressFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Addresses
     * const addresses = await prisma.address.findMany()
     * 
     * // Get first 10 Addresses
     * const addresses = await prisma.address.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const addressWithIdOnly = await prisma.address.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends addressFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, addressFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$addressPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Address.
     * @param {addressCreateArgs} args - Arguments to create a Address.
     * @example
     * // Create one Address
     * const Address = await prisma.address.create({
     *   data: {
     *     // ... data to create a Address
     *   }
     * })
     * 
    **/
    create<T extends addressCreateArgs<ExtArgs>>(
      args: SelectSubset<T, addressCreateArgs<ExtArgs>>
    ): Prisma__addressClient<$Result.GetResult<Prisma.$addressPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Addresses.
     *     @param {addressCreateManyArgs} args - Arguments to create many Addresses.
     *     @example
     *     // Create many Addresses
     *     const address = await prisma.address.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends addressCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, addressCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Address.
     * @param {addressDeleteArgs} args - Arguments to delete one Address.
     * @example
     * // Delete one Address
     * const Address = await prisma.address.delete({
     *   where: {
     *     // ... filter to delete one Address
     *   }
     * })
     * 
    **/
    delete<T extends addressDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, addressDeleteArgs<ExtArgs>>
    ): Prisma__addressClient<$Result.GetResult<Prisma.$addressPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Address.
     * @param {addressUpdateArgs} args - Arguments to update one Address.
     * @example
     * // Update one Address
     * const address = await prisma.address.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends addressUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, addressUpdateArgs<ExtArgs>>
    ): Prisma__addressClient<$Result.GetResult<Prisma.$addressPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Addresses.
     * @param {addressDeleteManyArgs} args - Arguments to filter Addresses to delete.
     * @example
     * // Delete a few Addresses
     * const { count } = await prisma.address.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends addressDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, addressDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {addressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Addresses
     * const address = await prisma.address.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends addressUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, addressUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Address.
     * @param {addressUpsertArgs} args - Arguments to update or create a Address.
     * @example
     * // Update or create a Address
     * const address = await prisma.address.upsert({
     *   create: {
     *     // ... data to create a Address
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Address we want to update
     *   }
     * })
    **/
    upsert<T extends addressUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, addressUpsertArgs<ExtArgs>>
    ): Prisma__addressClient<$Result.GetResult<Prisma.$addressPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {addressCountArgs} args - Arguments to filter Addresses to count.
     * @example
     * // Count the number of Addresses
     * const count = await prisma.address.count({
     *   where: {
     *     // ... the filter for the Addresses we want to count
     *   }
     * })
    **/
    count<T extends addressCountArgs>(
      args?: Subset<T, addressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AddressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Address.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AddressAggregateArgs>(args: Subset<T, AddressAggregateArgs>): Prisma.PrismaPromise<GetAddressAggregateType<T>>

    /**
     * Group by Address.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {addressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends addressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: addressGroupByArgs['orderBy'] }
        : { orderBy?: addressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, addressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAddressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the address model
   */
  readonly fields: addressFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for address.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__addressClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    order<T extends address$orderArgs<ExtArgs> = {}>(args?: Subset<T, address$orderArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$orderPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the address model
   */ 
  interface addressFieldRefs {
    readonly id: FieldRef<"address", 'Int'>
    readonly userId: FieldRef<"address", 'Int'>
    readonly default: FieldRef<"address", 'Boolean'>
    readonly addressName: FieldRef<"address", 'String'>
    readonly details: FieldRef<"address", 'String'>
    readonly remarks: FieldRef<"address", 'String'>
    readonly receiverFname: FieldRef<"address", 'String'>
    readonly receiverLname: FieldRef<"address", 'String'>
    readonly receiverFullname: FieldRef<"address", 'String'>
    readonly receiverPhone: FieldRef<"address", 'String'>
    readonly houseNo: FieldRef<"address", 'String'>
    readonly villageNo: FieldRef<"address", 'String'>
    readonly road: FieldRef<"address", 'String'>
    readonly province: FieldRef<"address", 'String'>
    readonly district: FieldRef<"address", 'String'>
    readonly subDistrict: FieldRef<"address", 'String'>
    readonly postCode: FieldRef<"address", 'String'>
    readonly isActive: FieldRef<"address", 'Boolean'>
    readonly createdAt: FieldRef<"address", 'DateTime'>
    readonly updatedAt: FieldRef<"address", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * address findUnique
   */
  export type addressFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the address
     */
    select?: addressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: addressInclude<ExtArgs> | null
    /**
     * Filter, which address to fetch.
     */
    where: addressWhereUniqueInput
  }


  /**
   * address findUniqueOrThrow
   */
  export type addressFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the address
     */
    select?: addressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: addressInclude<ExtArgs> | null
    /**
     * Filter, which address to fetch.
     */
    where: addressWhereUniqueInput
  }


  /**
   * address findFirst
   */
  export type addressFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the address
     */
    select?: addressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: addressInclude<ExtArgs> | null
    /**
     * Filter, which address to fetch.
     */
    where?: addressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of addresses to fetch.
     */
    orderBy?: addressOrderByWithRelationInput | addressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for addresses.
     */
    cursor?: addressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of addresses.
     */
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[]
  }


  /**
   * address findFirstOrThrow
   */
  export type addressFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the address
     */
    select?: addressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: addressInclude<ExtArgs> | null
    /**
     * Filter, which address to fetch.
     */
    where?: addressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of addresses to fetch.
     */
    orderBy?: addressOrderByWithRelationInput | addressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for addresses.
     */
    cursor?: addressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of addresses.
     */
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[]
  }


  /**
   * address findMany
   */
  export type addressFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the address
     */
    select?: addressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: addressInclude<ExtArgs> | null
    /**
     * Filter, which addresses to fetch.
     */
    where?: addressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of addresses to fetch.
     */
    orderBy?: addressOrderByWithRelationInput | addressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing addresses.
     */
    cursor?: addressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` addresses.
     */
    skip?: number
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[]
  }


  /**
   * address create
   */
  export type addressCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the address
     */
    select?: addressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: addressInclude<ExtArgs> | null
    /**
     * The data needed to create a address.
     */
    data: XOR<addressCreateInput, addressUncheckedCreateInput>
  }


  /**
   * address createMany
   */
  export type addressCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many addresses.
     */
    data: addressCreateManyInput | addressCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * address update
   */
  export type addressUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the address
     */
    select?: addressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: addressInclude<ExtArgs> | null
    /**
     * The data needed to update a address.
     */
    data: XOR<addressUpdateInput, addressUncheckedUpdateInput>
    /**
     * Choose, which address to update.
     */
    where: addressWhereUniqueInput
  }


  /**
   * address updateMany
   */
  export type addressUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update addresses.
     */
    data: XOR<addressUpdateManyMutationInput, addressUncheckedUpdateManyInput>
    /**
     * Filter which addresses to update
     */
    where?: addressWhereInput
  }


  /**
   * address upsert
   */
  export type addressUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the address
     */
    select?: addressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: addressInclude<ExtArgs> | null
    /**
     * The filter to search for the address to update in case it exists.
     */
    where: addressWhereUniqueInput
    /**
     * In case the address found by the `where` argument doesn't exist, create a new address with this data.
     */
    create: XOR<addressCreateInput, addressUncheckedCreateInput>
    /**
     * In case the address was found with the provided `where` argument, update it with this data.
     */
    update: XOR<addressUpdateInput, addressUncheckedUpdateInput>
  }


  /**
   * address delete
   */
  export type addressDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the address
     */
    select?: addressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: addressInclude<ExtArgs> | null
    /**
     * Filter which address to delete.
     */
    where: addressWhereUniqueInput
  }


  /**
   * address deleteMany
   */
  export type addressDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which addresses to delete
     */
    where?: addressWhereInput
  }


  /**
   * address.order
   */
  export type address$orderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order
     */
    select?: orderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: orderInclude<ExtArgs> | null
    where?: orderWhereInput
    orderBy?: orderOrderByWithRelationInput | orderOrderByWithRelationInput[]
    cursor?: orderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }


  /**
   * address without action
   */
  export type addressDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the address
     */
    select?: addressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: addressInclude<ExtArgs> | null
  }



  /**
   * Model brand
   */

  export type AggregateBrand = {
    _count: BrandCountAggregateOutputType | null
    _avg: BrandAvgAggregateOutputType | null
    _sum: BrandSumAggregateOutputType | null
    _min: BrandMinAggregateOutputType | null
    _max: BrandMaxAggregateOutputType | null
  }

  export type BrandAvgAggregateOutputType = {
    id: number | null
  }

  export type BrandSumAggregateOutputType = {
    id: number | null
  }

  export type BrandMinAggregateOutputType = {
    id: number | null
    name: string | null
    detail: string | null
    imagePath: string | null
    imageSrc: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BrandMaxAggregateOutputType = {
    id: number | null
    name: string | null
    detail: string | null
    imagePath: string | null
    imageSrc: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BrandCountAggregateOutputType = {
    id: number
    name: number
    detail: number
    imagePath: number
    imageSrc: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BrandAvgAggregateInputType = {
    id?: true
  }

  export type BrandSumAggregateInputType = {
    id?: true
  }

  export type BrandMinAggregateInputType = {
    id?: true
    name?: true
    detail?: true
    imagePath?: true
    imageSrc?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BrandMaxAggregateInputType = {
    id?: true
    name?: true
    detail?: true
    imagePath?: true
    imageSrc?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BrandCountAggregateInputType = {
    id?: true
    name?: true
    detail?: true
    imagePath?: true
    imageSrc?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BrandAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which brand to aggregate.
     */
    where?: brandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of brands to fetch.
     */
    orderBy?: brandOrderByWithRelationInput | brandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: brandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` brands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` brands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned brands
    **/
    _count?: true | BrandCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BrandAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BrandSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BrandMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BrandMaxAggregateInputType
  }

  export type GetBrandAggregateType<T extends BrandAggregateArgs> = {
        [P in keyof T & keyof AggregateBrand]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBrand[P]>
      : GetScalarType<T[P], AggregateBrand[P]>
  }




  export type brandGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: brandWhereInput
    orderBy?: brandOrderByWithAggregationInput | brandOrderByWithAggregationInput[]
    by: BrandScalarFieldEnum[] | BrandScalarFieldEnum
    having?: brandScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BrandCountAggregateInputType | true
    _avg?: BrandAvgAggregateInputType
    _sum?: BrandSumAggregateInputType
    _min?: BrandMinAggregateInputType
    _max?: BrandMaxAggregateInputType
  }

  export type BrandGroupByOutputType = {
    id: number
    name: string
    detail: string | null
    imagePath: string | null
    imageSrc: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: BrandCountAggregateOutputType | null
    _avg: BrandAvgAggregateOutputType | null
    _sum: BrandSumAggregateOutputType | null
    _min: BrandMinAggregateOutputType | null
    _max: BrandMaxAggregateOutputType | null
  }

  type GetBrandGroupByPayload<T extends brandGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BrandGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BrandGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BrandGroupByOutputType[P]>
            : GetScalarType<T[P], BrandGroupByOutputType[P]>
        }
      >
    >


  export type brandSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    detail?: boolean
    imagePath?: boolean
    imageSrc?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | brand$productArgs<ExtArgs>
    _count?: boolean | BrandCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["brand"]>

  export type brandSelectScalar = {
    id?: boolean
    name?: boolean
    detail?: boolean
    imagePath?: boolean
    imageSrc?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type brandInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | brand$productArgs<ExtArgs>
    _count?: boolean | BrandCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $brandPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "brand"
    objects: {
      product: Prisma.$productPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      detail: string | null
      imagePath: string | null
      imageSrc: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["brand"]>
    composites: {}
  }


  type brandGetPayload<S extends boolean | null | undefined | brandDefaultArgs> = $Result.GetResult<Prisma.$brandPayload, S>

  type brandCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<brandFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BrandCountAggregateInputType | true
    }

  export interface brandDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['brand'], meta: { name: 'brand' } }
    /**
     * Find zero or one Brand that matches the filter.
     * @param {brandFindUniqueArgs} args - Arguments to find a Brand
     * @example
     * // Get one Brand
     * const brand = await prisma.brand.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends brandFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, brandFindUniqueArgs<ExtArgs>>
    ): Prisma__brandClient<$Result.GetResult<Prisma.$brandPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Brand that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {brandFindUniqueOrThrowArgs} args - Arguments to find a Brand
     * @example
     * // Get one Brand
     * const brand = await prisma.brand.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends brandFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, brandFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__brandClient<$Result.GetResult<Prisma.$brandPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Brand that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {brandFindFirstArgs} args - Arguments to find a Brand
     * @example
     * // Get one Brand
     * const brand = await prisma.brand.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends brandFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, brandFindFirstArgs<ExtArgs>>
    ): Prisma__brandClient<$Result.GetResult<Prisma.$brandPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Brand that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {brandFindFirstOrThrowArgs} args - Arguments to find a Brand
     * @example
     * // Get one Brand
     * const brand = await prisma.brand.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends brandFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, brandFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__brandClient<$Result.GetResult<Prisma.$brandPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Brands that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {brandFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Brands
     * const brands = await prisma.brand.findMany()
     * 
     * // Get first 10 Brands
     * const brands = await prisma.brand.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const brandWithIdOnly = await prisma.brand.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends brandFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, brandFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$brandPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Brand.
     * @param {brandCreateArgs} args - Arguments to create a Brand.
     * @example
     * // Create one Brand
     * const Brand = await prisma.brand.create({
     *   data: {
     *     // ... data to create a Brand
     *   }
     * })
     * 
    **/
    create<T extends brandCreateArgs<ExtArgs>>(
      args: SelectSubset<T, brandCreateArgs<ExtArgs>>
    ): Prisma__brandClient<$Result.GetResult<Prisma.$brandPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Brands.
     *     @param {brandCreateManyArgs} args - Arguments to create many Brands.
     *     @example
     *     // Create many Brands
     *     const brand = await prisma.brand.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends brandCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, brandCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Brand.
     * @param {brandDeleteArgs} args - Arguments to delete one Brand.
     * @example
     * // Delete one Brand
     * const Brand = await prisma.brand.delete({
     *   where: {
     *     // ... filter to delete one Brand
     *   }
     * })
     * 
    **/
    delete<T extends brandDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, brandDeleteArgs<ExtArgs>>
    ): Prisma__brandClient<$Result.GetResult<Prisma.$brandPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Brand.
     * @param {brandUpdateArgs} args - Arguments to update one Brand.
     * @example
     * // Update one Brand
     * const brand = await prisma.brand.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends brandUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, brandUpdateArgs<ExtArgs>>
    ): Prisma__brandClient<$Result.GetResult<Prisma.$brandPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Brands.
     * @param {brandDeleteManyArgs} args - Arguments to filter Brands to delete.
     * @example
     * // Delete a few Brands
     * const { count } = await prisma.brand.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends brandDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, brandDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Brands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {brandUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Brands
     * const brand = await prisma.brand.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends brandUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, brandUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Brand.
     * @param {brandUpsertArgs} args - Arguments to update or create a Brand.
     * @example
     * // Update or create a Brand
     * const brand = await prisma.brand.upsert({
     *   create: {
     *     // ... data to create a Brand
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Brand we want to update
     *   }
     * })
    **/
    upsert<T extends brandUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, brandUpsertArgs<ExtArgs>>
    ): Prisma__brandClient<$Result.GetResult<Prisma.$brandPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Brands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {brandCountArgs} args - Arguments to filter Brands to count.
     * @example
     * // Count the number of Brands
     * const count = await prisma.brand.count({
     *   where: {
     *     // ... the filter for the Brands we want to count
     *   }
     * })
    **/
    count<T extends brandCountArgs>(
      args?: Subset<T, brandCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BrandCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Brand.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrandAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BrandAggregateArgs>(args: Subset<T, BrandAggregateArgs>): Prisma.PrismaPromise<GetBrandAggregateType<T>>

    /**
     * Group by Brand.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {brandGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends brandGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: brandGroupByArgs['orderBy'] }
        : { orderBy?: brandGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, brandGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBrandGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the brand model
   */
  readonly fields: brandFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for brand.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__brandClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    product<T extends brand$productArgs<ExtArgs> = {}>(args?: Subset<T, brand$productArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$productPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the brand model
   */ 
  interface brandFieldRefs {
    readonly id: FieldRef<"brand", 'Int'>
    readonly name: FieldRef<"brand", 'String'>
    readonly detail: FieldRef<"brand", 'String'>
    readonly imagePath: FieldRef<"brand", 'String'>
    readonly imageSrc: FieldRef<"brand", 'String'>
    readonly isActive: FieldRef<"brand", 'Boolean'>
    readonly createdAt: FieldRef<"brand", 'DateTime'>
    readonly updatedAt: FieldRef<"brand", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * brand findUnique
   */
  export type brandFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the brand
     */
    select?: brandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: brandInclude<ExtArgs> | null
    /**
     * Filter, which brand to fetch.
     */
    where: brandWhereUniqueInput
  }


  /**
   * brand findUniqueOrThrow
   */
  export type brandFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the brand
     */
    select?: brandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: brandInclude<ExtArgs> | null
    /**
     * Filter, which brand to fetch.
     */
    where: brandWhereUniqueInput
  }


  /**
   * brand findFirst
   */
  export type brandFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the brand
     */
    select?: brandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: brandInclude<ExtArgs> | null
    /**
     * Filter, which brand to fetch.
     */
    where?: brandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of brands to fetch.
     */
    orderBy?: brandOrderByWithRelationInput | brandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for brands.
     */
    cursor?: brandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` brands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` brands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of brands.
     */
    distinct?: BrandScalarFieldEnum | BrandScalarFieldEnum[]
  }


  /**
   * brand findFirstOrThrow
   */
  export type brandFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the brand
     */
    select?: brandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: brandInclude<ExtArgs> | null
    /**
     * Filter, which brand to fetch.
     */
    where?: brandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of brands to fetch.
     */
    orderBy?: brandOrderByWithRelationInput | brandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for brands.
     */
    cursor?: brandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` brands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` brands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of brands.
     */
    distinct?: BrandScalarFieldEnum | BrandScalarFieldEnum[]
  }


  /**
   * brand findMany
   */
  export type brandFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the brand
     */
    select?: brandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: brandInclude<ExtArgs> | null
    /**
     * Filter, which brands to fetch.
     */
    where?: brandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of brands to fetch.
     */
    orderBy?: brandOrderByWithRelationInput | brandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing brands.
     */
    cursor?: brandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` brands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` brands.
     */
    skip?: number
    distinct?: BrandScalarFieldEnum | BrandScalarFieldEnum[]
  }


  /**
   * brand create
   */
  export type brandCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the brand
     */
    select?: brandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: brandInclude<ExtArgs> | null
    /**
     * The data needed to create a brand.
     */
    data: XOR<brandCreateInput, brandUncheckedCreateInput>
  }


  /**
   * brand createMany
   */
  export type brandCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many brands.
     */
    data: brandCreateManyInput | brandCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * brand update
   */
  export type brandUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the brand
     */
    select?: brandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: brandInclude<ExtArgs> | null
    /**
     * The data needed to update a brand.
     */
    data: XOR<brandUpdateInput, brandUncheckedUpdateInput>
    /**
     * Choose, which brand to update.
     */
    where: brandWhereUniqueInput
  }


  /**
   * brand updateMany
   */
  export type brandUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update brands.
     */
    data: XOR<brandUpdateManyMutationInput, brandUncheckedUpdateManyInput>
    /**
     * Filter which brands to update
     */
    where?: brandWhereInput
  }


  /**
   * brand upsert
   */
  export type brandUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the brand
     */
    select?: brandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: brandInclude<ExtArgs> | null
    /**
     * The filter to search for the brand to update in case it exists.
     */
    where: brandWhereUniqueInput
    /**
     * In case the brand found by the `where` argument doesn't exist, create a new brand with this data.
     */
    create: XOR<brandCreateInput, brandUncheckedCreateInput>
    /**
     * In case the brand was found with the provided `where` argument, update it with this data.
     */
    update: XOR<brandUpdateInput, brandUncheckedUpdateInput>
  }


  /**
   * brand delete
   */
  export type brandDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the brand
     */
    select?: brandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: brandInclude<ExtArgs> | null
    /**
     * Filter which brand to delete.
     */
    where: brandWhereUniqueInput
  }


  /**
   * brand deleteMany
   */
  export type brandDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which brands to delete
     */
    where?: brandWhereInput
  }


  /**
   * brand.product
   */
  export type brand$productArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: productInclude<ExtArgs> | null
    where?: productWhereInput
    orderBy?: productOrderByWithRelationInput | productOrderByWithRelationInput[]
    cursor?: productWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }


  /**
   * brand without action
   */
  export type brandDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the brand
     */
    select?: brandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: brandInclude<ExtArgs> | null
  }



  /**
   * Model tag
   */

  export type AggregateTag = {
    _count: TagCountAggregateOutputType | null
    _avg: TagAvgAggregateOutputType | null
    _sum: TagSumAggregateOutputType | null
    _min: TagMinAggregateOutputType | null
    _max: TagMaxAggregateOutputType | null
  }

  export type TagAvgAggregateOutputType = {
    id: number | null
  }

  export type TagSumAggregateOutputType = {
    id: number | null
  }

  export type TagMinAggregateOutputType = {
    id: number | null
    name: string | null
    detail: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TagMaxAggregateOutputType = {
    id: number | null
    name: string | null
    detail: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TagCountAggregateOutputType = {
    id: number
    name: number
    detail: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TagAvgAggregateInputType = {
    id?: true
  }

  export type TagSumAggregateInputType = {
    id?: true
  }

  export type TagMinAggregateInputType = {
    id?: true
    name?: true
    detail?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TagMaxAggregateInputType = {
    id?: true
    name?: true
    detail?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TagCountAggregateInputType = {
    id?: true
    name?: true
    detail?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tag to aggregate.
     */
    where?: tagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tags to fetch.
     */
    orderBy?: tagOrderByWithRelationInput | tagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tags
    **/
    _count?: true | TagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TagAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TagSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TagMaxAggregateInputType
  }

  export type GetTagAggregateType<T extends TagAggregateArgs> = {
        [P in keyof T & keyof AggregateTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTag[P]>
      : GetScalarType<T[P], AggregateTag[P]>
  }




  export type tagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tagWhereInput
    orderBy?: tagOrderByWithAggregationInput | tagOrderByWithAggregationInput[]
    by: TagScalarFieldEnum[] | TagScalarFieldEnum
    having?: tagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TagCountAggregateInputType | true
    _avg?: TagAvgAggregateInputType
    _sum?: TagSumAggregateInputType
    _min?: TagMinAggregateInputType
    _max?: TagMaxAggregateInputType
  }

  export type TagGroupByOutputType = {
    id: number
    name: string
    detail: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: TagCountAggregateOutputType | null
    _avg: TagAvgAggregateOutputType | null
    _sum: TagSumAggregateOutputType | null
    _min: TagMinAggregateOutputType | null
    _max: TagMaxAggregateOutputType | null
  }

  type GetTagGroupByPayload<T extends tagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TagGroupByOutputType[P]>
            : GetScalarType<T[P], TagGroupByOutputType[P]>
        }
      >
    >


  export type tagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    detail?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product_tag?: boolean | tag$product_tagArgs<ExtArgs>
    _count?: boolean | TagCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tag"]>

  export type tagSelectScalar = {
    id?: boolean
    name?: boolean
    detail?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type tagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product_tag?: boolean | tag$product_tagArgs<ExtArgs>
    _count?: boolean | TagCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $tagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tag"
    objects: {
      product_tag: Prisma.$product_tagPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      detail: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["tag"]>
    composites: {}
  }


  type tagGetPayload<S extends boolean | null | undefined | tagDefaultArgs> = $Result.GetResult<Prisma.$tagPayload, S>

  type tagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<tagFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TagCountAggregateInputType | true
    }

  export interface tagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tag'], meta: { name: 'tag' } }
    /**
     * Find zero or one Tag that matches the filter.
     * @param {tagFindUniqueArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends tagFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, tagFindUniqueArgs<ExtArgs>>
    ): Prisma__tagClient<$Result.GetResult<Prisma.$tagPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Tag that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {tagFindUniqueOrThrowArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends tagFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, tagFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__tagClient<$Result.GetResult<Prisma.$tagPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Tag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tagFindFirstArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends tagFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, tagFindFirstArgs<ExtArgs>>
    ): Prisma__tagClient<$Result.GetResult<Prisma.$tagPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Tag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tagFindFirstOrThrowArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends tagFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, tagFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__tagClient<$Result.GetResult<Prisma.$tagPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tagFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tags
     * const tags = await prisma.tag.findMany()
     * 
     * // Get first 10 Tags
     * const tags = await prisma.tag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tagWithIdOnly = await prisma.tag.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends tagFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, tagFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tagPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Tag.
     * @param {tagCreateArgs} args - Arguments to create a Tag.
     * @example
     * // Create one Tag
     * const Tag = await prisma.tag.create({
     *   data: {
     *     // ... data to create a Tag
     *   }
     * })
     * 
    **/
    create<T extends tagCreateArgs<ExtArgs>>(
      args: SelectSubset<T, tagCreateArgs<ExtArgs>>
    ): Prisma__tagClient<$Result.GetResult<Prisma.$tagPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Tags.
     *     @param {tagCreateManyArgs} args - Arguments to create many Tags.
     *     @example
     *     // Create many Tags
     *     const tag = await prisma.tag.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends tagCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, tagCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tag.
     * @param {tagDeleteArgs} args - Arguments to delete one Tag.
     * @example
     * // Delete one Tag
     * const Tag = await prisma.tag.delete({
     *   where: {
     *     // ... filter to delete one Tag
     *   }
     * })
     * 
    **/
    delete<T extends tagDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, tagDeleteArgs<ExtArgs>>
    ): Prisma__tagClient<$Result.GetResult<Prisma.$tagPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Tag.
     * @param {tagUpdateArgs} args - Arguments to update one Tag.
     * @example
     * // Update one Tag
     * const tag = await prisma.tag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends tagUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, tagUpdateArgs<ExtArgs>>
    ): Prisma__tagClient<$Result.GetResult<Prisma.$tagPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Tags.
     * @param {tagDeleteManyArgs} args - Arguments to filter Tags to delete.
     * @example
     * // Delete a few Tags
     * const { count } = await prisma.tag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends tagDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, tagDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tags
     * const tag = await prisma.tag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends tagUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, tagUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tag.
     * @param {tagUpsertArgs} args - Arguments to update or create a Tag.
     * @example
     * // Update or create a Tag
     * const tag = await prisma.tag.upsert({
     *   create: {
     *     // ... data to create a Tag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tag we want to update
     *   }
     * })
    **/
    upsert<T extends tagUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, tagUpsertArgs<ExtArgs>>
    ): Prisma__tagClient<$Result.GetResult<Prisma.$tagPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tagCountArgs} args - Arguments to filter Tags to count.
     * @example
     * // Count the number of Tags
     * const count = await prisma.tag.count({
     *   where: {
     *     // ... the filter for the Tags we want to count
     *   }
     * })
    **/
    count<T extends tagCountArgs>(
      args?: Subset<T, tagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TagAggregateArgs>(args: Subset<T, TagAggregateArgs>): Prisma.PrismaPromise<GetTagAggregateType<T>>

    /**
     * Group by Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tagGroupByArgs['orderBy'] }
        : { orderBy?: tagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tag model
   */
  readonly fields: tagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    product_tag<T extends tag$product_tagArgs<ExtArgs> = {}>(args?: Subset<T, tag$product_tagArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$product_tagPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the tag model
   */ 
  interface tagFieldRefs {
    readonly id: FieldRef<"tag", 'Int'>
    readonly name: FieldRef<"tag", 'String'>
    readonly detail: FieldRef<"tag", 'String'>
    readonly isActive: FieldRef<"tag", 'Boolean'>
    readonly createdAt: FieldRef<"tag", 'DateTime'>
    readonly updatedAt: FieldRef<"tag", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * tag findUnique
   */
  export type tagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tag
     */
    select?: tagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tagInclude<ExtArgs> | null
    /**
     * Filter, which tag to fetch.
     */
    where: tagWhereUniqueInput
  }


  /**
   * tag findUniqueOrThrow
   */
  export type tagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tag
     */
    select?: tagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tagInclude<ExtArgs> | null
    /**
     * Filter, which tag to fetch.
     */
    where: tagWhereUniqueInput
  }


  /**
   * tag findFirst
   */
  export type tagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tag
     */
    select?: tagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tagInclude<ExtArgs> | null
    /**
     * Filter, which tag to fetch.
     */
    where?: tagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tags to fetch.
     */
    orderBy?: tagOrderByWithRelationInput | tagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tags.
     */
    cursor?: tagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tags.
     */
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }


  /**
   * tag findFirstOrThrow
   */
  export type tagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tag
     */
    select?: tagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tagInclude<ExtArgs> | null
    /**
     * Filter, which tag to fetch.
     */
    where?: tagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tags to fetch.
     */
    orderBy?: tagOrderByWithRelationInput | tagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tags.
     */
    cursor?: tagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tags.
     */
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }


  /**
   * tag findMany
   */
  export type tagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tag
     */
    select?: tagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tagInclude<ExtArgs> | null
    /**
     * Filter, which tags to fetch.
     */
    where?: tagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tags to fetch.
     */
    orderBy?: tagOrderByWithRelationInput | tagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tags.
     */
    cursor?: tagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tags.
     */
    skip?: number
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }


  /**
   * tag create
   */
  export type tagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tag
     */
    select?: tagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tagInclude<ExtArgs> | null
    /**
     * The data needed to create a tag.
     */
    data: XOR<tagCreateInput, tagUncheckedCreateInput>
  }


  /**
   * tag createMany
   */
  export type tagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tags.
     */
    data: tagCreateManyInput | tagCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * tag update
   */
  export type tagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tag
     */
    select?: tagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tagInclude<ExtArgs> | null
    /**
     * The data needed to update a tag.
     */
    data: XOR<tagUpdateInput, tagUncheckedUpdateInput>
    /**
     * Choose, which tag to update.
     */
    where: tagWhereUniqueInput
  }


  /**
   * tag updateMany
   */
  export type tagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tags.
     */
    data: XOR<tagUpdateManyMutationInput, tagUncheckedUpdateManyInput>
    /**
     * Filter which tags to update
     */
    where?: tagWhereInput
  }


  /**
   * tag upsert
   */
  export type tagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tag
     */
    select?: tagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tagInclude<ExtArgs> | null
    /**
     * The filter to search for the tag to update in case it exists.
     */
    where: tagWhereUniqueInput
    /**
     * In case the tag found by the `where` argument doesn't exist, create a new tag with this data.
     */
    create: XOR<tagCreateInput, tagUncheckedCreateInput>
    /**
     * In case the tag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tagUpdateInput, tagUncheckedUpdateInput>
  }


  /**
   * tag delete
   */
  export type tagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tag
     */
    select?: tagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tagInclude<ExtArgs> | null
    /**
     * Filter which tag to delete.
     */
    where: tagWhereUniqueInput
  }


  /**
   * tag deleteMany
   */
  export type tagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tags to delete
     */
    where?: tagWhereInput
  }


  /**
   * tag.product_tag
   */
  export type tag$product_tagArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_tag
     */
    select?: product_tagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: product_tagInclude<ExtArgs> | null
    where?: product_tagWhereInput
    orderBy?: product_tagOrderByWithRelationInput | product_tagOrderByWithRelationInput[]
    cursor?: product_tagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Product_tagScalarFieldEnum | Product_tagScalarFieldEnum[]
  }


  /**
   * tag without action
   */
  export type tagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tag
     */
    select?: tagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tagInclude<ExtArgs> | null
  }



  /**
   * Model category
   */

  export type AggregateCategory = {
    _count: CategoryCountAggregateOutputType | null
    _avg: CategoryAvgAggregateOutputType | null
    _sum: CategorySumAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  export type CategoryAvgAggregateOutputType = {
    id: number | null
  }

  export type CategorySumAggregateOutputType = {
    id: number | null
  }

  export type CategoryMinAggregateOutputType = {
    id: number | null
    name: string | null
    detail: string | null
    imagePath: string | null
    imageSrc: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CategoryMaxAggregateOutputType = {
    id: number | null
    name: string | null
    detail: string | null
    imagePath: string | null
    imageSrc: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CategoryCountAggregateOutputType = {
    id: number
    name: number
    detail: number
    imagePath: number
    imageSrc: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CategoryAvgAggregateInputType = {
    id?: true
  }

  export type CategorySumAggregateInputType = {
    id?: true
  }

  export type CategoryMinAggregateInputType = {
    id?: true
    name?: true
    detail?: true
    imagePath?: true
    imageSrc?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CategoryMaxAggregateInputType = {
    id?: true
    name?: true
    detail?: true
    imagePath?: true
    imageSrc?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CategoryCountAggregateInputType = {
    id?: true
    name?: true
    detail?: true
    imagePath?: true
    imageSrc?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which category to aggregate.
     */
    where?: categoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categories to fetch.
     */
    orderBy?: categoryOrderByWithRelationInput | categoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: categoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned categories
    **/
    _count?: true | CategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoryMaxAggregateInputType
  }

  export type GetCategoryAggregateType<T extends CategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategory[P]>
      : GetScalarType<T[P], AggregateCategory[P]>
  }




  export type categoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: categoryWhereInput
    orderBy?: categoryOrderByWithAggregationInput | categoryOrderByWithAggregationInput[]
    by: CategoryScalarFieldEnum[] | CategoryScalarFieldEnum
    having?: categoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoryCountAggregateInputType | true
    _avg?: CategoryAvgAggregateInputType
    _sum?: CategorySumAggregateInputType
    _min?: CategoryMinAggregateInputType
    _max?: CategoryMaxAggregateInputType
  }

  export type CategoryGroupByOutputType = {
    id: number
    name: string
    detail: string | null
    imagePath: string | null
    imageSrc: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: CategoryCountAggregateOutputType | null
    _avg: CategoryAvgAggregateOutputType | null
    _sum: CategorySumAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  type GetCategoryGroupByPayload<T extends categoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoryGroupByOutputType[P]>
            : GetScalarType<T[P], CategoryGroupByOutputType[P]>
        }
      >
    >


  export type categorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    detail?: boolean
    imagePath?: boolean
    imageSrc?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sub_category?: boolean | category$sub_categoryArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type categorySelectScalar = {
    id?: boolean
    name?: boolean
    detail?: boolean
    imagePath?: boolean
    imageSrc?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type categoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sub_category?: boolean | category$sub_categoryArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $categoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "category"
    objects: {
      sub_category: Prisma.$sub_categoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      detail: string | null
      imagePath: string | null
      imageSrc: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["category"]>
    composites: {}
  }


  type categoryGetPayload<S extends boolean | null | undefined | categoryDefaultArgs> = $Result.GetResult<Prisma.$categoryPayload, S>

  type categoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<categoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CategoryCountAggregateInputType | true
    }

  export interface categoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['category'], meta: { name: 'category' } }
    /**
     * Find zero or one Category that matches the filter.
     * @param {categoryFindUniqueArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends categoryFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, categoryFindUniqueArgs<ExtArgs>>
    ): Prisma__categoryClient<$Result.GetResult<Prisma.$categoryPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Category that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {categoryFindUniqueOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends categoryFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, categoryFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__categoryClient<$Result.GetResult<Prisma.$categoryPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Category that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoryFindFirstArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends categoryFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, categoryFindFirstArgs<ExtArgs>>
    ): Prisma__categoryClient<$Result.GetResult<Prisma.$categoryPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Category that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoryFindFirstOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends categoryFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, categoryFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__categoryClient<$Result.GetResult<Prisma.$categoryPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categories
     * const categories = await prisma.category.findMany()
     * 
     * // Get first 10 Categories
     * const categories = await prisma.category.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoryWithIdOnly = await prisma.category.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends categoryFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, categoryFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$categoryPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Category.
     * @param {categoryCreateArgs} args - Arguments to create a Category.
     * @example
     * // Create one Category
     * const Category = await prisma.category.create({
     *   data: {
     *     // ... data to create a Category
     *   }
     * })
     * 
    **/
    create<T extends categoryCreateArgs<ExtArgs>>(
      args: SelectSubset<T, categoryCreateArgs<ExtArgs>>
    ): Prisma__categoryClient<$Result.GetResult<Prisma.$categoryPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Categories.
     *     @param {categoryCreateManyArgs} args - Arguments to create many Categories.
     *     @example
     *     // Create many Categories
     *     const category = await prisma.category.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends categoryCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, categoryCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Category.
     * @param {categoryDeleteArgs} args - Arguments to delete one Category.
     * @example
     * // Delete one Category
     * const Category = await prisma.category.delete({
     *   where: {
     *     // ... filter to delete one Category
     *   }
     * })
     * 
    **/
    delete<T extends categoryDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, categoryDeleteArgs<ExtArgs>>
    ): Prisma__categoryClient<$Result.GetResult<Prisma.$categoryPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Category.
     * @param {categoryUpdateArgs} args - Arguments to update one Category.
     * @example
     * // Update one Category
     * const category = await prisma.category.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends categoryUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, categoryUpdateArgs<ExtArgs>>
    ): Prisma__categoryClient<$Result.GetResult<Prisma.$categoryPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Categories.
     * @param {categoryDeleteManyArgs} args - Arguments to filter Categories to delete.
     * @example
     * // Delete a few Categories
     * const { count } = await prisma.category.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends categoryDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, categoryDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends categoryUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, categoryUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Category.
     * @param {categoryUpsertArgs} args - Arguments to update or create a Category.
     * @example
     * // Update or create a Category
     * const category = await prisma.category.upsert({
     *   create: {
     *     // ... data to create a Category
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Category we want to update
     *   }
     * })
    **/
    upsert<T extends categoryUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, categoryUpsertArgs<ExtArgs>>
    ): Prisma__categoryClient<$Result.GetResult<Prisma.$categoryPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoryCountArgs} args - Arguments to filter Categories to count.
     * @example
     * // Count the number of Categories
     * const count = await prisma.category.count({
     *   where: {
     *     // ... the filter for the Categories we want to count
     *   }
     * })
    **/
    count<T extends categoryCountArgs>(
      args?: Subset<T, categoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoryAggregateArgs>(args: Subset<T, CategoryAggregateArgs>): Prisma.PrismaPromise<GetCategoryAggregateType<T>>

    /**
     * Group by Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends categoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: categoryGroupByArgs['orderBy'] }
        : { orderBy?: categoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, categoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the category model
   */
  readonly fields: categoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for category.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__categoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    sub_category<T extends category$sub_categoryArgs<ExtArgs> = {}>(args?: Subset<T, category$sub_categoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sub_categoryPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the category model
   */ 
  interface categoryFieldRefs {
    readonly id: FieldRef<"category", 'Int'>
    readonly name: FieldRef<"category", 'String'>
    readonly detail: FieldRef<"category", 'String'>
    readonly imagePath: FieldRef<"category", 'String'>
    readonly imageSrc: FieldRef<"category", 'String'>
    readonly isActive: FieldRef<"category", 'Boolean'>
    readonly createdAt: FieldRef<"category", 'DateTime'>
    readonly updatedAt: FieldRef<"category", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * category findUnique
   */
  export type categoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category
     */
    select?: categorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: categoryInclude<ExtArgs> | null
    /**
     * Filter, which category to fetch.
     */
    where: categoryWhereUniqueInput
  }


  /**
   * category findUniqueOrThrow
   */
  export type categoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category
     */
    select?: categorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: categoryInclude<ExtArgs> | null
    /**
     * Filter, which category to fetch.
     */
    where: categoryWhereUniqueInput
  }


  /**
   * category findFirst
   */
  export type categoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category
     */
    select?: categorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: categoryInclude<ExtArgs> | null
    /**
     * Filter, which category to fetch.
     */
    where?: categoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categories to fetch.
     */
    orderBy?: categoryOrderByWithRelationInput | categoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for categories.
     */
    cursor?: categoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }


  /**
   * category findFirstOrThrow
   */
  export type categoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category
     */
    select?: categorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: categoryInclude<ExtArgs> | null
    /**
     * Filter, which category to fetch.
     */
    where?: categoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categories to fetch.
     */
    orderBy?: categoryOrderByWithRelationInput | categoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for categories.
     */
    cursor?: categoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }


  /**
   * category findMany
   */
  export type categoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category
     */
    select?: categorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: categoryInclude<ExtArgs> | null
    /**
     * Filter, which categories to fetch.
     */
    where?: categoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categories to fetch.
     */
    orderBy?: categoryOrderByWithRelationInput | categoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing categories.
     */
    cursor?: categoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categories.
     */
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }


  /**
   * category create
   */
  export type categoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category
     */
    select?: categorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: categoryInclude<ExtArgs> | null
    /**
     * The data needed to create a category.
     */
    data: XOR<categoryCreateInput, categoryUncheckedCreateInput>
  }


  /**
   * category createMany
   */
  export type categoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many categories.
     */
    data: categoryCreateManyInput | categoryCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * category update
   */
  export type categoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category
     */
    select?: categorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: categoryInclude<ExtArgs> | null
    /**
     * The data needed to update a category.
     */
    data: XOR<categoryUpdateInput, categoryUncheckedUpdateInput>
    /**
     * Choose, which category to update.
     */
    where: categoryWhereUniqueInput
  }


  /**
   * category updateMany
   */
  export type categoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update categories.
     */
    data: XOR<categoryUpdateManyMutationInput, categoryUncheckedUpdateManyInput>
    /**
     * Filter which categories to update
     */
    where?: categoryWhereInput
  }


  /**
   * category upsert
   */
  export type categoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category
     */
    select?: categorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: categoryInclude<ExtArgs> | null
    /**
     * The filter to search for the category to update in case it exists.
     */
    where: categoryWhereUniqueInput
    /**
     * In case the category found by the `where` argument doesn't exist, create a new category with this data.
     */
    create: XOR<categoryCreateInput, categoryUncheckedCreateInput>
    /**
     * In case the category was found with the provided `where` argument, update it with this data.
     */
    update: XOR<categoryUpdateInput, categoryUncheckedUpdateInput>
  }


  /**
   * category delete
   */
  export type categoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category
     */
    select?: categorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: categoryInclude<ExtArgs> | null
    /**
     * Filter which category to delete.
     */
    where: categoryWhereUniqueInput
  }


  /**
   * category deleteMany
   */
  export type categoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which categories to delete
     */
    where?: categoryWhereInput
  }


  /**
   * category.sub_category
   */
  export type category$sub_categoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sub_category
     */
    select?: sub_categorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sub_categoryInclude<ExtArgs> | null
    where?: sub_categoryWhereInput
    orderBy?: sub_categoryOrderByWithRelationInput | sub_categoryOrderByWithRelationInput[]
    cursor?: sub_categoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Sub_categoryScalarFieldEnum | Sub_categoryScalarFieldEnum[]
  }


  /**
   * category without action
   */
  export type categoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category
     */
    select?: categorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: categoryInclude<ExtArgs> | null
  }



  /**
   * Model sub_category
   */

  export type AggregateSub_category = {
    _count: Sub_categoryCountAggregateOutputType | null
    _avg: Sub_categoryAvgAggregateOutputType | null
    _sum: Sub_categorySumAggregateOutputType | null
    _min: Sub_categoryMinAggregateOutputType | null
    _max: Sub_categoryMaxAggregateOutputType | null
  }

  export type Sub_categoryAvgAggregateOutputType = {
    id: number | null
    categoryId: number | null
  }

  export type Sub_categorySumAggregateOutputType = {
    id: number | null
    categoryId: number | null
  }

  export type Sub_categoryMinAggregateOutputType = {
    id: number | null
    categoryId: number | null
    name: string | null
    detail: string | null
    imagePath: string | null
    imageSrc: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Sub_categoryMaxAggregateOutputType = {
    id: number | null
    categoryId: number | null
    name: string | null
    detail: string | null
    imagePath: string | null
    imageSrc: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Sub_categoryCountAggregateOutputType = {
    id: number
    categoryId: number
    name: number
    detail: number
    imagePath: number
    imageSrc: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Sub_categoryAvgAggregateInputType = {
    id?: true
    categoryId?: true
  }

  export type Sub_categorySumAggregateInputType = {
    id?: true
    categoryId?: true
  }

  export type Sub_categoryMinAggregateInputType = {
    id?: true
    categoryId?: true
    name?: true
    detail?: true
    imagePath?: true
    imageSrc?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Sub_categoryMaxAggregateInputType = {
    id?: true
    categoryId?: true
    name?: true
    detail?: true
    imagePath?: true
    imageSrc?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Sub_categoryCountAggregateInputType = {
    id?: true
    categoryId?: true
    name?: true
    detail?: true
    imagePath?: true
    imageSrc?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Sub_categoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which sub_category to aggregate.
     */
    where?: sub_categoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sub_categories to fetch.
     */
    orderBy?: sub_categoryOrderByWithRelationInput | sub_categoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: sub_categoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sub_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sub_categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned sub_categories
    **/
    _count?: true | Sub_categoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Sub_categoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Sub_categorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Sub_categoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Sub_categoryMaxAggregateInputType
  }

  export type GetSub_categoryAggregateType<T extends Sub_categoryAggregateArgs> = {
        [P in keyof T & keyof AggregateSub_category]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSub_category[P]>
      : GetScalarType<T[P], AggregateSub_category[P]>
  }




  export type sub_categoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: sub_categoryWhereInput
    orderBy?: sub_categoryOrderByWithAggregationInput | sub_categoryOrderByWithAggregationInput[]
    by: Sub_categoryScalarFieldEnum[] | Sub_categoryScalarFieldEnum
    having?: sub_categoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Sub_categoryCountAggregateInputType | true
    _avg?: Sub_categoryAvgAggregateInputType
    _sum?: Sub_categorySumAggregateInputType
    _min?: Sub_categoryMinAggregateInputType
    _max?: Sub_categoryMaxAggregateInputType
  }

  export type Sub_categoryGroupByOutputType = {
    id: number
    categoryId: number
    name: string
    detail: string | null
    imagePath: string | null
    imageSrc: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: Sub_categoryCountAggregateOutputType | null
    _avg: Sub_categoryAvgAggregateOutputType | null
    _sum: Sub_categorySumAggregateOutputType | null
    _min: Sub_categoryMinAggregateOutputType | null
    _max: Sub_categoryMaxAggregateOutputType | null
  }

  type GetSub_categoryGroupByPayload<T extends sub_categoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Sub_categoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Sub_categoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Sub_categoryGroupByOutputType[P]>
            : GetScalarType<T[P], Sub_categoryGroupByOutputType[P]>
        }
      >
    >


  export type sub_categorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    categoryId?: boolean
    name?: boolean
    detail?: boolean
    imagePath?: boolean
    imageSrc?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    category?: boolean | categoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sub_category"]>

  export type sub_categorySelectScalar = {
    id?: boolean
    categoryId?: boolean
    name?: boolean
    detail?: boolean
    imagePath?: boolean
    imageSrc?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type sub_categoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | categoryDefaultArgs<ExtArgs>
  }


  export type $sub_categoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "sub_category"
    objects: {
      category: Prisma.$categoryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      categoryId: number
      name: string
      detail: string | null
      imagePath: string | null
      imageSrc: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["sub_category"]>
    composites: {}
  }


  type sub_categoryGetPayload<S extends boolean | null | undefined | sub_categoryDefaultArgs> = $Result.GetResult<Prisma.$sub_categoryPayload, S>

  type sub_categoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<sub_categoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Sub_categoryCountAggregateInputType | true
    }

  export interface sub_categoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['sub_category'], meta: { name: 'sub_category' } }
    /**
     * Find zero or one Sub_category that matches the filter.
     * @param {sub_categoryFindUniqueArgs} args - Arguments to find a Sub_category
     * @example
     * // Get one Sub_category
     * const sub_category = await prisma.sub_category.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends sub_categoryFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, sub_categoryFindUniqueArgs<ExtArgs>>
    ): Prisma__sub_categoryClient<$Result.GetResult<Prisma.$sub_categoryPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Sub_category that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {sub_categoryFindUniqueOrThrowArgs} args - Arguments to find a Sub_category
     * @example
     * // Get one Sub_category
     * const sub_category = await prisma.sub_category.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends sub_categoryFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, sub_categoryFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__sub_categoryClient<$Result.GetResult<Prisma.$sub_categoryPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Sub_category that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sub_categoryFindFirstArgs} args - Arguments to find a Sub_category
     * @example
     * // Get one Sub_category
     * const sub_category = await prisma.sub_category.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends sub_categoryFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, sub_categoryFindFirstArgs<ExtArgs>>
    ): Prisma__sub_categoryClient<$Result.GetResult<Prisma.$sub_categoryPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Sub_category that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sub_categoryFindFirstOrThrowArgs} args - Arguments to find a Sub_category
     * @example
     * // Get one Sub_category
     * const sub_category = await prisma.sub_category.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends sub_categoryFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, sub_categoryFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__sub_categoryClient<$Result.GetResult<Prisma.$sub_categoryPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Sub_categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sub_categoryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sub_categories
     * const sub_categories = await prisma.sub_category.findMany()
     * 
     * // Get first 10 Sub_categories
     * const sub_categories = await prisma.sub_category.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sub_categoryWithIdOnly = await prisma.sub_category.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends sub_categoryFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, sub_categoryFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sub_categoryPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Sub_category.
     * @param {sub_categoryCreateArgs} args - Arguments to create a Sub_category.
     * @example
     * // Create one Sub_category
     * const Sub_category = await prisma.sub_category.create({
     *   data: {
     *     // ... data to create a Sub_category
     *   }
     * })
     * 
    **/
    create<T extends sub_categoryCreateArgs<ExtArgs>>(
      args: SelectSubset<T, sub_categoryCreateArgs<ExtArgs>>
    ): Prisma__sub_categoryClient<$Result.GetResult<Prisma.$sub_categoryPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Sub_categories.
     *     @param {sub_categoryCreateManyArgs} args - Arguments to create many Sub_categories.
     *     @example
     *     // Create many Sub_categories
     *     const sub_category = await prisma.sub_category.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends sub_categoryCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, sub_categoryCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Sub_category.
     * @param {sub_categoryDeleteArgs} args - Arguments to delete one Sub_category.
     * @example
     * // Delete one Sub_category
     * const Sub_category = await prisma.sub_category.delete({
     *   where: {
     *     // ... filter to delete one Sub_category
     *   }
     * })
     * 
    **/
    delete<T extends sub_categoryDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, sub_categoryDeleteArgs<ExtArgs>>
    ): Prisma__sub_categoryClient<$Result.GetResult<Prisma.$sub_categoryPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Sub_category.
     * @param {sub_categoryUpdateArgs} args - Arguments to update one Sub_category.
     * @example
     * // Update one Sub_category
     * const sub_category = await prisma.sub_category.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends sub_categoryUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, sub_categoryUpdateArgs<ExtArgs>>
    ): Prisma__sub_categoryClient<$Result.GetResult<Prisma.$sub_categoryPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Sub_categories.
     * @param {sub_categoryDeleteManyArgs} args - Arguments to filter Sub_categories to delete.
     * @example
     * // Delete a few Sub_categories
     * const { count } = await prisma.sub_category.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends sub_categoryDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, sub_categoryDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sub_categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sub_categoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sub_categories
     * const sub_category = await prisma.sub_category.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends sub_categoryUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, sub_categoryUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Sub_category.
     * @param {sub_categoryUpsertArgs} args - Arguments to update or create a Sub_category.
     * @example
     * // Update or create a Sub_category
     * const sub_category = await prisma.sub_category.upsert({
     *   create: {
     *     // ... data to create a Sub_category
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sub_category we want to update
     *   }
     * })
    **/
    upsert<T extends sub_categoryUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, sub_categoryUpsertArgs<ExtArgs>>
    ): Prisma__sub_categoryClient<$Result.GetResult<Prisma.$sub_categoryPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Sub_categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sub_categoryCountArgs} args - Arguments to filter Sub_categories to count.
     * @example
     * // Count the number of Sub_categories
     * const count = await prisma.sub_category.count({
     *   where: {
     *     // ... the filter for the Sub_categories we want to count
     *   }
     * })
    **/
    count<T extends sub_categoryCountArgs>(
      args?: Subset<T, sub_categoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Sub_categoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sub_category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Sub_categoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Sub_categoryAggregateArgs>(args: Subset<T, Sub_categoryAggregateArgs>): Prisma.PrismaPromise<GetSub_categoryAggregateType<T>>

    /**
     * Group by Sub_category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sub_categoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends sub_categoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: sub_categoryGroupByArgs['orderBy'] }
        : { orderBy?: sub_categoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, sub_categoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSub_categoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the sub_category model
   */
  readonly fields: sub_categoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for sub_category.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__sub_categoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    category<T extends categoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, categoryDefaultArgs<ExtArgs>>): Prisma__categoryClient<$Result.GetResult<Prisma.$categoryPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the sub_category model
   */ 
  interface sub_categoryFieldRefs {
    readonly id: FieldRef<"sub_category", 'Int'>
    readonly categoryId: FieldRef<"sub_category", 'Int'>
    readonly name: FieldRef<"sub_category", 'String'>
    readonly detail: FieldRef<"sub_category", 'String'>
    readonly imagePath: FieldRef<"sub_category", 'String'>
    readonly imageSrc: FieldRef<"sub_category", 'String'>
    readonly isActive: FieldRef<"sub_category", 'Boolean'>
    readonly createdAt: FieldRef<"sub_category", 'DateTime'>
    readonly updatedAt: FieldRef<"sub_category", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * sub_category findUnique
   */
  export type sub_categoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sub_category
     */
    select?: sub_categorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sub_categoryInclude<ExtArgs> | null
    /**
     * Filter, which sub_category to fetch.
     */
    where: sub_categoryWhereUniqueInput
  }


  /**
   * sub_category findUniqueOrThrow
   */
  export type sub_categoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sub_category
     */
    select?: sub_categorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sub_categoryInclude<ExtArgs> | null
    /**
     * Filter, which sub_category to fetch.
     */
    where: sub_categoryWhereUniqueInput
  }


  /**
   * sub_category findFirst
   */
  export type sub_categoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sub_category
     */
    select?: sub_categorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sub_categoryInclude<ExtArgs> | null
    /**
     * Filter, which sub_category to fetch.
     */
    where?: sub_categoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sub_categories to fetch.
     */
    orderBy?: sub_categoryOrderByWithRelationInput | sub_categoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sub_categories.
     */
    cursor?: sub_categoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sub_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sub_categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sub_categories.
     */
    distinct?: Sub_categoryScalarFieldEnum | Sub_categoryScalarFieldEnum[]
  }


  /**
   * sub_category findFirstOrThrow
   */
  export type sub_categoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sub_category
     */
    select?: sub_categorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sub_categoryInclude<ExtArgs> | null
    /**
     * Filter, which sub_category to fetch.
     */
    where?: sub_categoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sub_categories to fetch.
     */
    orderBy?: sub_categoryOrderByWithRelationInput | sub_categoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sub_categories.
     */
    cursor?: sub_categoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sub_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sub_categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sub_categories.
     */
    distinct?: Sub_categoryScalarFieldEnum | Sub_categoryScalarFieldEnum[]
  }


  /**
   * sub_category findMany
   */
  export type sub_categoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sub_category
     */
    select?: sub_categorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sub_categoryInclude<ExtArgs> | null
    /**
     * Filter, which sub_categories to fetch.
     */
    where?: sub_categoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sub_categories to fetch.
     */
    orderBy?: sub_categoryOrderByWithRelationInput | sub_categoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing sub_categories.
     */
    cursor?: sub_categoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sub_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sub_categories.
     */
    skip?: number
    distinct?: Sub_categoryScalarFieldEnum | Sub_categoryScalarFieldEnum[]
  }


  /**
   * sub_category create
   */
  export type sub_categoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sub_category
     */
    select?: sub_categorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sub_categoryInclude<ExtArgs> | null
    /**
     * The data needed to create a sub_category.
     */
    data: XOR<sub_categoryCreateInput, sub_categoryUncheckedCreateInput>
  }


  /**
   * sub_category createMany
   */
  export type sub_categoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many sub_categories.
     */
    data: sub_categoryCreateManyInput | sub_categoryCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * sub_category update
   */
  export type sub_categoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sub_category
     */
    select?: sub_categorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sub_categoryInclude<ExtArgs> | null
    /**
     * The data needed to update a sub_category.
     */
    data: XOR<sub_categoryUpdateInput, sub_categoryUncheckedUpdateInput>
    /**
     * Choose, which sub_category to update.
     */
    where: sub_categoryWhereUniqueInput
  }


  /**
   * sub_category updateMany
   */
  export type sub_categoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update sub_categories.
     */
    data: XOR<sub_categoryUpdateManyMutationInput, sub_categoryUncheckedUpdateManyInput>
    /**
     * Filter which sub_categories to update
     */
    where?: sub_categoryWhereInput
  }


  /**
   * sub_category upsert
   */
  export type sub_categoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sub_category
     */
    select?: sub_categorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sub_categoryInclude<ExtArgs> | null
    /**
     * The filter to search for the sub_category to update in case it exists.
     */
    where: sub_categoryWhereUniqueInput
    /**
     * In case the sub_category found by the `where` argument doesn't exist, create a new sub_category with this data.
     */
    create: XOR<sub_categoryCreateInput, sub_categoryUncheckedCreateInput>
    /**
     * In case the sub_category was found with the provided `where` argument, update it with this data.
     */
    update: XOR<sub_categoryUpdateInput, sub_categoryUncheckedUpdateInput>
  }


  /**
   * sub_category delete
   */
  export type sub_categoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sub_category
     */
    select?: sub_categorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sub_categoryInclude<ExtArgs> | null
    /**
     * Filter which sub_category to delete.
     */
    where: sub_categoryWhereUniqueInput
  }


  /**
   * sub_category deleteMany
   */
  export type sub_categoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which sub_categories to delete
     */
    where?: sub_categoryWhereInput
  }


  /**
   * sub_category without action
   */
  export type sub_categoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sub_category
     */
    select?: sub_categorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sub_categoryInclude<ExtArgs> | null
  }



  /**
   * Model product_review
   */

  export type AggregateProduct_review = {
    _count: Product_reviewCountAggregateOutputType | null
    _avg: Product_reviewAvgAggregateOutputType | null
    _sum: Product_reviewSumAggregateOutputType | null
    _min: Product_reviewMinAggregateOutputType | null
    _max: Product_reviewMaxAggregateOutputType | null
  }

  export type Product_reviewAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    productId: number | null
    adminId: number | null
    rating: number | null
  }

  export type Product_reviewSumAggregateOutputType = {
    id: number | null
    userId: number | null
    productId: number | null
    adminId: number | null
    rating: number | null
  }

  export type Product_reviewMinAggregateOutputType = {
    id: number | null
    userId: number | null
    productId: number | null
    adminId: number | null
    detail: string | null
    rating: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Product_reviewMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    productId: number | null
    adminId: number | null
    detail: string | null
    rating: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Product_reviewCountAggregateOutputType = {
    id: number
    userId: number
    productId: number
    adminId: number
    detail: number
    rating: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Product_reviewAvgAggregateInputType = {
    id?: true
    userId?: true
    productId?: true
    adminId?: true
    rating?: true
  }

  export type Product_reviewSumAggregateInputType = {
    id?: true
    userId?: true
    productId?: true
    adminId?: true
    rating?: true
  }

  export type Product_reviewMinAggregateInputType = {
    id?: true
    userId?: true
    productId?: true
    adminId?: true
    detail?: true
    rating?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Product_reviewMaxAggregateInputType = {
    id?: true
    userId?: true
    productId?: true
    adminId?: true
    detail?: true
    rating?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Product_reviewCountAggregateInputType = {
    id?: true
    userId?: true
    productId?: true
    adminId?: true
    detail?: true
    rating?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Product_reviewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which product_review to aggregate.
     */
    where?: product_reviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of product_reviews to fetch.
     */
    orderBy?: product_reviewOrderByWithRelationInput | product_reviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: product_reviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` product_reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` product_reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned product_reviews
    **/
    _count?: true | Product_reviewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Product_reviewAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Product_reviewSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Product_reviewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Product_reviewMaxAggregateInputType
  }

  export type GetProduct_reviewAggregateType<T extends Product_reviewAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct_review]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct_review[P]>
      : GetScalarType<T[P], AggregateProduct_review[P]>
  }




  export type product_reviewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: product_reviewWhereInput
    orderBy?: product_reviewOrderByWithAggregationInput | product_reviewOrderByWithAggregationInput[]
    by: Product_reviewScalarFieldEnum[] | Product_reviewScalarFieldEnum
    having?: product_reviewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Product_reviewCountAggregateInputType | true
    _avg?: Product_reviewAvgAggregateInputType
    _sum?: Product_reviewSumAggregateInputType
    _min?: Product_reviewMinAggregateInputType
    _max?: Product_reviewMaxAggregateInputType
  }

  export type Product_reviewGroupByOutputType = {
    id: number
    userId: number
    productId: number
    adminId: number
    detail: string | null
    rating: number
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: Product_reviewCountAggregateOutputType | null
    _avg: Product_reviewAvgAggregateOutputType | null
    _sum: Product_reviewSumAggregateOutputType | null
    _min: Product_reviewMinAggregateOutputType | null
    _max: Product_reviewMaxAggregateOutputType | null
  }

  type GetProduct_reviewGroupByPayload<T extends product_reviewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Product_reviewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Product_reviewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Product_reviewGroupByOutputType[P]>
            : GetScalarType<T[P], Product_reviewGroupByOutputType[P]>
        }
      >
    >


  export type product_reviewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    productId?: boolean
    adminId?: boolean
    detail?: boolean
    rating?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
    product?: boolean | productDefaultArgs<ExtArgs>
    admin?: boolean | adminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product_review"]>

  export type product_reviewSelectScalar = {
    id?: boolean
    userId?: boolean
    productId?: boolean
    adminId?: boolean
    detail?: boolean
    rating?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type product_reviewInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
    product?: boolean | productDefaultArgs<ExtArgs>
    admin?: boolean | adminDefaultArgs<ExtArgs>
  }


  export type $product_reviewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "product_review"
    objects: {
      user: Prisma.$userPayload<ExtArgs>
      product: Prisma.$productPayload<ExtArgs>
      admin: Prisma.$adminPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      productId: number
      adminId: number
      detail: string | null
      rating: number
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["product_review"]>
    composites: {}
  }


  type product_reviewGetPayload<S extends boolean | null | undefined | product_reviewDefaultArgs> = $Result.GetResult<Prisma.$product_reviewPayload, S>

  type product_reviewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<product_reviewFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Product_reviewCountAggregateInputType | true
    }

  export interface product_reviewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['product_review'], meta: { name: 'product_review' } }
    /**
     * Find zero or one Product_review that matches the filter.
     * @param {product_reviewFindUniqueArgs} args - Arguments to find a Product_review
     * @example
     * // Get one Product_review
     * const product_review = await prisma.product_review.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends product_reviewFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, product_reviewFindUniqueArgs<ExtArgs>>
    ): Prisma__product_reviewClient<$Result.GetResult<Prisma.$product_reviewPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Product_review that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {product_reviewFindUniqueOrThrowArgs} args - Arguments to find a Product_review
     * @example
     * // Get one Product_review
     * const product_review = await prisma.product_review.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends product_reviewFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, product_reviewFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__product_reviewClient<$Result.GetResult<Prisma.$product_reviewPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Product_review that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {product_reviewFindFirstArgs} args - Arguments to find a Product_review
     * @example
     * // Get one Product_review
     * const product_review = await prisma.product_review.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends product_reviewFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, product_reviewFindFirstArgs<ExtArgs>>
    ): Prisma__product_reviewClient<$Result.GetResult<Prisma.$product_reviewPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Product_review that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {product_reviewFindFirstOrThrowArgs} args - Arguments to find a Product_review
     * @example
     * // Get one Product_review
     * const product_review = await prisma.product_review.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends product_reviewFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, product_reviewFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__product_reviewClient<$Result.GetResult<Prisma.$product_reviewPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Product_reviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {product_reviewFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Product_reviews
     * const product_reviews = await prisma.product_review.findMany()
     * 
     * // Get first 10 Product_reviews
     * const product_reviews = await prisma.product_review.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const product_reviewWithIdOnly = await prisma.product_review.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends product_reviewFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, product_reviewFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$product_reviewPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Product_review.
     * @param {product_reviewCreateArgs} args - Arguments to create a Product_review.
     * @example
     * // Create one Product_review
     * const Product_review = await prisma.product_review.create({
     *   data: {
     *     // ... data to create a Product_review
     *   }
     * })
     * 
    **/
    create<T extends product_reviewCreateArgs<ExtArgs>>(
      args: SelectSubset<T, product_reviewCreateArgs<ExtArgs>>
    ): Prisma__product_reviewClient<$Result.GetResult<Prisma.$product_reviewPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Product_reviews.
     *     @param {product_reviewCreateManyArgs} args - Arguments to create many Product_reviews.
     *     @example
     *     // Create many Product_reviews
     *     const product_review = await prisma.product_review.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends product_reviewCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, product_reviewCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Product_review.
     * @param {product_reviewDeleteArgs} args - Arguments to delete one Product_review.
     * @example
     * // Delete one Product_review
     * const Product_review = await prisma.product_review.delete({
     *   where: {
     *     // ... filter to delete one Product_review
     *   }
     * })
     * 
    **/
    delete<T extends product_reviewDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, product_reviewDeleteArgs<ExtArgs>>
    ): Prisma__product_reviewClient<$Result.GetResult<Prisma.$product_reviewPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Product_review.
     * @param {product_reviewUpdateArgs} args - Arguments to update one Product_review.
     * @example
     * // Update one Product_review
     * const product_review = await prisma.product_review.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends product_reviewUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, product_reviewUpdateArgs<ExtArgs>>
    ): Prisma__product_reviewClient<$Result.GetResult<Prisma.$product_reviewPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Product_reviews.
     * @param {product_reviewDeleteManyArgs} args - Arguments to filter Product_reviews to delete.
     * @example
     * // Delete a few Product_reviews
     * const { count } = await prisma.product_review.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends product_reviewDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, product_reviewDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Product_reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {product_reviewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Product_reviews
     * const product_review = await prisma.product_review.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends product_reviewUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, product_reviewUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Product_review.
     * @param {product_reviewUpsertArgs} args - Arguments to update or create a Product_review.
     * @example
     * // Update or create a Product_review
     * const product_review = await prisma.product_review.upsert({
     *   create: {
     *     // ... data to create a Product_review
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product_review we want to update
     *   }
     * })
    **/
    upsert<T extends product_reviewUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, product_reviewUpsertArgs<ExtArgs>>
    ): Prisma__product_reviewClient<$Result.GetResult<Prisma.$product_reviewPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Product_reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {product_reviewCountArgs} args - Arguments to filter Product_reviews to count.
     * @example
     * // Count the number of Product_reviews
     * const count = await prisma.product_review.count({
     *   where: {
     *     // ... the filter for the Product_reviews we want to count
     *   }
     * })
    **/
    count<T extends product_reviewCountArgs>(
      args?: Subset<T, product_reviewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Product_reviewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product_review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Product_reviewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Product_reviewAggregateArgs>(args: Subset<T, Product_reviewAggregateArgs>): Prisma.PrismaPromise<GetProduct_reviewAggregateType<T>>

    /**
     * Group by Product_review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {product_reviewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends product_reviewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: product_reviewGroupByArgs['orderBy'] }
        : { orderBy?: product_reviewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, product_reviewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProduct_reviewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the product_review model
   */
  readonly fields: product_reviewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for product_review.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__product_reviewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    product<T extends productDefaultArgs<ExtArgs> = {}>(args?: Subset<T, productDefaultArgs<ExtArgs>>): Prisma__productClient<$Result.GetResult<Prisma.$productPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    admin<T extends adminDefaultArgs<ExtArgs> = {}>(args?: Subset<T, adminDefaultArgs<ExtArgs>>): Prisma__adminClient<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the product_review model
   */ 
  interface product_reviewFieldRefs {
    readonly id: FieldRef<"product_review", 'Int'>
    readonly userId: FieldRef<"product_review", 'Int'>
    readonly productId: FieldRef<"product_review", 'Int'>
    readonly adminId: FieldRef<"product_review", 'Int'>
    readonly detail: FieldRef<"product_review", 'String'>
    readonly rating: FieldRef<"product_review", 'Int'>
    readonly isActive: FieldRef<"product_review", 'Boolean'>
    readonly createdAt: FieldRef<"product_review", 'DateTime'>
    readonly updatedAt: FieldRef<"product_review", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * product_review findUnique
   */
  export type product_reviewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_review
     */
    select?: product_reviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: product_reviewInclude<ExtArgs> | null
    /**
     * Filter, which product_review to fetch.
     */
    where: product_reviewWhereUniqueInput
  }


  /**
   * product_review findUniqueOrThrow
   */
  export type product_reviewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_review
     */
    select?: product_reviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: product_reviewInclude<ExtArgs> | null
    /**
     * Filter, which product_review to fetch.
     */
    where: product_reviewWhereUniqueInput
  }


  /**
   * product_review findFirst
   */
  export type product_reviewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_review
     */
    select?: product_reviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: product_reviewInclude<ExtArgs> | null
    /**
     * Filter, which product_review to fetch.
     */
    where?: product_reviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of product_reviews to fetch.
     */
    orderBy?: product_reviewOrderByWithRelationInput | product_reviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for product_reviews.
     */
    cursor?: product_reviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` product_reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` product_reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of product_reviews.
     */
    distinct?: Product_reviewScalarFieldEnum | Product_reviewScalarFieldEnum[]
  }


  /**
   * product_review findFirstOrThrow
   */
  export type product_reviewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_review
     */
    select?: product_reviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: product_reviewInclude<ExtArgs> | null
    /**
     * Filter, which product_review to fetch.
     */
    where?: product_reviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of product_reviews to fetch.
     */
    orderBy?: product_reviewOrderByWithRelationInput | product_reviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for product_reviews.
     */
    cursor?: product_reviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` product_reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` product_reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of product_reviews.
     */
    distinct?: Product_reviewScalarFieldEnum | Product_reviewScalarFieldEnum[]
  }


  /**
   * product_review findMany
   */
  export type product_reviewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_review
     */
    select?: product_reviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: product_reviewInclude<ExtArgs> | null
    /**
     * Filter, which product_reviews to fetch.
     */
    where?: product_reviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of product_reviews to fetch.
     */
    orderBy?: product_reviewOrderByWithRelationInput | product_reviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing product_reviews.
     */
    cursor?: product_reviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` product_reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` product_reviews.
     */
    skip?: number
    distinct?: Product_reviewScalarFieldEnum | Product_reviewScalarFieldEnum[]
  }


  /**
   * product_review create
   */
  export type product_reviewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_review
     */
    select?: product_reviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: product_reviewInclude<ExtArgs> | null
    /**
     * The data needed to create a product_review.
     */
    data: XOR<product_reviewCreateInput, product_reviewUncheckedCreateInput>
  }


  /**
   * product_review createMany
   */
  export type product_reviewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many product_reviews.
     */
    data: product_reviewCreateManyInput | product_reviewCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * product_review update
   */
  export type product_reviewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_review
     */
    select?: product_reviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: product_reviewInclude<ExtArgs> | null
    /**
     * The data needed to update a product_review.
     */
    data: XOR<product_reviewUpdateInput, product_reviewUncheckedUpdateInput>
    /**
     * Choose, which product_review to update.
     */
    where: product_reviewWhereUniqueInput
  }


  /**
   * product_review updateMany
   */
  export type product_reviewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update product_reviews.
     */
    data: XOR<product_reviewUpdateManyMutationInput, product_reviewUncheckedUpdateManyInput>
    /**
     * Filter which product_reviews to update
     */
    where?: product_reviewWhereInput
  }


  /**
   * product_review upsert
   */
  export type product_reviewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_review
     */
    select?: product_reviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: product_reviewInclude<ExtArgs> | null
    /**
     * The filter to search for the product_review to update in case it exists.
     */
    where: product_reviewWhereUniqueInput
    /**
     * In case the product_review found by the `where` argument doesn't exist, create a new product_review with this data.
     */
    create: XOR<product_reviewCreateInput, product_reviewUncheckedCreateInput>
    /**
     * In case the product_review was found with the provided `where` argument, update it with this data.
     */
    update: XOR<product_reviewUpdateInput, product_reviewUncheckedUpdateInput>
  }


  /**
   * product_review delete
   */
  export type product_reviewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_review
     */
    select?: product_reviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: product_reviewInclude<ExtArgs> | null
    /**
     * Filter which product_review to delete.
     */
    where: product_reviewWhereUniqueInput
  }


  /**
   * product_review deleteMany
   */
  export type product_reviewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which product_reviews to delete
     */
    where?: product_reviewWhereInput
  }


  /**
   * product_review without action
   */
  export type product_reviewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_review
     */
    select?: product_reviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: product_reviewInclude<ExtArgs> | null
  }



  /**
   * Model review_image
   */

  export type AggregateReview_image = {
    _count: Review_imageCountAggregateOutputType | null
    _avg: Review_imageAvgAggregateOutputType | null
    _sum: Review_imageSumAggregateOutputType | null
    _min: Review_imageMinAggregateOutputType | null
    _max: Review_imageMaxAggregateOutputType | null
  }

  export type Review_imageAvgAggregateOutputType = {
    id: number | null
  }

  export type Review_imageSumAggregateOutputType = {
    id: number | null
  }

  export type Review_imageMinAggregateOutputType = {
    id: number | null
    imagePath: string | null
    imageSrc: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Review_imageMaxAggregateOutputType = {
    id: number | null
    imagePath: string | null
    imageSrc: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Review_imageCountAggregateOutputType = {
    id: number
    imagePath: number
    imageSrc: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Review_imageAvgAggregateInputType = {
    id?: true
  }

  export type Review_imageSumAggregateInputType = {
    id?: true
  }

  export type Review_imageMinAggregateInputType = {
    id?: true
    imagePath?: true
    imageSrc?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Review_imageMaxAggregateInputType = {
    id?: true
    imagePath?: true
    imageSrc?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Review_imageCountAggregateInputType = {
    id?: true
    imagePath?: true
    imageSrc?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Review_imageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which review_image to aggregate.
     */
    where?: review_imageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of review_images to fetch.
     */
    orderBy?: review_imageOrderByWithRelationInput | review_imageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: review_imageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` review_images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` review_images.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned review_images
    **/
    _count?: true | Review_imageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Review_imageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Review_imageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Review_imageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Review_imageMaxAggregateInputType
  }

  export type GetReview_imageAggregateType<T extends Review_imageAggregateArgs> = {
        [P in keyof T & keyof AggregateReview_image]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReview_image[P]>
      : GetScalarType<T[P], AggregateReview_image[P]>
  }




  export type review_imageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: review_imageWhereInput
    orderBy?: review_imageOrderByWithAggregationInput | review_imageOrderByWithAggregationInput[]
    by: Review_imageScalarFieldEnum[] | Review_imageScalarFieldEnum
    having?: review_imageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Review_imageCountAggregateInputType | true
    _avg?: Review_imageAvgAggregateInputType
    _sum?: Review_imageSumAggregateInputType
    _min?: Review_imageMinAggregateInputType
    _max?: Review_imageMaxAggregateInputType
  }

  export type Review_imageGroupByOutputType = {
    id: number
    imagePath: string | null
    imageSrc: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: Review_imageCountAggregateOutputType | null
    _avg: Review_imageAvgAggregateOutputType | null
    _sum: Review_imageSumAggregateOutputType | null
    _min: Review_imageMinAggregateOutputType | null
    _max: Review_imageMaxAggregateOutputType | null
  }

  type GetReview_imageGroupByPayload<T extends review_imageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Review_imageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Review_imageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Review_imageGroupByOutputType[P]>
            : GetScalarType<T[P], Review_imageGroupByOutputType[P]>
        }
      >
    >


  export type review_imageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    imagePath?: boolean
    imageSrc?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["review_image"]>

  export type review_imageSelectScalar = {
    id?: boolean
    imagePath?: boolean
    imageSrc?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $review_imagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "review_image"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      imagePath: string | null
      imageSrc: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["review_image"]>
    composites: {}
  }


  type review_imageGetPayload<S extends boolean | null | undefined | review_imageDefaultArgs> = $Result.GetResult<Prisma.$review_imagePayload, S>

  type review_imageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<review_imageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Review_imageCountAggregateInputType | true
    }

  export interface review_imageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['review_image'], meta: { name: 'review_image' } }
    /**
     * Find zero or one Review_image that matches the filter.
     * @param {review_imageFindUniqueArgs} args - Arguments to find a Review_image
     * @example
     * // Get one Review_image
     * const review_image = await prisma.review_image.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends review_imageFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, review_imageFindUniqueArgs<ExtArgs>>
    ): Prisma__review_imageClient<$Result.GetResult<Prisma.$review_imagePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Review_image that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {review_imageFindUniqueOrThrowArgs} args - Arguments to find a Review_image
     * @example
     * // Get one Review_image
     * const review_image = await prisma.review_image.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends review_imageFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, review_imageFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__review_imageClient<$Result.GetResult<Prisma.$review_imagePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Review_image that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {review_imageFindFirstArgs} args - Arguments to find a Review_image
     * @example
     * // Get one Review_image
     * const review_image = await prisma.review_image.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends review_imageFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, review_imageFindFirstArgs<ExtArgs>>
    ): Prisma__review_imageClient<$Result.GetResult<Prisma.$review_imagePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Review_image that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {review_imageFindFirstOrThrowArgs} args - Arguments to find a Review_image
     * @example
     * // Get one Review_image
     * const review_image = await prisma.review_image.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends review_imageFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, review_imageFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__review_imageClient<$Result.GetResult<Prisma.$review_imagePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Review_images that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {review_imageFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Review_images
     * const review_images = await prisma.review_image.findMany()
     * 
     * // Get first 10 Review_images
     * const review_images = await prisma.review_image.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const review_imageWithIdOnly = await prisma.review_image.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends review_imageFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, review_imageFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$review_imagePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Review_image.
     * @param {review_imageCreateArgs} args - Arguments to create a Review_image.
     * @example
     * // Create one Review_image
     * const Review_image = await prisma.review_image.create({
     *   data: {
     *     // ... data to create a Review_image
     *   }
     * })
     * 
    **/
    create<T extends review_imageCreateArgs<ExtArgs>>(
      args: SelectSubset<T, review_imageCreateArgs<ExtArgs>>
    ): Prisma__review_imageClient<$Result.GetResult<Prisma.$review_imagePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Review_images.
     *     @param {review_imageCreateManyArgs} args - Arguments to create many Review_images.
     *     @example
     *     // Create many Review_images
     *     const review_image = await prisma.review_image.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends review_imageCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, review_imageCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Review_image.
     * @param {review_imageDeleteArgs} args - Arguments to delete one Review_image.
     * @example
     * // Delete one Review_image
     * const Review_image = await prisma.review_image.delete({
     *   where: {
     *     // ... filter to delete one Review_image
     *   }
     * })
     * 
    **/
    delete<T extends review_imageDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, review_imageDeleteArgs<ExtArgs>>
    ): Prisma__review_imageClient<$Result.GetResult<Prisma.$review_imagePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Review_image.
     * @param {review_imageUpdateArgs} args - Arguments to update one Review_image.
     * @example
     * // Update one Review_image
     * const review_image = await prisma.review_image.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends review_imageUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, review_imageUpdateArgs<ExtArgs>>
    ): Prisma__review_imageClient<$Result.GetResult<Prisma.$review_imagePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Review_images.
     * @param {review_imageDeleteManyArgs} args - Arguments to filter Review_images to delete.
     * @example
     * // Delete a few Review_images
     * const { count } = await prisma.review_image.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends review_imageDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, review_imageDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Review_images.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {review_imageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Review_images
     * const review_image = await prisma.review_image.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends review_imageUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, review_imageUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Review_image.
     * @param {review_imageUpsertArgs} args - Arguments to update or create a Review_image.
     * @example
     * // Update or create a Review_image
     * const review_image = await prisma.review_image.upsert({
     *   create: {
     *     // ... data to create a Review_image
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Review_image we want to update
     *   }
     * })
    **/
    upsert<T extends review_imageUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, review_imageUpsertArgs<ExtArgs>>
    ): Prisma__review_imageClient<$Result.GetResult<Prisma.$review_imagePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Review_images.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {review_imageCountArgs} args - Arguments to filter Review_images to count.
     * @example
     * // Count the number of Review_images
     * const count = await prisma.review_image.count({
     *   where: {
     *     // ... the filter for the Review_images we want to count
     *   }
     * })
    **/
    count<T extends review_imageCountArgs>(
      args?: Subset<T, review_imageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Review_imageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Review_image.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Review_imageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Review_imageAggregateArgs>(args: Subset<T, Review_imageAggregateArgs>): Prisma.PrismaPromise<GetReview_imageAggregateType<T>>

    /**
     * Group by Review_image.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {review_imageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends review_imageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: review_imageGroupByArgs['orderBy'] }
        : { orderBy?: review_imageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, review_imageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReview_imageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the review_image model
   */
  readonly fields: review_imageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for review_image.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__review_imageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the review_image model
   */ 
  interface review_imageFieldRefs {
    readonly id: FieldRef<"review_image", 'Int'>
    readonly imagePath: FieldRef<"review_image", 'String'>
    readonly imageSrc: FieldRef<"review_image", 'String'>
    readonly isActive: FieldRef<"review_image", 'Boolean'>
    readonly createdAt: FieldRef<"review_image", 'DateTime'>
    readonly updatedAt: FieldRef<"review_image", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * review_image findUnique
   */
  export type review_imageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the review_image
     */
    select?: review_imageSelect<ExtArgs> | null
    /**
     * Filter, which review_image to fetch.
     */
    where: review_imageWhereUniqueInput
  }


  /**
   * review_image findUniqueOrThrow
   */
  export type review_imageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the review_image
     */
    select?: review_imageSelect<ExtArgs> | null
    /**
     * Filter, which review_image to fetch.
     */
    where: review_imageWhereUniqueInput
  }


  /**
   * review_image findFirst
   */
  export type review_imageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the review_image
     */
    select?: review_imageSelect<ExtArgs> | null
    /**
     * Filter, which review_image to fetch.
     */
    where?: review_imageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of review_images to fetch.
     */
    orderBy?: review_imageOrderByWithRelationInput | review_imageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for review_images.
     */
    cursor?: review_imageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` review_images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` review_images.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of review_images.
     */
    distinct?: Review_imageScalarFieldEnum | Review_imageScalarFieldEnum[]
  }


  /**
   * review_image findFirstOrThrow
   */
  export type review_imageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the review_image
     */
    select?: review_imageSelect<ExtArgs> | null
    /**
     * Filter, which review_image to fetch.
     */
    where?: review_imageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of review_images to fetch.
     */
    orderBy?: review_imageOrderByWithRelationInput | review_imageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for review_images.
     */
    cursor?: review_imageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` review_images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` review_images.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of review_images.
     */
    distinct?: Review_imageScalarFieldEnum | Review_imageScalarFieldEnum[]
  }


  /**
   * review_image findMany
   */
  export type review_imageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the review_image
     */
    select?: review_imageSelect<ExtArgs> | null
    /**
     * Filter, which review_images to fetch.
     */
    where?: review_imageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of review_images to fetch.
     */
    orderBy?: review_imageOrderByWithRelationInput | review_imageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing review_images.
     */
    cursor?: review_imageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` review_images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` review_images.
     */
    skip?: number
    distinct?: Review_imageScalarFieldEnum | Review_imageScalarFieldEnum[]
  }


  /**
   * review_image create
   */
  export type review_imageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the review_image
     */
    select?: review_imageSelect<ExtArgs> | null
    /**
     * The data needed to create a review_image.
     */
    data: XOR<review_imageCreateInput, review_imageUncheckedCreateInput>
  }


  /**
   * review_image createMany
   */
  export type review_imageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many review_images.
     */
    data: review_imageCreateManyInput | review_imageCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * review_image update
   */
  export type review_imageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the review_image
     */
    select?: review_imageSelect<ExtArgs> | null
    /**
     * The data needed to update a review_image.
     */
    data: XOR<review_imageUpdateInput, review_imageUncheckedUpdateInput>
    /**
     * Choose, which review_image to update.
     */
    where: review_imageWhereUniqueInput
  }


  /**
   * review_image updateMany
   */
  export type review_imageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update review_images.
     */
    data: XOR<review_imageUpdateManyMutationInput, review_imageUncheckedUpdateManyInput>
    /**
     * Filter which review_images to update
     */
    where?: review_imageWhereInput
  }


  /**
   * review_image upsert
   */
  export type review_imageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the review_image
     */
    select?: review_imageSelect<ExtArgs> | null
    /**
     * The filter to search for the review_image to update in case it exists.
     */
    where: review_imageWhereUniqueInput
    /**
     * In case the review_image found by the `where` argument doesn't exist, create a new review_image with this data.
     */
    create: XOR<review_imageCreateInput, review_imageUncheckedCreateInput>
    /**
     * In case the review_image was found with the provided `where` argument, update it with this data.
     */
    update: XOR<review_imageUpdateInput, review_imageUncheckedUpdateInput>
  }


  /**
   * review_image delete
   */
  export type review_imageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the review_image
     */
    select?: review_imageSelect<ExtArgs> | null
    /**
     * Filter which review_image to delete.
     */
    where: review_imageWhereUniqueInput
  }


  /**
   * review_image deleteMany
   */
  export type review_imageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which review_images to delete
     */
    where?: review_imageWhereInput
  }


  /**
   * review_image without action
   */
  export type review_imageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the review_image
     */
    select?: review_imageSelect<ExtArgs> | null
  }



  /**
   * Model product
   */

  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  export type ProductAvgAggregateOutputType = {
    id: number | null
    brandId: number | null
    adminId: number | null
    discountPercent: number | null
    minPrice: number | null
    maxPrice: number | null
    rating: number | null
    sold: number | null
  }

  export type ProductSumAggregateOutputType = {
    id: number | null
    brandId: number | null
    adminId: number | null
    discountPercent: number | null
    minPrice: number | null
    maxPrice: number | null
    rating: number | null
    sold: number | null
  }

  export type ProductMinAggregateOutputType = {
    id: number | null
    brandId: number | null
    adminId: number | null
    name: string | null
    shortName: string | null
    detail: string | null
    isDiscount: boolean | null
    discountPercent: number | null
    minPrice: number | null
    maxPrice: number | null
    slug: string | null
    cardImgPath: string | null
    cardImgSrc: string | null
    optionFirst: string | null
    optionSecond: string | null
    isWholesale: boolean | null
    rating: number | null
    sold: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductMaxAggregateOutputType = {
    id: number | null
    brandId: number | null
    adminId: number | null
    name: string | null
    shortName: string | null
    detail: string | null
    isDiscount: boolean | null
    discountPercent: number | null
    minPrice: number | null
    maxPrice: number | null
    slug: string | null
    cardImgPath: string | null
    cardImgSrc: string | null
    optionFirst: string | null
    optionSecond: string | null
    isWholesale: boolean | null
    rating: number | null
    sold: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductCountAggregateOutputType = {
    id: number
    brandId: number
    adminId: number
    name: number
    shortName: number
    detail: number
    isDiscount: number
    discountPercent: number
    minPrice: number
    maxPrice: number
    slug: number
    cardImgPath: number
    cardImgSrc: number
    optionFirst: number
    optionSecond: number
    isWholesale: number
    rating: number
    sold: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductAvgAggregateInputType = {
    id?: true
    brandId?: true
    adminId?: true
    discountPercent?: true
    minPrice?: true
    maxPrice?: true
    rating?: true
    sold?: true
  }

  export type ProductSumAggregateInputType = {
    id?: true
    brandId?: true
    adminId?: true
    discountPercent?: true
    minPrice?: true
    maxPrice?: true
    rating?: true
    sold?: true
  }

  export type ProductMinAggregateInputType = {
    id?: true
    brandId?: true
    adminId?: true
    name?: true
    shortName?: true
    detail?: true
    isDiscount?: true
    discountPercent?: true
    minPrice?: true
    maxPrice?: true
    slug?: true
    cardImgPath?: true
    cardImgSrc?: true
    optionFirst?: true
    optionSecond?: true
    isWholesale?: true
    rating?: true
    sold?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductMaxAggregateInputType = {
    id?: true
    brandId?: true
    adminId?: true
    name?: true
    shortName?: true
    detail?: true
    isDiscount?: true
    discountPercent?: true
    minPrice?: true
    maxPrice?: true
    slug?: true
    cardImgPath?: true
    cardImgSrc?: true
    optionFirst?: true
    optionSecond?: true
    isWholesale?: true
    rating?: true
    sold?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductCountAggregateInputType = {
    id?: true
    brandId?: true
    adminId?: true
    name?: true
    shortName?: true
    detail?: true
    isDiscount?: true
    discountPercent?: true
    minPrice?: true
    maxPrice?: true
    slug?: true
    cardImgPath?: true
    cardImgSrc?: true
    optionFirst?: true
    optionSecond?: true
    isWholesale?: true
    rating?: true
    sold?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which product to aggregate.
     */
    where?: productWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of products to fetch.
     */
    orderBy?: productOrderByWithRelationInput | productOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: productWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned products
    **/
    _count?: true | ProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMaxAggregateInputType
  }

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>
  }




  export type productGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: productWhereInput
    orderBy?: productOrderByWithAggregationInput | productOrderByWithAggregationInput[]
    by: ProductScalarFieldEnum[] | ProductScalarFieldEnum
    having?: productScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCountAggregateInputType | true
    _avg?: ProductAvgAggregateInputType
    _sum?: ProductSumAggregateInputType
    _min?: ProductMinAggregateInputType
    _max?: ProductMaxAggregateInputType
  }

  export type ProductGroupByOutputType = {
    id: number
    brandId: number
    adminId: number
    name: string
    shortName: string | null
    detail: string | null
    isDiscount: boolean
    discountPercent: number
    minPrice: number
    maxPrice: number
    slug: string
    cardImgPath: string
    cardImgSrc: string
    optionFirst: string | null
    optionSecond: string | null
    isWholesale: boolean
    rating: number
    sold: number
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  type GetProductGroupByPayload<T extends productGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGroupByOutputType[P]>
        }
      >
    >


  export type productSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    brandId?: boolean
    adminId?: boolean
    name?: boolean
    shortName?: boolean
    detail?: boolean
    isDiscount?: boolean
    discountPercent?: boolean
    minPrice?: boolean
    maxPrice?: boolean
    slug?: boolean
    cardImgPath?: boolean
    cardImgSrc?: boolean
    optionFirst?: boolean
    optionSecond?: boolean
    isWholesale?: boolean
    rating?: boolean
    sold?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    brand?: boolean | brandDefaultArgs<ExtArgs>
    admin?: boolean | adminDefaultArgs<ExtArgs>
    product_image?: boolean | product$product_imageArgs<ExtArgs>
    product_spec?: boolean | product$product_specArgs<ExtArgs>
    product_detail?: boolean | product$product_detailArgs<ExtArgs>
    product_option_first?: boolean | product$product_option_firstArgs<ExtArgs>
    product_option_second?: boolean | product$product_option_secondArgs<ExtArgs>
    product_price?: boolean | product$product_priceArgs<ExtArgs>
    product_wholesale?: boolean | product$product_wholesaleArgs<ExtArgs>
    product_review?: boolean | product$product_reviewArgs<ExtArgs>
    product_tag?: boolean | product$product_tagArgs<ExtArgs>
    cart?: boolean | product$cartArgs<ExtArgs>
    order_product?: boolean | product$order_productArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type productSelectScalar = {
    id?: boolean
    brandId?: boolean
    adminId?: boolean
    name?: boolean
    shortName?: boolean
    detail?: boolean
    isDiscount?: boolean
    discountPercent?: boolean
    minPrice?: boolean
    maxPrice?: boolean
    slug?: boolean
    cardImgPath?: boolean
    cardImgSrc?: boolean
    optionFirst?: boolean
    optionSecond?: boolean
    isWholesale?: boolean
    rating?: boolean
    sold?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type productInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    brand?: boolean | brandDefaultArgs<ExtArgs>
    admin?: boolean | adminDefaultArgs<ExtArgs>
    product_image?: boolean | product$product_imageArgs<ExtArgs>
    product_spec?: boolean | product$product_specArgs<ExtArgs>
    product_detail?: boolean | product$product_detailArgs<ExtArgs>
    product_option_first?: boolean | product$product_option_firstArgs<ExtArgs>
    product_option_second?: boolean | product$product_option_secondArgs<ExtArgs>
    product_price?: boolean | product$product_priceArgs<ExtArgs>
    product_wholesale?: boolean | product$product_wholesaleArgs<ExtArgs>
    product_review?: boolean | product$product_reviewArgs<ExtArgs>
    product_tag?: boolean | product$product_tagArgs<ExtArgs>
    cart?: boolean | product$cartArgs<ExtArgs>
    order_product?: boolean | product$order_productArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $productPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "product"
    objects: {
      brand: Prisma.$brandPayload<ExtArgs>
      admin: Prisma.$adminPayload<ExtArgs>
      product_image: Prisma.$product_imagePayload<ExtArgs>[]
      product_spec: Prisma.$product_specPayload<ExtArgs>[]
      product_detail: Prisma.$product_detailPayload<ExtArgs>[]
      product_option_first: Prisma.$product_option_firstPayload<ExtArgs>[]
      product_option_second: Prisma.$product_option_secondPayload<ExtArgs>[]
      product_price: Prisma.$product_pricePayload<ExtArgs>[]
      product_wholesale: Prisma.$product_wholesalePayload<ExtArgs>[]
      product_review: Prisma.$product_reviewPayload<ExtArgs>[]
      product_tag: Prisma.$product_tagPayload<ExtArgs>[]
      cart: Prisma.$cartPayload<ExtArgs>[]
      order_product: Prisma.$order_productPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      brandId: number
      adminId: number
      name: string
      shortName: string | null
      detail: string | null
      isDiscount: boolean
      discountPercent: number
      minPrice: number
      maxPrice: number
      slug: string
      cardImgPath: string
      cardImgSrc: string
      optionFirst: string | null
      optionSecond: string | null
      isWholesale: boolean
      rating: number
      sold: number
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["product"]>
    composites: {}
  }


  type productGetPayload<S extends boolean | null | undefined | productDefaultArgs> = $Result.GetResult<Prisma.$productPayload, S>

  type productCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<productFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProductCountAggregateInputType | true
    }

  export interface productDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['product'], meta: { name: 'product' } }
    /**
     * Find zero or one Product that matches the filter.
     * @param {productFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends productFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, productFindUniqueArgs<ExtArgs>>
    ): Prisma__productClient<$Result.GetResult<Prisma.$productPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Product that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {productFindUniqueOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends productFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, productFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__productClient<$Result.GetResult<Prisma.$productPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends productFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, productFindFirstArgs<ExtArgs>>
    ): Prisma__productClient<$Result.GetResult<Prisma.$productPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Product that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productFindFirstOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends productFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, productFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__productClient<$Result.GetResult<Prisma.$productPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productWithIdOnly = await prisma.product.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends productFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, productFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$productPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Product.
     * @param {productCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     * 
    **/
    create<T extends productCreateArgs<ExtArgs>>(
      args: SelectSubset<T, productCreateArgs<ExtArgs>>
    ): Prisma__productClient<$Result.GetResult<Prisma.$productPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Products.
     *     @param {productCreateManyArgs} args - Arguments to create many Products.
     *     @example
     *     // Create many Products
     *     const product = await prisma.product.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends productCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, productCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Product.
     * @param {productDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     * 
    **/
    delete<T extends productDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, productDeleteArgs<ExtArgs>>
    ): Prisma__productClient<$Result.GetResult<Prisma.$productPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Product.
     * @param {productUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends productUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, productUpdateArgs<ExtArgs>>
    ): Prisma__productClient<$Result.GetResult<Prisma.$productPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Products.
     * @param {productDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends productDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, productDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends productUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, productUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Product.
     * @param {productUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
    **/
    upsert<T extends productUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, productUpsertArgs<ExtArgs>>
    ): Prisma__productClient<$Result.GetResult<Prisma.$productPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends productCountArgs>(
      args?: Subset<T, productCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAggregateArgs>(args: Subset<T, ProductAggregateArgs>): Prisma.PrismaPromise<GetProductAggregateType<T>>

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends productGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: productGroupByArgs['orderBy'] }
        : { orderBy?: productGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, productGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the product model
   */
  readonly fields: productFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__productClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    brand<T extends brandDefaultArgs<ExtArgs> = {}>(args?: Subset<T, brandDefaultArgs<ExtArgs>>): Prisma__brandClient<$Result.GetResult<Prisma.$brandPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    admin<T extends adminDefaultArgs<ExtArgs> = {}>(args?: Subset<T, adminDefaultArgs<ExtArgs>>): Prisma__adminClient<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    product_image<T extends product$product_imageArgs<ExtArgs> = {}>(args?: Subset<T, product$product_imageArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$product_imagePayload<ExtArgs>, T, 'findMany'> | Null>;

    product_spec<T extends product$product_specArgs<ExtArgs> = {}>(args?: Subset<T, product$product_specArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$product_specPayload<ExtArgs>, T, 'findMany'> | Null>;

    product_detail<T extends product$product_detailArgs<ExtArgs> = {}>(args?: Subset<T, product$product_detailArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$product_detailPayload<ExtArgs>, T, 'findMany'> | Null>;

    product_option_first<T extends product$product_option_firstArgs<ExtArgs> = {}>(args?: Subset<T, product$product_option_firstArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$product_option_firstPayload<ExtArgs>, T, 'findMany'> | Null>;

    product_option_second<T extends product$product_option_secondArgs<ExtArgs> = {}>(args?: Subset<T, product$product_option_secondArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$product_option_secondPayload<ExtArgs>, T, 'findMany'> | Null>;

    product_price<T extends product$product_priceArgs<ExtArgs> = {}>(args?: Subset<T, product$product_priceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$product_pricePayload<ExtArgs>, T, 'findMany'> | Null>;

    product_wholesale<T extends product$product_wholesaleArgs<ExtArgs> = {}>(args?: Subset<T, product$product_wholesaleArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$product_wholesalePayload<ExtArgs>, T, 'findMany'> | Null>;

    product_review<T extends product$product_reviewArgs<ExtArgs> = {}>(args?: Subset<T, product$product_reviewArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$product_reviewPayload<ExtArgs>, T, 'findMany'> | Null>;

    product_tag<T extends product$product_tagArgs<ExtArgs> = {}>(args?: Subset<T, product$product_tagArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$product_tagPayload<ExtArgs>, T, 'findMany'> | Null>;

    cart<T extends product$cartArgs<ExtArgs> = {}>(args?: Subset<T, product$cartArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$cartPayload<ExtArgs>, T, 'findMany'> | Null>;

    order_product<T extends product$order_productArgs<ExtArgs> = {}>(args?: Subset<T, product$order_productArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$order_productPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the product model
   */ 
  interface productFieldRefs {
    readonly id: FieldRef<"product", 'Int'>
    readonly brandId: FieldRef<"product", 'Int'>
    readonly adminId: FieldRef<"product", 'Int'>
    readonly name: FieldRef<"product", 'String'>
    readonly shortName: FieldRef<"product", 'String'>
    readonly detail: FieldRef<"product", 'String'>
    readonly isDiscount: FieldRef<"product", 'Boolean'>
    readonly discountPercent: FieldRef<"product", 'Int'>
    readonly minPrice: FieldRef<"product", 'Float'>
    readonly maxPrice: FieldRef<"product", 'Float'>
    readonly slug: FieldRef<"product", 'String'>
    readonly cardImgPath: FieldRef<"product", 'String'>
    readonly cardImgSrc: FieldRef<"product", 'String'>
    readonly optionFirst: FieldRef<"product", 'String'>
    readonly optionSecond: FieldRef<"product", 'String'>
    readonly isWholesale: FieldRef<"product", 'Boolean'>
    readonly rating: FieldRef<"product", 'Int'>
    readonly sold: FieldRef<"product", 'Int'>
    readonly isActive: FieldRef<"product", 'Boolean'>
    readonly createdAt: FieldRef<"product", 'DateTime'>
    readonly updatedAt: FieldRef<"product", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * product findUnique
   */
  export type productFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: productInclude<ExtArgs> | null
    /**
     * Filter, which product to fetch.
     */
    where: productWhereUniqueInput
  }


  /**
   * product findUniqueOrThrow
   */
  export type productFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: productInclude<ExtArgs> | null
    /**
     * Filter, which product to fetch.
     */
    where: productWhereUniqueInput
  }


  /**
   * product findFirst
   */
  export type productFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: productInclude<ExtArgs> | null
    /**
     * Filter, which product to fetch.
     */
    where?: productWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of products to fetch.
     */
    orderBy?: productOrderByWithRelationInput | productOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for products.
     */
    cursor?: productWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }


  /**
   * product findFirstOrThrow
   */
  export type productFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: productInclude<ExtArgs> | null
    /**
     * Filter, which product to fetch.
     */
    where?: productWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of products to fetch.
     */
    orderBy?: productOrderByWithRelationInput | productOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for products.
     */
    cursor?: productWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }


  /**
   * product findMany
   */
  export type productFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: productInclude<ExtArgs> | null
    /**
     * Filter, which products to fetch.
     */
    where?: productWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of products to fetch.
     */
    orderBy?: productOrderByWithRelationInput | productOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing products.
     */
    cursor?: productWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` products.
     */
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }


  /**
   * product create
   */
  export type productCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: productInclude<ExtArgs> | null
    /**
     * The data needed to create a product.
     */
    data: XOR<productCreateInput, productUncheckedCreateInput>
  }


  /**
   * product createMany
   */
  export type productCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many products.
     */
    data: productCreateManyInput | productCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * product update
   */
  export type productUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: productInclude<ExtArgs> | null
    /**
     * The data needed to update a product.
     */
    data: XOR<productUpdateInput, productUncheckedUpdateInput>
    /**
     * Choose, which product to update.
     */
    where: productWhereUniqueInput
  }


  /**
   * product updateMany
   */
  export type productUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update products.
     */
    data: XOR<productUpdateManyMutationInput, productUncheckedUpdateManyInput>
    /**
     * Filter which products to update
     */
    where?: productWhereInput
  }


  /**
   * product upsert
   */
  export type productUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: productInclude<ExtArgs> | null
    /**
     * The filter to search for the product to update in case it exists.
     */
    where: productWhereUniqueInput
    /**
     * In case the product found by the `where` argument doesn't exist, create a new product with this data.
     */
    create: XOR<productCreateInput, productUncheckedCreateInput>
    /**
     * In case the product was found with the provided `where` argument, update it with this data.
     */
    update: XOR<productUpdateInput, productUncheckedUpdateInput>
  }


  /**
   * product delete
   */
  export type productDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: productInclude<ExtArgs> | null
    /**
     * Filter which product to delete.
     */
    where: productWhereUniqueInput
  }


  /**
   * product deleteMany
   */
  export type productDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which products to delete
     */
    where?: productWhereInput
  }


  /**
   * product.product_image
   */
  export type product$product_imageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_image
     */
    select?: product_imageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: product_imageInclude<ExtArgs> | null
    where?: product_imageWhereInput
    orderBy?: product_imageOrderByWithRelationInput | product_imageOrderByWithRelationInput[]
    cursor?: product_imageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Product_imageScalarFieldEnum | Product_imageScalarFieldEnum[]
  }


  /**
   * product.product_spec
   */
  export type product$product_specArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_spec
     */
    select?: product_specSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: product_specInclude<ExtArgs> | null
    where?: product_specWhereInput
    orderBy?: product_specOrderByWithRelationInput | product_specOrderByWithRelationInput[]
    cursor?: product_specWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Product_specScalarFieldEnum | Product_specScalarFieldEnum[]
  }


  /**
   * product.product_detail
   */
  export type product$product_detailArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_detail
     */
    select?: product_detailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: product_detailInclude<ExtArgs> | null
    where?: product_detailWhereInput
    orderBy?: product_detailOrderByWithRelationInput | product_detailOrderByWithRelationInput[]
    cursor?: product_detailWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Product_detailScalarFieldEnum | Product_detailScalarFieldEnum[]
  }


  /**
   * product.product_option_first
   */
  export type product$product_option_firstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_option_first
     */
    select?: product_option_firstSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: product_option_firstInclude<ExtArgs> | null
    where?: product_option_firstWhereInput
    orderBy?: product_option_firstOrderByWithRelationInput | product_option_firstOrderByWithRelationInput[]
    cursor?: product_option_firstWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Product_option_firstScalarFieldEnum | Product_option_firstScalarFieldEnum[]
  }


  /**
   * product.product_option_second
   */
  export type product$product_option_secondArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_option_second
     */
    select?: product_option_secondSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: product_option_secondInclude<ExtArgs> | null
    where?: product_option_secondWhereInput
    orderBy?: product_option_secondOrderByWithRelationInput | product_option_secondOrderByWithRelationInput[]
    cursor?: product_option_secondWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Product_option_secondScalarFieldEnum | Product_option_secondScalarFieldEnum[]
  }


  /**
   * product.product_price
   */
  export type product$product_priceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_price
     */
    select?: product_priceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: product_priceInclude<ExtArgs> | null
    where?: product_priceWhereInput
    orderBy?: product_priceOrderByWithRelationInput | product_priceOrderByWithRelationInput[]
    cursor?: product_priceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Product_priceScalarFieldEnum | Product_priceScalarFieldEnum[]
  }


  /**
   * product.product_wholesale
   */
  export type product$product_wholesaleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_wholesale
     */
    select?: product_wholesaleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: product_wholesaleInclude<ExtArgs> | null
    where?: product_wholesaleWhereInput
    orderBy?: product_wholesaleOrderByWithRelationInput | product_wholesaleOrderByWithRelationInput[]
    cursor?: product_wholesaleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Product_wholesaleScalarFieldEnum | Product_wholesaleScalarFieldEnum[]
  }


  /**
   * product.product_review
   */
  export type product$product_reviewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_review
     */
    select?: product_reviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: product_reviewInclude<ExtArgs> | null
    where?: product_reviewWhereInput
    orderBy?: product_reviewOrderByWithRelationInput | product_reviewOrderByWithRelationInput[]
    cursor?: product_reviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Product_reviewScalarFieldEnum | Product_reviewScalarFieldEnum[]
  }


  /**
   * product.product_tag
   */
  export type product$product_tagArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_tag
     */
    select?: product_tagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: product_tagInclude<ExtArgs> | null
    where?: product_tagWhereInput
    orderBy?: product_tagOrderByWithRelationInput | product_tagOrderByWithRelationInput[]
    cursor?: product_tagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Product_tagScalarFieldEnum | Product_tagScalarFieldEnum[]
  }


  /**
   * product.cart
   */
  export type product$cartArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cart
     */
    select?: cartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: cartInclude<ExtArgs> | null
    where?: cartWhereInput
    orderBy?: cartOrderByWithRelationInput | cartOrderByWithRelationInput[]
    cursor?: cartWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CartScalarFieldEnum | CartScalarFieldEnum[]
  }


  /**
   * product.order_product
   */
  export type product$order_productArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_product
     */
    select?: order_productSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: order_productInclude<ExtArgs> | null
    where?: order_productWhereInput
    orderBy?: order_productOrderByWithRelationInput | order_productOrderByWithRelationInput[]
    cursor?: order_productWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Order_productScalarFieldEnum | Order_productScalarFieldEnum[]
  }


  /**
   * product without action
   */
  export type productDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: productInclude<ExtArgs> | null
  }



  /**
   * Model product_tag
   */

  export type AggregateProduct_tag = {
    _count: Product_tagCountAggregateOutputType | null
    _avg: Product_tagAvgAggregateOutputType | null
    _sum: Product_tagSumAggregateOutputType | null
    _min: Product_tagMinAggregateOutputType | null
    _max: Product_tagMaxAggregateOutputType | null
  }

  export type Product_tagAvgAggregateOutputType = {
    id: number | null
    productId: number | null
    tagId: number | null
  }

  export type Product_tagSumAggregateOutputType = {
    id: number | null
    productId: number | null
    tagId: number | null
  }

  export type Product_tagMinAggregateOutputType = {
    id: number | null
    productId: number | null
    tagId: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Product_tagMaxAggregateOutputType = {
    id: number | null
    productId: number | null
    tagId: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Product_tagCountAggregateOutputType = {
    id: number
    productId: number
    tagId: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Product_tagAvgAggregateInputType = {
    id?: true
    productId?: true
    tagId?: true
  }

  export type Product_tagSumAggregateInputType = {
    id?: true
    productId?: true
    tagId?: true
  }

  export type Product_tagMinAggregateInputType = {
    id?: true
    productId?: true
    tagId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Product_tagMaxAggregateInputType = {
    id?: true
    productId?: true
    tagId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Product_tagCountAggregateInputType = {
    id?: true
    productId?: true
    tagId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Product_tagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which product_tag to aggregate.
     */
    where?: product_tagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of product_tags to fetch.
     */
    orderBy?: product_tagOrderByWithRelationInput | product_tagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: product_tagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` product_tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` product_tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned product_tags
    **/
    _count?: true | Product_tagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Product_tagAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Product_tagSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Product_tagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Product_tagMaxAggregateInputType
  }

  export type GetProduct_tagAggregateType<T extends Product_tagAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct_tag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct_tag[P]>
      : GetScalarType<T[P], AggregateProduct_tag[P]>
  }




  export type product_tagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: product_tagWhereInput
    orderBy?: product_tagOrderByWithAggregationInput | product_tagOrderByWithAggregationInput[]
    by: Product_tagScalarFieldEnum[] | Product_tagScalarFieldEnum
    having?: product_tagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Product_tagCountAggregateInputType | true
    _avg?: Product_tagAvgAggregateInputType
    _sum?: Product_tagSumAggregateInputType
    _min?: Product_tagMinAggregateInputType
    _max?: Product_tagMaxAggregateInputType
  }

  export type Product_tagGroupByOutputType = {
    id: number
    productId: number
    tagId: number
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: Product_tagCountAggregateOutputType | null
    _avg: Product_tagAvgAggregateOutputType | null
    _sum: Product_tagSumAggregateOutputType | null
    _min: Product_tagMinAggregateOutputType | null
    _max: Product_tagMaxAggregateOutputType | null
  }

  type GetProduct_tagGroupByPayload<T extends product_tagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Product_tagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Product_tagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Product_tagGroupByOutputType[P]>
            : GetScalarType<T[P], Product_tagGroupByOutputType[P]>
        }
      >
    >


  export type product_tagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    tagId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | productDefaultArgs<ExtArgs>
    tag?: boolean | tagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product_tag"]>

  export type product_tagSelectScalar = {
    id?: boolean
    productId?: boolean
    tagId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type product_tagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | productDefaultArgs<ExtArgs>
    tag?: boolean | tagDefaultArgs<ExtArgs>
  }


  export type $product_tagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "product_tag"
    objects: {
      product: Prisma.$productPayload<ExtArgs>
      tag: Prisma.$tagPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      productId: number
      tagId: number
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["product_tag"]>
    composites: {}
  }


  type product_tagGetPayload<S extends boolean | null | undefined | product_tagDefaultArgs> = $Result.GetResult<Prisma.$product_tagPayload, S>

  type product_tagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<product_tagFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Product_tagCountAggregateInputType | true
    }

  export interface product_tagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['product_tag'], meta: { name: 'product_tag' } }
    /**
     * Find zero or one Product_tag that matches the filter.
     * @param {product_tagFindUniqueArgs} args - Arguments to find a Product_tag
     * @example
     * // Get one Product_tag
     * const product_tag = await prisma.product_tag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends product_tagFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, product_tagFindUniqueArgs<ExtArgs>>
    ): Prisma__product_tagClient<$Result.GetResult<Prisma.$product_tagPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Product_tag that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {product_tagFindUniqueOrThrowArgs} args - Arguments to find a Product_tag
     * @example
     * // Get one Product_tag
     * const product_tag = await prisma.product_tag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends product_tagFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, product_tagFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__product_tagClient<$Result.GetResult<Prisma.$product_tagPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Product_tag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {product_tagFindFirstArgs} args - Arguments to find a Product_tag
     * @example
     * // Get one Product_tag
     * const product_tag = await prisma.product_tag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends product_tagFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, product_tagFindFirstArgs<ExtArgs>>
    ): Prisma__product_tagClient<$Result.GetResult<Prisma.$product_tagPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Product_tag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {product_tagFindFirstOrThrowArgs} args - Arguments to find a Product_tag
     * @example
     * // Get one Product_tag
     * const product_tag = await prisma.product_tag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends product_tagFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, product_tagFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__product_tagClient<$Result.GetResult<Prisma.$product_tagPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Product_tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {product_tagFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Product_tags
     * const product_tags = await prisma.product_tag.findMany()
     * 
     * // Get first 10 Product_tags
     * const product_tags = await prisma.product_tag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const product_tagWithIdOnly = await prisma.product_tag.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends product_tagFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, product_tagFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$product_tagPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Product_tag.
     * @param {product_tagCreateArgs} args - Arguments to create a Product_tag.
     * @example
     * // Create one Product_tag
     * const Product_tag = await prisma.product_tag.create({
     *   data: {
     *     // ... data to create a Product_tag
     *   }
     * })
     * 
    **/
    create<T extends product_tagCreateArgs<ExtArgs>>(
      args: SelectSubset<T, product_tagCreateArgs<ExtArgs>>
    ): Prisma__product_tagClient<$Result.GetResult<Prisma.$product_tagPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Product_tags.
     *     @param {product_tagCreateManyArgs} args - Arguments to create many Product_tags.
     *     @example
     *     // Create many Product_tags
     *     const product_tag = await prisma.product_tag.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends product_tagCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, product_tagCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Product_tag.
     * @param {product_tagDeleteArgs} args - Arguments to delete one Product_tag.
     * @example
     * // Delete one Product_tag
     * const Product_tag = await prisma.product_tag.delete({
     *   where: {
     *     // ... filter to delete one Product_tag
     *   }
     * })
     * 
    **/
    delete<T extends product_tagDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, product_tagDeleteArgs<ExtArgs>>
    ): Prisma__product_tagClient<$Result.GetResult<Prisma.$product_tagPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Product_tag.
     * @param {product_tagUpdateArgs} args - Arguments to update one Product_tag.
     * @example
     * // Update one Product_tag
     * const product_tag = await prisma.product_tag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends product_tagUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, product_tagUpdateArgs<ExtArgs>>
    ): Prisma__product_tagClient<$Result.GetResult<Prisma.$product_tagPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Product_tags.
     * @param {product_tagDeleteManyArgs} args - Arguments to filter Product_tags to delete.
     * @example
     * // Delete a few Product_tags
     * const { count } = await prisma.product_tag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends product_tagDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, product_tagDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Product_tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {product_tagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Product_tags
     * const product_tag = await prisma.product_tag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends product_tagUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, product_tagUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Product_tag.
     * @param {product_tagUpsertArgs} args - Arguments to update or create a Product_tag.
     * @example
     * // Update or create a Product_tag
     * const product_tag = await prisma.product_tag.upsert({
     *   create: {
     *     // ... data to create a Product_tag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product_tag we want to update
     *   }
     * })
    **/
    upsert<T extends product_tagUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, product_tagUpsertArgs<ExtArgs>>
    ): Prisma__product_tagClient<$Result.GetResult<Prisma.$product_tagPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Product_tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {product_tagCountArgs} args - Arguments to filter Product_tags to count.
     * @example
     * // Count the number of Product_tags
     * const count = await prisma.product_tag.count({
     *   where: {
     *     // ... the filter for the Product_tags we want to count
     *   }
     * })
    **/
    count<T extends product_tagCountArgs>(
      args?: Subset<T, product_tagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Product_tagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product_tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Product_tagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Product_tagAggregateArgs>(args: Subset<T, Product_tagAggregateArgs>): Prisma.PrismaPromise<GetProduct_tagAggregateType<T>>

    /**
     * Group by Product_tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {product_tagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends product_tagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: product_tagGroupByArgs['orderBy'] }
        : { orderBy?: product_tagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, product_tagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProduct_tagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the product_tag model
   */
  readonly fields: product_tagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for product_tag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__product_tagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    product<T extends productDefaultArgs<ExtArgs> = {}>(args?: Subset<T, productDefaultArgs<ExtArgs>>): Prisma__productClient<$Result.GetResult<Prisma.$productPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    tag<T extends tagDefaultArgs<ExtArgs> = {}>(args?: Subset<T, tagDefaultArgs<ExtArgs>>): Prisma__tagClient<$Result.GetResult<Prisma.$tagPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the product_tag model
   */ 
  interface product_tagFieldRefs {
    readonly id: FieldRef<"product_tag", 'Int'>
    readonly productId: FieldRef<"product_tag", 'Int'>
    readonly tagId: FieldRef<"product_tag", 'Int'>
    readonly isActive: FieldRef<"product_tag", 'Boolean'>
    readonly createdAt: FieldRef<"product_tag", 'DateTime'>
    readonly updatedAt: FieldRef<"product_tag", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * product_tag findUnique
   */
  export type product_tagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_tag
     */
    select?: product_tagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: product_tagInclude<ExtArgs> | null
    /**
     * Filter, which product_tag to fetch.
     */
    where: product_tagWhereUniqueInput
  }


  /**
   * product_tag findUniqueOrThrow
   */
  export type product_tagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_tag
     */
    select?: product_tagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: product_tagInclude<ExtArgs> | null
    /**
     * Filter, which product_tag to fetch.
     */
    where: product_tagWhereUniqueInput
  }


  /**
   * product_tag findFirst
   */
  export type product_tagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_tag
     */
    select?: product_tagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: product_tagInclude<ExtArgs> | null
    /**
     * Filter, which product_tag to fetch.
     */
    where?: product_tagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of product_tags to fetch.
     */
    orderBy?: product_tagOrderByWithRelationInput | product_tagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for product_tags.
     */
    cursor?: product_tagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` product_tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` product_tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of product_tags.
     */
    distinct?: Product_tagScalarFieldEnum | Product_tagScalarFieldEnum[]
  }


  /**
   * product_tag findFirstOrThrow
   */
  export type product_tagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_tag
     */
    select?: product_tagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: product_tagInclude<ExtArgs> | null
    /**
     * Filter, which product_tag to fetch.
     */
    where?: product_tagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of product_tags to fetch.
     */
    orderBy?: product_tagOrderByWithRelationInput | product_tagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for product_tags.
     */
    cursor?: product_tagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` product_tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` product_tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of product_tags.
     */
    distinct?: Product_tagScalarFieldEnum | Product_tagScalarFieldEnum[]
  }


  /**
   * product_tag findMany
   */
  export type product_tagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_tag
     */
    select?: product_tagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: product_tagInclude<ExtArgs> | null
    /**
     * Filter, which product_tags to fetch.
     */
    where?: product_tagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of product_tags to fetch.
     */
    orderBy?: product_tagOrderByWithRelationInput | product_tagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing product_tags.
     */
    cursor?: product_tagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` product_tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` product_tags.
     */
    skip?: number
    distinct?: Product_tagScalarFieldEnum | Product_tagScalarFieldEnum[]
  }


  /**
   * product_tag create
   */
  export type product_tagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_tag
     */
    select?: product_tagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: product_tagInclude<ExtArgs> | null
    /**
     * The data needed to create a product_tag.
     */
    data: XOR<product_tagCreateInput, product_tagUncheckedCreateInput>
  }


  /**
   * product_tag createMany
   */
  export type product_tagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many product_tags.
     */
    data: product_tagCreateManyInput | product_tagCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * product_tag update
   */
  export type product_tagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_tag
     */
    select?: product_tagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: product_tagInclude<ExtArgs> | null
    /**
     * The data needed to update a product_tag.
     */
    data: XOR<product_tagUpdateInput, product_tagUncheckedUpdateInput>
    /**
     * Choose, which product_tag to update.
     */
    where: product_tagWhereUniqueInput
  }


  /**
   * product_tag updateMany
   */
  export type product_tagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update product_tags.
     */
    data: XOR<product_tagUpdateManyMutationInput, product_tagUncheckedUpdateManyInput>
    /**
     * Filter which product_tags to update
     */
    where?: product_tagWhereInput
  }


  /**
   * product_tag upsert
   */
  export type product_tagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_tag
     */
    select?: product_tagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: product_tagInclude<ExtArgs> | null
    /**
     * The filter to search for the product_tag to update in case it exists.
     */
    where: product_tagWhereUniqueInput
    /**
     * In case the product_tag found by the `where` argument doesn't exist, create a new product_tag with this data.
     */
    create: XOR<product_tagCreateInput, product_tagUncheckedCreateInput>
    /**
     * In case the product_tag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<product_tagUpdateInput, product_tagUncheckedUpdateInput>
  }


  /**
   * product_tag delete
   */
  export type product_tagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_tag
     */
    select?: product_tagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: product_tagInclude<ExtArgs> | null
    /**
     * Filter which product_tag to delete.
     */
    where: product_tagWhereUniqueInput
  }


  /**
   * product_tag deleteMany
   */
  export type product_tagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which product_tags to delete
     */
    where?: product_tagWhereInput
  }


  /**
   * product_tag without action
   */
  export type product_tagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_tag
     */
    select?: product_tagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: product_tagInclude<ExtArgs> | null
  }



  /**
   * Model product_wholesale
   */

  export type AggregateProduct_wholesale = {
    _count: Product_wholesaleCountAggregateOutputType | null
    _avg: Product_wholesaleAvgAggregateOutputType | null
    _sum: Product_wholesaleSumAggregateOutputType | null
    _min: Product_wholesaleMinAggregateOutputType | null
    _max: Product_wholesaleMaxAggregateOutputType | null
  }

  export type Product_wholesaleAvgAggregateOutputType = {
    id: number | null
    productId: number | null
    min: number | null
    price: number | null
  }

  export type Product_wholesaleSumAggregateOutputType = {
    id: number | null
    productId: number | null
    min: number | null
    price: number | null
  }

  export type Product_wholesaleMinAggregateOutputType = {
    id: number | null
    productId: number | null
    min: number | null
    price: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Product_wholesaleMaxAggregateOutputType = {
    id: number | null
    productId: number | null
    min: number | null
    price: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Product_wholesaleCountAggregateOutputType = {
    id: number
    productId: number
    min: number
    price: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Product_wholesaleAvgAggregateInputType = {
    id?: true
    productId?: true
    min?: true
    price?: true
  }

  export type Product_wholesaleSumAggregateInputType = {
    id?: true
    productId?: true
    min?: true
    price?: true
  }

  export type Product_wholesaleMinAggregateInputType = {
    id?: true
    productId?: true
    min?: true
    price?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Product_wholesaleMaxAggregateInputType = {
    id?: true
    productId?: true
    min?: true
    price?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Product_wholesaleCountAggregateInputType = {
    id?: true
    productId?: true
    min?: true
    price?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Product_wholesaleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which product_wholesale to aggregate.
     */
    where?: product_wholesaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of product_wholesales to fetch.
     */
    orderBy?: product_wholesaleOrderByWithRelationInput | product_wholesaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: product_wholesaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` product_wholesales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` product_wholesales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned product_wholesales
    **/
    _count?: true | Product_wholesaleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Product_wholesaleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Product_wholesaleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Product_wholesaleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Product_wholesaleMaxAggregateInputType
  }

  export type GetProduct_wholesaleAggregateType<T extends Product_wholesaleAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct_wholesale]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct_wholesale[P]>
      : GetScalarType<T[P], AggregateProduct_wholesale[P]>
  }




  export type product_wholesaleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: product_wholesaleWhereInput
    orderBy?: product_wholesaleOrderByWithAggregationInput | product_wholesaleOrderByWithAggregationInput[]
    by: Product_wholesaleScalarFieldEnum[] | Product_wholesaleScalarFieldEnum
    having?: product_wholesaleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Product_wholesaleCountAggregateInputType | true
    _avg?: Product_wholesaleAvgAggregateInputType
    _sum?: Product_wholesaleSumAggregateInputType
    _min?: Product_wholesaleMinAggregateInputType
    _max?: Product_wholesaleMaxAggregateInputType
  }

  export type Product_wholesaleGroupByOutputType = {
    id: number
    productId: number
    min: number
    price: number
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: Product_wholesaleCountAggregateOutputType | null
    _avg: Product_wholesaleAvgAggregateOutputType | null
    _sum: Product_wholesaleSumAggregateOutputType | null
    _min: Product_wholesaleMinAggregateOutputType | null
    _max: Product_wholesaleMaxAggregateOutputType | null
  }

  type GetProduct_wholesaleGroupByPayload<T extends product_wholesaleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Product_wholesaleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Product_wholesaleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Product_wholesaleGroupByOutputType[P]>
            : GetScalarType<T[P], Product_wholesaleGroupByOutputType[P]>
        }
      >
    >


  export type product_wholesaleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    min?: boolean
    price?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | productDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product_wholesale"]>

  export type product_wholesaleSelectScalar = {
    id?: boolean
    productId?: boolean
    min?: boolean
    price?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type product_wholesaleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | productDefaultArgs<ExtArgs>
  }


  export type $product_wholesalePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "product_wholesale"
    objects: {
      product: Prisma.$productPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      productId: number
      min: number
      price: number
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["product_wholesale"]>
    composites: {}
  }


  type product_wholesaleGetPayload<S extends boolean | null | undefined | product_wholesaleDefaultArgs> = $Result.GetResult<Prisma.$product_wholesalePayload, S>

  type product_wholesaleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<product_wholesaleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Product_wholesaleCountAggregateInputType | true
    }

  export interface product_wholesaleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['product_wholesale'], meta: { name: 'product_wholesale' } }
    /**
     * Find zero or one Product_wholesale that matches the filter.
     * @param {product_wholesaleFindUniqueArgs} args - Arguments to find a Product_wholesale
     * @example
     * // Get one Product_wholesale
     * const product_wholesale = await prisma.product_wholesale.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends product_wholesaleFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, product_wholesaleFindUniqueArgs<ExtArgs>>
    ): Prisma__product_wholesaleClient<$Result.GetResult<Prisma.$product_wholesalePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Product_wholesale that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {product_wholesaleFindUniqueOrThrowArgs} args - Arguments to find a Product_wholesale
     * @example
     * // Get one Product_wholesale
     * const product_wholesale = await prisma.product_wholesale.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends product_wholesaleFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, product_wholesaleFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__product_wholesaleClient<$Result.GetResult<Prisma.$product_wholesalePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Product_wholesale that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {product_wholesaleFindFirstArgs} args - Arguments to find a Product_wholesale
     * @example
     * // Get one Product_wholesale
     * const product_wholesale = await prisma.product_wholesale.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends product_wholesaleFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, product_wholesaleFindFirstArgs<ExtArgs>>
    ): Prisma__product_wholesaleClient<$Result.GetResult<Prisma.$product_wholesalePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Product_wholesale that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {product_wholesaleFindFirstOrThrowArgs} args - Arguments to find a Product_wholesale
     * @example
     * // Get one Product_wholesale
     * const product_wholesale = await prisma.product_wholesale.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends product_wholesaleFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, product_wholesaleFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__product_wholesaleClient<$Result.GetResult<Prisma.$product_wholesalePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Product_wholesales that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {product_wholesaleFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Product_wholesales
     * const product_wholesales = await prisma.product_wholesale.findMany()
     * 
     * // Get first 10 Product_wholesales
     * const product_wholesales = await prisma.product_wholesale.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const product_wholesaleWithIdOnly = await prisma.product_wholesale.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends product_wholesaleFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, product_wholesaleFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$product_wholesalePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Product_wholesale.
     * @param {product_wholesaleCreateArgs} args - Arguments to create a Product_wholesale.
     * @example
     * // Create one Product_wholesale
     * const Product_wholesale = await prisma.product_wholesale.create({
     *   data: {
     *     // ... data to create a Product_wholesale
     *   }
     * })
     * 
    **/
    create<T extends product_wholesaleCreateArgs<ExtArgs>>(
      args: SelectSubset<T, product_wholesaleCreateArgs<ExtArgs>>
    ): Prisma__product_wholesaleClient<$Result.GetResult<Prisma.$product_wholesalePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Product_wholesales.
     *     @param {product_wholesaleCreateManyArgs} args - Arguments to create many Product_wholesales.
     *     @example
     *     // Create many Product_wholesales
     *     const product_wholesale = await prisma.product_wholesale.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends product_wholesaleCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, product_wholesaleCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Product_wholesale.
     * @param {product_wholesaleDeleteArgs} args - Arguments to delete one Product_wholesale.
     * @example
     * // Delete one Product_wholesale
     * const Product_wholesale = await prisma.product_wholesale.delete({
     *   where: {
     *     // ... filter to delete one Product_wholesale
     *   }
     * })
     * 
    **/
    delete<T extends product_wholesaleDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, product_wholesaleDeleteArgs<ExtArgs>>
    ): Prisma__product_wholesaleClient<$Result.GetResult<Prisma.$product_wholesalePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Product_wholesale.
     * @param {product_wholesaleUpdateArgs} args - Arguments to update one Product_wholesale.
     * @example
     * // Update one Product_wholesale
     * const product_wholesale = await prisma.product_wholesale.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends product_wholesaleUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, product_wholesaleUpdateArgs<ExtArgs>>
    ): Prisma__product_wholesaleClient<$Result.GetResult<Prisma.$product_wholesalePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Product_wholesales.
     * @param {product_wholesaleDeleteManyArgs} args - Arguments to filter Product_wholesales to delete.
     * @example
     * // Delete a few Product_wholesales
     * const { count } = await prisma.product_wholesale.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends product_wholesaleDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, product_wholesaleDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Product_wholesales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {product_wholesaleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Product_wholesales
     * const product_wholesale = await prisma.product_wholesale.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends product_wholesaleUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, product_wholesaleUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Product_wholesale.
     * @param {product_wholesaleUpsertArgs} args - Arguments to update or create a Product_wholesale.
     * @example
     * // Update or create a Product_wholesale
     * const product_wholesale = await prisma.product_wholesale.upsert({
     *   create: {
     *     // ... data to create a Product_wholesale
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product_wholesale we want to update
     *   }
     * })
    **/
    upsert<T extends product_wholesaleUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, product_wholesaleUpsertArgs<ExtArgs>>
    ): Prisma__product_wholesaleClient<$Result.GetResult<Prisma.$product_wholesalePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Product_wholesales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {product_wholesaleCountArgs} args - Arguments to filter Product_wholesales to count.
     * @example
     * // Count the number of Product_wholesales
     * const count = await prisma.product_wholesale.count({
     *   where: {
     *     // ... the filter for the Product_wholesales we want to count
     *   }
     * })
    **/
    count<T extends product_wholesaleCountArgs>(
      args?: Subset<T, product_wholesaleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Product_wholesaleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product_wholesale.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Product_wholesaleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Product_wholesaleAggregateArgs>(args: Subset<T, Product_wholesaleAggregateArgs>): Prisma.PrismaPromise<GetProduct_wholesaleAggregateType<T>>

    /**
     * Group by Product_wholesale.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {product_wholesaleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends product_wholesaleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: product_wholesaleGroupByArgs['orderBy'] }
        : { orderBy?: product_wholesaleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, product_wholesaleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProduct_wholesaleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the product_wholesale model
   */
  readonly fields: product_wholesaleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for product_wholesale.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__product_wholesaleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    product<T extends productDefaultArgs<ExtArgs> = {}>(args?: Subset<T, productDefaultArgs<ExtArgs>>): Prisma__productClient<$Result.GetResult<Prisma.$productPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the product_wholesale model
   */ 
  interface product_wholesaleFieldRefs {
    readonly id: FieldRef<"product_wholesale", 'Int'>
    readonly productId: FieldRef<"product_wholesale", 'Int'>
    readonly min: FieldRef<"product_wholesale", 'Int'>
    readonly price: FieldRef<"product_wholesale", 'Float'>
    readonly isActive: FieldRef<"product_wholesale", 'Boolean'>
    readonly createdAt: FieldRef<"product_wholesale", 'DateTime'>
    readonly updatedAt: FieldRef<"product_wholesale", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * product_wholesale findUnique
   */
  export type product_wholesaleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_wholesale
     */
    select?: product_wholesaleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: product_wholesaleInclude<ExtArgs> | null
    /**
     * Filter, which product_wholesale to fetch.
     */
    where: product_wholesaleWhereUniqueInput
  }


  /**
   * product_wholesale findUniqueOrThrow
   */
  export type product_wholesaleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_wholesale
     */
    select?: product_wholesaleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: product_wholesaleInclude<ExtArgs> | null
    /**
     * Filter, which product_wholesale to fetch.
     */
    where: product_wholesaleWhereUniqueInput
  }


  /**
   * product_wholesale findFirst
   */
  export type product_wholesaleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_wholesale
     */
    select?: product_wholesaleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: product_wholesaleInclude<ExtArgs> | null
    /**
     * Filter, which product_wholesale to fetch.
     */
    where?: product_wholesaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of product_wholesales to fetch.
     */
    orderBy?: product_wholesaleOrderByWithRelationInput | product_wholesaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for product_wholesales.
     */
    cursor?: product_wholesaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` product_wholesales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` product_wholesales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of product_wholesales.
     */
    distinct?: Product_wholesaleScalarFieldEnum | Product_wholesaleScalarFieldEnum[]
  }


  /**
   * product_wholesale findFirstOrThrow
   */
  export type product_wholesaleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_wholesale
     */
    select?: product_wholesaleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: product_wholesaleInclude<ExtArgs> | null
    /**
     * Filter, which product_wholesale to fetch.
     */
    where?: product_wholesaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of product_wholesales to fetch.
     */
    orderBy?: product_wholesaleOrderByWithRelationInput | product_wholesaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for product_wholesales.
     */
    cursor?: product_wholesaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` product_wholesales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` product_wholesales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of product_wholesales.
     */
    distinct?: Product_wholesaleScalarFieldEnum | Product_wholesaleScalarFieldEnum[]
  }


  /**
   * product_wholesale findMany
   */
  export type product_wholesaleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_wholesale
     */
    select?: product_wholesaleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: product_wholesaleInclude<ExtArgs> | null
    /**
     * Filter, which product_wholesales to fetch.
     */
    where?: product_wholesaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of product_wholesales to fetch.
     */
    orderBy?: product_wholesaleOrderByWithRelationInput | product_wholesaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing product_wholesales.
     */
    cursor?: product_wholesaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` product_wholesales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` product_wholesales.
     */
    skip?: number
    distinct?: Product_wholesaleScalarFieldEnum | Product_wholesaleScalarFieldEnum[]
  }


  /**
   * product_wholesale create
   */
  export type product_wholesaleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_wholesale
     */
    select?: product_wholesaleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: product_wholesaleInclude<ExtArgs> | null
    /**
     * The data needed to create a product_wholesale.
     */
    data: XOR<product_wholesaleCreateInput, product_wholesaleUncheckedCreateInput>
  }


  /**
   * product_wholesale createMany
   */
  export type product_wholesaleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many product_wholesales.
     */
    data: product_wholesaleCreateManyInput | product_wholesaleCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * product_wholesale update
   */
  export type product_wholesaleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_wholesale
     */
    select?: product_wholesaleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: product_wholesaleInclude<ExtArgs> | null
    /**
     * The data needed to update a product_wholesale.
     */
    data: XOR<product_wholesaleUpdateInput, product_wholesaleUncheckedUpdateInput>
    /**
     * Choose, which product_wholesale to update.
     */
    where: product_wholesaleWhereUniqueInput
  }


  /**
   * product_wholesale updateMany
   */
  export type product_wholesaleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update product_wholesales.
     */
    data: XOR<product_wholesaleUpdateManyMutationInput, product_wholesaleUncheckedUpdateManyInput>
    /**
     * Filter which product_wholesales to update
     */
    where?: product_wholesaleWhereInput
  }


  /**
   * product_wholesale upsert
   */
  export type product_wholesaleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_wholesale
     */
    select?: product_wholesaleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: product_wholesaleInclude<ExtArgs> | null
    /**
     * The filter to search for the product_wholesale to update in case it exists.
     */
    where: product_wholesaleWhereUniqueInput
    /**
     * In case the product_wholesale found by the `where` argument doesn't exist, create a new product_wholesale with this data.
     */
    create: XOR<product_wholesaleCreateInput, product_wholesaleUncheckedCreateInput>
    /**
     * In case the product_wholesale was found with the provided `where` argument, update it with this data.
     */
    update: XOR<product_wholesaleUpdateInput, product_wholesaleUncheckedUpdateInput>
  }


  /**
   * product_wholesale delete
   */
  export type product_wholesaleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_wholesale
     */
    select?: product_wholesaleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: product_wholesaleInclude<ExtArgs> | null
    /**
     * Filter which product_wholesale to delete.
     */
    where: product_wholesaleWhereUniqueInput
  }


  /**
   * product_wholesale deleteMany
   */
  export type product_wholesaleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which product_wholesales to delete
     */
    where?: product_wholesaleWhereInput
  }


  /**
   * product_wholesale without action
   */
  export type product_wholesaleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_wholesale
     */
    select?: product_wholesaleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: product_wholesaleInclude<ExtArgs> | null
  }



  /**
   * Model product_option_first
   */

  export type AggregateProduct_option_first = {
    _count: Product_option_firstCountAggregateOutputType | null
    _avg: Product_option_firstAvgAggregateOutputType | null
    _sum: Product_option_firstSumAggregateOutputType | null
    _min: Product_option_firstMinAggregateOutputType | null
    _max: Product_option_firstMaxAggregateOutputType | null
  }

  export type Product_option_firstAvgAggregateOutputType = {
    id: number | null
    productId: number | null
  }

  export type Product_option_firstSumAggregateOutputType = {
    id: number | null
    productId: number | null
  }

  export type Product_option_firstMinAggregateOutputType = {
    id: number | null
    productId: number | null
    name: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Product_option_firstMaxAggregateOutputType = {
    id: number | null
    productId: number | null
    name: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Product_option_firstCountAggregateOutputType = {
    id: number
    productId: number
    name: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Product_option_firstAvgAggregateInputType = {
    id?: true
    productId?: true
  }

  export type Product_option_firstSumAggregateInputType = {
    id?: true
    productId?: true
  }

  export type Product_option_firstMinAggregateInputType = {
    id?: true
    productId?: true
    name?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Product_option_firstMaxAggregateInputType = {
    id?: true
    productId?: true
    name?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Product_option_firstCountAggregateInputType = {
    id?: true
    productId?: true
    name?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Product_option_firstAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which product_option_first to aggregate.
     */
    where?: product_option_firstWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of product_option_firsts to fetch.
     */
    orderBy?: product_option_firstOrderByWithRelationInput | product_option_firstOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: product_option_firstWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` product_option_firsts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` product_option_firsts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned product_option_firsts
    **/
    _count?: true | Product_option_firstCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Product_option_firstAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Product_option_firstSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Product_option_firstMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Product_option_firstMaxAggregateInputType
  }

  export type GetProduct_option_firstAggregateType<T extends Product_option_firstAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct_option_first]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct_option_first[P]>
      : GetScalarType<T[P], AggregateProduct_option_first[P]>
  }




  export type product_option_firstGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: product_option_firstWhereInput
    orderBy?: product_option_firstOrderByWithAggregationInput | product_option_firstOrderByWithAggregationInput[]
    by: Product_option_firstScalarFieldEnum[] | Product_option_firstScalarFieldEnum
    having?: product_option_firstScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Product_option_firstCountAggregateInputType | true
    _avg?: Product_option_firstAvgAggregateInputType
    _sum?: Product_option_firstSumAggregateInputType
    _min?: Product_option_firstMinAggregateInputType
    _max?: Product_option_firstMaxAggregateInputType
  }

  export type Product_option_firstGroupByOutputType = {
    id: number
    productId: number
    name: string
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: Product_option_firstCountAggregateOutputType | null
    _avg: Product_option_firstAvgAggregateOutputType | null
    _sum: Product_option_firstSumAggregateOutputType | null
    _min: Product_option_firstMinAggregateOutputType | null
    _max: Product_option_firstMaxAggregateOutputType | null
  }

  type GetProduct_option_firstGroupByPayload<T extends product_option_firstGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Product_option_firstGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Product_option_firstGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Product_option_firstGroupByOutputType[P]>
            : GetScalarType<T[P], Product_option_firstGroupByOutputType[P]>
        }
      >
    >


  export type product_option_firstSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    name?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | productDefaultArgs<ExtArgs>
    product_price?: boolean | product_option_first$product_priceArgs<ExtArgs>
    _count?: boolean | Product_option_firstCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product_option_first"]>

  export type product_option_firstSelectScalar = {
    id?: boolean
    productId?: boolean
    name?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type product_option_firstInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | productDefaultArgs<ExtArgs>
    product_price?: boolean | product_option_first$product_priceArgs<ExtArgs>
    _count?: boolean | Product_option_firstCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $product_option_firstPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "product_option_first"
    objects: {
      product: Prisma.$productPayload<ExtArgs>
      product_price: Prisma.$product_pricePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      productId: number
      name: string
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["product_option_first"]>
    composites: {}
  }


  type product_option_firstGetPayload<S extends boolean | null | undefined | product_option_firstDefaultArgs> = $Result.GetResult<Prisma.$product_option_firstPayload, S>

  type product_option_firstCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<product_option_firstFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Product_option_firstCountAggregateInputType | true
    }

  export interface product_option_firstDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['product_option_first'], meta: { name: 'product_option_first' } }
    /**
     * Find zero or one Product_option_first that matches the filter.
     * @param {product_option_firstFindUniqueArgs} args - Arguments to find a Product_option_first
     * @example
     * // Get one Product_option_first
     * const product_option_first = await prisma.product_option_first.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends product_option_firstFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, product_option_firstFindUniqueArgs<ExtArgs>>
    ): Prisma__product_option_firstClient<$Result.GetResult<Prisma.$product_option_firstPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Product_option_first that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {product_option_firstFindUniqueOrThrowArgs} args - Arguments to find a Product_option_first
     * @example
     * // Get one Product_option_first
     * const product_option_first = await prisma.product_option_first.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends product_option_firstFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, product_option_firstFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__product_option_firstClient<$Result.GetResult<Prisma.$product_option_firstPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Product_option_first that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {product_option_firstFindFirstArgs} args - Arguments to find a Product_option_first
     * @example
     * // Get one Product_option_first
     * const product_option_first = await prisma.product_option_first.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends product_option_firstFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, product_option_firstFindFirstArgs<ExtArgs>>
    ): Prisma__product_option_firstClient<$Result.GetResult<Prisma.$product_option_firstPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Product_option_first that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {product_option_firstFindFirstOrThrowArgs} args - Arguments to find a Product_option_first
     * @example
     * // Get one Product_option_first
     * const product_option_first = await prisma.product_option_first.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends product_option_firstFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, product_option_firstFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__product_option_firstClient<$Result.GetResult<Prisma.$product_option_firstPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Product_option_firsts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {product_option_firstFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Product_option_firsts
     * const product_option_firsts = await prisma.product_option_first.findMany()
     * 
     * // Get first 10 Product_option_firsts
     * const product_option_firsts = await prisma.product_option_first.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const product_option_firstWithIdOnly = await prisma.product_option_first.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends product_option_firstFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, product_option_firstFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$product_option_firstPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Product_option_first.
     * @param {product_option_firstCreateArgs} args - Arguments to create a Product_option_first.
     * @example
     * // Create one Product_option_first
     * const Product_option_first = await prisma.product_option_first.create({
     *   data: {
     *     // ... data to create a Product_option_first
     *   }
     * })
     * 
    **/
    create<T extends product_option_firstCreateArgs<ExtArgs>>(
      args: SelectSubset<T, product_option_firstCreateArgs<ExtArgs>>
    ): Prisma__product_option_firstClient<$Result.GetResult<Prisma.$product_option_firstPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Product_option_firsts.
     *     @param {product_option_firstCreateManyArgs} args - Arguments to create many Product_option_firsts.
     *     @example
     *     // Create many Product_option_firsts
     *     const product_option_first = await prisma.product_option_first.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends product_option_firstCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, product_option_firstCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Product_option_first.
     * @param {product_option_firstDeleteArgs} args - Arguments to delete one Product_option_first.
     * @example
     * // Delete one Product_option_first
     * const Product_option_first = await prisma.product_option_first.delete({
     *   where: {
     *     // ... filter to delete one Product_option_first
     *   }
     * })
     * 
    **/
    delete<T extends product_option_firstDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, product_option_firstDeleteArgs<ExtArgs>>
    ): Prisma__product_option_firstClient<$Result.GetResult<Prisma.$product_option_firstPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Product_option_first.
     * @param {product_option_firstUpdateArgs} args - Arguments to update one Product_option_first.
     * @example
     * // Update one Product_option_first
     * const product_option_first = await prisma.product_option_first.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends product_option_firstUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, product_option_firstUpdateArgs<ExtArgs>>
    ): Prisma__product_option_firstClient<$Result.GetResult<Prisma.$product_option_firstPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Product_option_firsts.
     * @param {product_option_firstDeleteManyArgs} args - Arguments to filter Product_option_firsts to delete.
     * @example
     * // Delete a few Product_option_firsts
     * const { count } = await prisma.product_option_first.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends product_option_firstDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, product_option_firstDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Product_option_firsts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {product_option_firstUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Product_option_firsts
     * const product_option_first = await prisma.product_option_first.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends product_option_firstUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, product_option_firstUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Product_option_first.
     * @param {product_option_firstUpsertArgs} args - Arguments to update or create a Product_option_first.
     * @example
     * // Update or create a Product_option_first
     * const product_option_first = await prisma.product_option_first.upsert({
     *   create: {
     *     // ... data to create a Product_option_first
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product_option_first we want to update
     *   }
     * })
    **/
    upsert<T extends product_option_firstUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, product_option_firstUpsertArgs<ExtArgs>>
    ): Prisma__product_option_firstClient<$Result.GetResult<Prisma.$product_option_firstPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Product_option_firsts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {product_option_firstCountArgs} args - Arguments to filter Product_option_firsts to count.
     * @example
     * // Count the number of Product_option_firsts
     * const count = await prisma.product_option_first.count({
     *   where: {
     *     // ... the filter for the Product_option_firsts we want to count
     *   }
     * })
    **/
    count<T extends product_option_firstCountArgs>(
      args?: Subset<T, product_option_firstCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Product_option_firstCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product_option_first.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Product_option_firstAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Product_option_firstAggregateArgs>(args: Subset<T, Product_option_firstAggregateArgs>): Prisma.PrismaPromise<GetProduct_option_firstAggregateType<T>>

    /**
     * Group by Product_option_first.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {product_option_firstGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends product_option_firstGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: product_option_firstGroupByArgs['orderBy'] }
        : { orderBy?: product_option_firstGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, product_option_firstGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProduct_option_firstGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the product_option_first model
   */
  readonly fields: product_option_firstFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for product_option_first.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__product_option_firstClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    product<T extends productDefaultArgs<ExtArgs> = {}>(args?: Subset<T, productDefaultArgs<ExtArgs>>): Prisma__productClient<$Result.GetResult<Prisma.$productPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    product_price<T extends product_option_first$product_priceArgs<ExtArgs> = {}>(args?: Subset<T, product_option_first$product_priceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$product_pricePayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the product_option_first model
   */ 
  interface product_option_firstFieldRefs {
    readonly id: FieldRef<"product_option_first", 'Int'>
    readonly productId: FieldRef<"product_option_first", 'Int'>
    readonly name: FieldRef<"product_option_first", 'String'>
    readonly isActive: FieldRef<"product_option_first", 'Boolean'>
    readonly createdAt: FieldRef<"product_option_first", 'DateTime'>
    readonly updatedAt: FieldRef<"product_option_first", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * product_option_first findUnique
   */
  export type product_option_firstFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_option_first
     */
    select?: product_option_firstSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: product_option_firstInclude<ExtArgs> | null
    /**
     * Filter, which product_option_first to fetch.
     */
    where: product_option_firstWhereUniqueInput
  }


  /**
   * product_option_first findUniqueOrThrow
   */
  export type product_option_firstFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_option_first
     */
    select?: product_option_firstSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: product_option_firstInclude<ExtArgs> | null
    /**
     * Filter, which product_option_first to fetch.
     */
    where: product_option_firstWhereUniqueInput
  }


  /**
   * product_option_first findFirst
   */
  export type product_option_firstFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_option_first
     */
    select?: product_option_firstSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: product_option_firstInclude<ExtArgs> | null
    /**
     * Filter, which product_option_first to fetch.
     */
    where?: product_option_firstWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of product_option_firsts to fetch.
     */
    orderBy?: product_option_firstOrderByWithRelationInput | product_option_firstOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for product_option_firsts.
     */
    cursor?: product_option_firstWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` product_option_firsts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` product_option_firsts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of product_option_firsts.
     */
    distinct?: Product_option_firstScalarFieldEnum | Product_option_firstScalarFieldEnum[]
  }


  /**
   * product_option_first findFirstOrThrow
   */
  export type product_option_firstFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_option_first
     */
    select?: product_option_firstSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: product_option_firstInclude<ExtArgs> | null
    /**
     * Filter, which product_option_first to fetch.
     */
    where?: product_option_firstWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of product_option_firsts to fetch.
     */
    orderBy?: product_option_firstOrderByWithRelationInput | product_option_firstOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for product_option_firsts.
     */
    cursor?: product_option_firstWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` product_option_firsts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` product_option_firsts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of product_option_firsts.
     */
    distinct?: Product_option_firstScalarFieldEnum | Product_option_firstScalarFieldEnum[]
  }


  /**
   * product_option_first findMany
   */
  export type product_option_firstFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_option_first
     */
    select?: product_option_firstSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: product_option_firstInclude<ExtArgs> | null
    /**
     * Filter, which product_option_firsts to fetch.
     */
    where?: product_option_firstWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of product_option_firsts to fetch.
     */
    orderBy?: product_option_firstOrderByWithRelationInput | product_option_firstOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing product_option_firsts.
     */
    cursor?: product_option_firstWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` product_option_firsts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` product_option_firsts.
     */
    skip?: number
    distinct?: Product_option_firstScalarFieldEnum | Product_option_firstScalarFieldEnum[]
  }


  /**
   * product_option_first create
   */
  export type product_option_firstCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_option_first
     */
    select?: product_option_firstSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: product_option_firstInclude<ExtArgs> | null
    /**
     * The data needed to create a product_option_first.
     */
    data: XOR<product_option_firstCreateInput, product_option_firstUncheckedCreateInput>
  }


  /**
   * product_option_first createMany
   */
  export type product_option_firstCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many product_option_firsts.
     */
    data: product_option_firstCreateManyInput | product_option_firstCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * product_option_first update
   */
  export type product_option_firstUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_option_first
     */
    select?: product_option_firstSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: product_option_firstInclude<ExtArgs> | null
    /**
     * The data needed to update a product_option_first.
     */
    data: XOR<product_option_firstUpdateInput, product_option_firstUncheckedUpdateInput>
    /**
     * Choose, which product_option_first to update.
     */
    where: product_option_firstWhereUniqueInput
  }


  /**
   * product_option_first updateMany
   */
  export type product_option_firstUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update product_option_firsts.
     */
    data: XOR<product_option_firstUpdateManyMutationInput, product_option_firstUncheckedUpdateManyInput>
    /**
     * Filter which product_option_firsts to update
     */
    where?: product_option_firstWhereInput
  }


  /**
   * product_option_first upsert
   */
  export type product_option_firstUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_option_first
     */
    select?: product_option_firstSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: product_option_firstInclude<ExtArgs> | null
    /**
     * The filter to search for the product_option_first to update in case it exists.
     */
    where: product_option_firstWhereUniqueInput
    /**
     * In case the product_option_first found by the `where` argument doesn't exist, create a new product_option_first with this data.
     */
    create: XOR<product_option_firstCreateInput, product_option_firstUncheckedCreateInput>
    /**
     * In case the product_option_first was found with the provided `where` argument, update it with this data.
     */
    update: XOR<product_option_firstUpdateInput, product_option_firstUncheckedUpdateInput>
  }


  /**
   * product_option_first delete
   */
  export type product_option_firstDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_option_first
     */
    select?: product_option_firstSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: product_option_firstInclude<ExtArgs> | null
    /**
     * Filter which product_option_first to delete.
     */
    where: product_option_firstWhereUniqueInput
  }


  /**
   * product_option_first deleteMany
   */
  export type product_option_firstDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which product_option_firsts to delete
     */
    where?: product_option_firstWhereInput
  }


  /**
   * product_option_first.product_price
   */
  export type product_option_first$product_priceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_price
     */
    select?: product_priceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: product_priceInclude<ExtArgs> | null
    where?: product_priceWhereInput
    orderBy?: product_priceOrderByWithRelationInput | product_priceOrderByWithRelationInput[]
    cursor?: product_priceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Product_priceScalarFieldEnum | Product_priceScalarFieldEnum[]
  }


  /**
   * product_option_first without action
   */
  export type product_option_firstDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_option_first
     */
    select?: product_option_firstSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: product_option_firstInclude<ExtArgs> | null
  }



  /**
   * Model product_option_second
   */

  export type AggregateProduct_option_second = {
    _count: Product_option_secondCountAggregateOutputType | null
    _avg: Product_option_secondAvgAggregateOutputType | null
    _sum: Product_option_secondSumAggregateOutputType | null
    _min: Product_option_secondMinAggregateOutputType | null
    _max: Product_option_secondMaxAggregateOutputType | null
  }

  export type Product_option_secondAvgAggregateOutputType = {
    id: number | null
    productId: number | null
  }

  export type Product_option_secondSumAggregateOutputType = {
    id: number | null
    productId: number | null
  }

  export type Product_option_secondMinAggregateOutputType = {
    id: number | null
    productId: number | null
    name: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Product_option_secondMaxAggregateOutputType = {
    id: number | null
    productId: number | null
    name: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Product_option_secondCountAggregateOutputType = {
    id: number
    productId: number
    name: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Product_option_secondAvgAggregateInputType = {
    id?: true
    productId?: true
  }

  export type Product_option_secondSumAggregateInputType = {
    id?: true
    productId?: true
  }

  export type Product_option_secondMinAggregateInputType = {
    id?: true
    productId?: true
    name?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Product_option_secondMaxAggregateInputType = {
    id?: true
    productId?: true
    name?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Product_option_secondCountAggregateInputType = {
    id?: true
    productId?: true
    name?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Product_option_secondAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which product_option_second to aggregate.
     */
    where?: product_option_secondWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of product_option_seconds to fetch.
     */
    orderBy?: product_option_secondOrderByWithRelationInput | product_option_secondOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: product_option_secondWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` product_option_seconds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` product_option_seconds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned product_option_seconds
    **/
    _count?: true | Product_option_secondCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Product_option_secondAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Product_option_secondSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Product_option_secondMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Product_option_secondMaxAggregateInputType
  }

  export type GetProduct_option_secondAggregateType<T extends Product_option_secondAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct_option_second]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct_option_second[P]>
      : GetScalarType<T[P], AggregateProduct_option_second[P]>
  }




  export type product_option_secondGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: product_option_secondWhereInput
    orderBy?: product_option_secondOrderByWithAggregationInput | product_option_secondOrderByWithAggregationInput[]
    by: Product_option_secondScalarFieldEnum[] | Product_option_secondScalarFieldEnum
    having?: product_option_secondScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Product_option_secondCountAggregateInputType | true
    _avg?: Product_option_secondAvgAggregateInputType
    _sum?: Product_option_secondSumAggregateInputType
    _min?: Product_option_secondMinAggregateInputType
    _max?: Product_option_secondMaxAggregateInputType
  }

  export type Product_option_secondGroupByOutputType = {
    id: number
    productId: number
    name: string
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: Product_option_secondCountAggregateOutputType | null
    _avg: Product_option_secondAvgAggregateOutputType | null
    _sum: Product_option_secondSumAggregateOutputType | null
    _min: Product_option_secondMinAggregateOutputType | null
    _max: Product_option_secondMaxAggregateOutputType | null
  }

  type GetProduct_option_secondGroupByPayload<T extends product_option_secondGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Product_option_secondGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Product_option_secondGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Product_option_secondGroupByOutputType[P]>
            : GetScalarType<T[P], Product_option_secondGroupByOutputType[P]>
        }
      >
    >


  export type product_option_secondSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    name?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | productDefaultArgs<ExtArgs>
    product_price?: boolean | product_option_second$product_priceArgs<ExtArgs>
    _count?: boolean | Product_option_secondCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product_option_second"]>

  export type product_option_secondSelectScalar = {
    id?: boolean
    productId?: boolean
    name?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type product_option_secondInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | productDefaultArgs<ExtArgs>
    product_price?: boolean | product_option_second$product_priceArgs<ExtArgs>
    _count?: boolean | Product_option_secondCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $product_option_secondPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "product_option_second"
    objects: {
      product: Prisma.$productPayload<ExtArgs>
      product_price: Prisma.$product_pricePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      productId: number
      name: string
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["product_option_second"]>
    composites: {}
  }


  type product_option_secondGetPayload<S extends boolean | null | undefined | product_option_secondDefaultArgs> = $Result.GetResult<Prisma.$product_option_secondPayload, S>

  type product_option_secondCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<product_option_secondFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Product_option_secondCountAggregateInputType | true
    }

  export interface product_option_secondDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['product_option_second'], meta: { name: 'product_option_second' } }
    /**
     * Find zero or one Product_option_second that matches the filter.
     * @param {product_option_secondFindUniqueArgs} args - Arguments to find a Product_option_second
     * @example
     * // Get one Product_option_second
     * const product_option_second = await prisma.product_option_second.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends product_option_secondFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, product_option_secondFindUniqueArgs<ExtArgs>>
    ): Prisma__product_option_secondClient<$Result.GetResult<Prisma.$product_option_secondPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Product_option_second that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {product_option_secondFindUniqueOrThrowArgs} args - Arguments to find a Product_option_second
     * @example
     * // Get one Product_option_second
     * const product_option_second = await prisma.product_option_second.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends product_option_secondFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, product_option_secondFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__product_option_secondClient<$Result.GetResult<Prisma.$product_option_secondPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Product_option_second that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {product_option_secondFindFirstArgs} args - Arguments to find a Product_option_second
     * @example
     * // Get one Product_option_second
     * const product_option_second = await prisma.product_option_second.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends product_option_secondFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, product_option_secondFindFirstArgs<ExtArgs>>
    ): Prisma__product_option_secondClient<$Result.GetResult<Prisma.$product_option_secondPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Product_option_second that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {product_option_secondFindFirstOrThrowArgs} args - Arguments to find a Product_option_second
     * @example
     * // Get one Product_option_second
     * const product_option_second = await prisma.product_option_second.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends product_option_secondFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, product_option_secondFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__product_option_secondClient<$Result.GetResult<Prisma.$product_option_secondPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Product_option_seconds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {product_option_secondFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Product_option_seconds
     * const product_option_seconds = await prisma.product_option_second.findMany()
     * 
     * // Get first 10 Product_option_seconds
     * const product_option_seconds = await prisma.product_option_second.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const product_option_secondWithIdOnly = await prisma.product_option_second.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends product_option_secondFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, product_option_secondFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$product_option_secondPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Product_option_second.
     * @param {product_option_secondCreateArgs} args - Arguments to create a Product_option_second.
     * @example
     * // Create one Product_option_second
     * const Product_option_second = await prisma.product_option_second.create({
     *   data: {
     *     // ... data to create a Product_option_second
     *   }
     * })
     * 
    **/
    create<T extends product_option_secondCreateArgs<ExtArgs>>(
      args: SelectSubset<T, product_option_secondCreateArgs<ExtArgs>>
    ): Prisma__product_option_secondClient<$Result.GetResult<Prisma.$product_option_secondPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Product_option_seconds.
     *     @param {product_option_secondCreateManyArgs} args - Arguments to create many Product_option_seconds.
     *     @example
     *     // Create many Product_option_seconds
     *     const product_option_second = await prisma.product_option_second.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends product_option_secondCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, product_option_secondCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Product_option_second.
     * @param {product_option_secondDeleteArgs} args - Arguments to delete one Product_option_second.
     * @example
     * // Delete one Product_option_second
     * const Product_option_second = await prisma.product_option_second.delete({
     *   where: {
     *     // ... filter to delete one Product_option_second
     *   }
     * })
     * 
    **/
    delete<T extends product_option_secondDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, product_option_secondDeleteArgs<ExtArgs>>
    ): Prisma__product_option_secondClient<$Result.GetResult<Prisma.$product_option_secondPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Product_option_second.
     * @param {product_option_secondUpdateArgs} args - Arguments to update one Product_option_second.
     * @example
     * // Update one Product_option_second
     * const product_option_second = await prisma.product_option_second.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends product_option_secondUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, product_option_secondUpdateArgs<ExtArgs>>
    ): Prisma__product_option_secondClient<$Result.GetResult<Prisma.$product_option_secondPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Product_option_seconds.
     * @param {product_option_secondDeleteManyArgs} args - Arguments to filter Product_option_seconds to delete.
     * @example
     * // Delete a few Product_option_seconds
     * const { count } = await prisma.product_option_second.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends product_option_secondDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, product_option_secondDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Product_option_seconds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {product_option_secondUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Product_option_seconds
     * const product_option_second = await prisma.product_option_second.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends product_option_secondUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, product_option_secondUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Product_option_second.
     * @param {product_option_secondUpsertArgs} args - Arguments to update or create a Product_option_second.
     * @example
     * // Update or create a Product_option_second
     * const product_option_second = await prisma.product_option_second.upsert({
     *   create: {
     *     // ... data to create a Product_option_second
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product_option_second we want to update
     *   }
     * })
    **/
    upsert<T extends product_option_secondUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, product_option_secondUpsertArgs<ExtArgs>>
    ): Prisma__product_option_secondClient<$Result.GetResult<Prisma.$product_option_secondPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Product_option_seconds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {product_option_secondCountArgs} args - Arguments to filter Product_option_seconds to count.
     * @example
     * // Count the number of Product_option_seconds
     * const count = await prisma.product_option_second.count({
     *   where: {
     *     // ... the filter for the Product_option_seconds we want to count
     *   }
     * })
    **/
    count<T extends product_option_secondCountArgs>(
      args?: Subset<T, product_option_secondCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Product_option_secondCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product_option_second.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Product_option_secondAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Product_option_secondAggregateArgs>(args: Subset<T, Product_option_secondAggregateArgs>): Prisma.PrismaPromise<GetProduct_option_secondAggregateType<T>>

    /**
     * Group by Product_option_second.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {product_option_secondGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends product_option_secondGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: product_option_secondGroupByArgs['orderBy'] }
        : { orderBy?: product_option_secondGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, product_option_secondGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProduct_option_secondGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the product_option_second model
   */
  readonly fields: product_option_secondFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for product_option_second.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__product_option_secondClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    product<T extends productDefaultArgs<ExtArgs> = {}>(args?: Subset<T, productDefaultArgs<ExtArgs>>): Prisma__productClient<$Result.GetResult<Prisma.$productPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    product_price<T extends product_option_second$product_priceArgs<ExtArgs> = {}>(args?: Subset<T, product_option_second$product_priceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$product_pricePayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the product_option_second model
   */ 
  interface product_option_secondFieldRefs {
    readonly id: FieldRef<"product_option_second", 'Int'>
    readonly productId: FieldRef<"product_option_second", 'Int'>
    readonly name: FieldRef<"product_option_second", 'String'>
    readonly isActive: FieldRef<"product_option_second", 'Boolean'>
    readonly createdAt: FieldRef<"product_option_second", 'DateTime'>
    readonly updatedAt: FieldRef<"product_option_second", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * product_option_second findUnique
   */
  export type product_option_secondFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_option_second
     */
    select?: product_option_secondSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: product_option_secondInclude<ExtArgs> | null
    /**
     * Filter, which product_option_second to fetch.
     */
    where: product_option_secondWhereUniqueInput
  }


  /**
   * product_option_second findUniqueOrThrow
   */
  export type product_option_secondFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_option_second
     */
    select?: product_option_secondSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: product_option_secondInclude<ExtArgs> | null
    /**
     * Filter, which product_option_second to fetch.
     */
    where: product_option_secondWhereUniqueInput
  }


  /**
   * product_option_second findFirst
   */
  export type product_option_secondFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_option_second
     */
    select?: product_option_secondSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: product_option_secondInclude<ExtArgs> | null
    /**
     * Filter, which product_option_second to fetch.
     */
    where?: product_option_secondWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of product_option_seconds to fetch.
     */
    orderBy?: product_option_secondOrderByWithRelationInput | product_option_secondOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for product_option_seconds.
     */
    cursor?: product_option_secondWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` product_option_seconds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` product_option_seconds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of product_option_seconds.
     */
    distinct?: Product_option_secondScalarFieldEnum | Product_option_secondScalarFieldEnum[]
  }


  /**
   * product_option_second findFirstOrThrow
   */
  export type product_option_secondFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_option_second
     */
    select?: product_option_secondSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: product_option_secondInclude<ExtArgs> | null
    /**
     * Filter, which product_option_second to fetch.
     */
    where?: product_option_secondWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of product_option_seconds to fetch.
     */
    orderBy?: product_option_secondOrderByWithRelationInput | product_option_secondOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for product_option_seconds.
     */
    cursor?: product_option_secondWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` product_option_seconds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` product_option_seconds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of product_option_seconds.
     */
    distinct?: Product_option_secondScalarFieldEnum | Product_option_secondScalarFieldEnum[]
  }


  /**
   * product_option_second findMany
   */
  export type product_option_secondFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_option_second
     */
    select?: product_option_secondSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: product_option_secondInclude<ExtArgs> | null
    /**
     * Filter, which product_option_seconds to fetch.
     */
    where?: product_option_secondWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of product_option_seconds to fetch.
     */
    orderBy?: product_option_secondOrderByWithRelationInput | product_option_secondOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing product_option_seconds.
     */
    cursor?: product_option_secondWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` product_option_seconds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` product_option_seconds.
     */
    skip?: number
    distinct?: Product_option_secondScalarFieldEnum | Product_option_secondScalarFieldEnum[]
  }


  /**
   * product_option_second create
   */
  export type product_option_secondCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_option_second
     */
    select?: product_option_secondSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: product_option_secondInclude<ExtArgs> | null
    /**
     * The data needed to create a product_option_second.
     */
    data: XOR<product_option_secondCreateInput, product_option_secondUncheckedCreateInput>
  }


  /**
   * product_option_second createMany
   */
  export type product_option_secondCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many product_option_seconds.
     */
    data: product_option_secondCreateManyInput | product_option_secondCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * product_option_second update
   */
  export type product_option_secondUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_option_second
     */
    select?: product_option_secondSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: product_option_secondInclude<ExtArgs> | null
    /**
     * The data needed to update a product_option_second.
     */
    data: XOR<product_option_secondUpdateInput, product_option_secondUncheckedUpdateInput>
    /**
     * Choose, which product_option_second to update.
     */
    where: product_option_secondWhereUniqueInput
  }


  /**
   * product_option_second updateMany
   */
  export type product_option_secondUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update product_option_seconds.
     */
    data: XOR<product_option_secondUpdateManyMutationInput, product_option_secondUncheckedUpdateManyInput>
    /**
     * Filter which product_option_seconds to update
     */
    where?: product_option_secondWhereInput
  }


  /**
   * product_option_second upsert
   */
  export type product_option_secondUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_option_second
     */
    select?: product_option_secondSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: product_option_secondInclude<ExtArgs> | null
    /**
     * The filter to search for the product_option_second to update in case it exists.
     */
    where: product_option_secondWhereUniqueInput
    /**
     * In case the product_option_second found by the `where` argument doesn't exist, create a new product_option_second with this data.
     */
    create: XOR<product_option_secondCreateInput, product_option_secondUncheckedCreateInput>
    /**
     * In case the product_option_second was found with the provided `where` argument, update it with this data.
     */
    update: XOR<product_option_secondUpdateInput, product_option_secondUncheckedUpdateInput>
  }


  /**
   * product_option_second delete
   */
  export type product_option_secondDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_option_second
     */
    select?: product_option_secondSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: product_option_secondInclude<ExtArgs> | null
    /**
     * Filter which product_option_second to delete.
     */
    where: product_option_secondWhereUniqueInput
  }


  /**
   * product_option_second deleteMany
   */
  export type product_option_secondDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which product_option_seconds to delete
     */
    where?: product_option_secondWhereInput
  }


  /**
   * product_option_second.product_price
   */
  export type product_option_second$product_priceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_price
     */
    select?: product_priceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: product_priceInclude<ExtArgs> | null
    where?: product_priceWhereInput
    orderBy?: product_priceOrderByWithRelationInput | product_priceOrderByWithRelationInput[]
    cursor?: product_priceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Product_priceScalarFieldEnum | Product_priceScalarFieldEnum[]
  }


  /**
   * product_option_second without action
   */
  export type product_option_secondDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_option_second
     */
    select?: product_option_secondSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: product_option_secondInclude<ExtArgs> | null
  }



  /**
   * Model product_price
   */

  export type AggregateProduct_price = {
    _count: Product_priceCountAggregateOutputType | null
    _avg: Product_priceAvgAggregateOutputType | null
    _sum: Product_priceSumAggregateOutputType | null
    _min: Product_priceMinAggregateOutputType | null
    _max: Product_priceMaxAggregateOutputType | null
  }

  export type Product_priceAvgAggregateOutputType = {
    id: number | null
    productId: number | null
    product_option_firstId: number | null
    product_option_secondId: number | null
    price: number | null
  }

  export type Product_priceSumAggregateOutputType = {
    id: number | null
    productId: number | null
    product_option_firstId: number | null
    product_option_secondId: number | null
    price: number | null
  }

  export type Product_priceMinAggregateOutputType = {
    id: number | null
    productId: number | null
    product_option_firstId: number | null
    product_option_secondId: number | null
    price: number | null
    sku: string | null
    isWholesale: boolean | null
  }

  export type Product_priceMaxAggregateOutputType = {
    id: number | null
    productId: number | null
    product_option_firstId: number | null
    product_option_secondId: number | null
    price: number | null
    sku: string | null
    isWholesale: boolean | null
  }

  export type Product_priceCountAggregateOutputType = {
    id: number
    productId: number
    product_option_firstId: number
    product_option_secondId: number
    price: number
    sku: number
    isWholesale: number
    _all: number
  }


  export type Product_priceAvgAggregateInputType = {
    id?: true
    productId?: true
    product_option_firstId?: true
    product_option_secondId?: true
    price?: true
  }

  export type Product_priceSumAggregateInputType = {
    id?: true
    productId?: true
    product_option_firstId?: true
    product_option_secondId?: true
    price?: true
  }

  export type Product_priceMinAggregateInputType = {
    id?: true
    productId?: true
    product_option_firstId?: true
    product_option_secondId?: true
    price?: true
    sku?: true
    isWholesale?: true
  }

  export type Product_priceMaxAggregateInputType = {
    id?: true
    productId?: true
    product_option_firstId?: true
    product_option_secondId?: true
    price?: true
    sku?: true
    isWholesale?: true
  }

  export type Product_priceCountAggregateInputType = {
    id?: true
    productId?: true
    product_option_firstId?: true
    product_option_secondId?: true
    price?: true
    sku?: true
    isWholesale?: true
    _all?: true
  }

  export type Product_priceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which product_price to aggregate.
     */
    where?: product_priceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of product_prices to fetch.
     */
    orderBy?: product_priceOrderByWithRelationInput | product_priceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: product_priceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` product_prices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` product_prices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned product_prices
    **/
    _count?: true | Product_priceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Product_priceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Product_priceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Product_priceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Product_priceMaxAggregateInputType
  }

  export type GetProduct_priceAggregateType<T extends Product_priceAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct_price]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct_price[P]>
      : GetScalarType<T[P], AggregateProduct_price[P]>
  }




  export type product_priceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: product_priceWhereInput
    orderBy?: product_priceOrderByWithAggregationInput | product_priceOrderByWithAggregationInput[]
    by: Product_priceScalarFieldEnum[] | Product_priceScalarFieldEnum
    having?: product_priceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Product_priceCountAggregateInputType | true
    _avg?: Product_priceAvgAggregateInputType
    _sum?: Product_priceSumAggregateInputType
    _min?: Product_priceMinAggregateInputType
    _max?: Product_priceMaxAggregateInputType
  }

  export type Product_priceGroupByOutputType = {
    id: number
    productId: number
    product_option_firstId: number | null
    product_option_secondId: number | null
    price: number
    sku: string | null
    isWholesale: boolean
    _count: Product_priceCountAggregateOutputType | null
    _avg: Product_priceAvgAggregateOutputType | null
    _sum: Product_priceSumAggregateOutputType | null
    _min: Product_priceMinAggregateOutputType | null
    _max: Product_priceMaxAggregateOutputType | null
  }

  type GetProduct_priceGroupByPayload<T extends product_priceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Product_priceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Product_priceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Product_priceGroupByOutputType[P]>
            : GetScalarType<T[P], Product_priceGroupByOutputType[P]>
        }
      >
    >


  export type product_priceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    product_option_firstId?: boolean
    product_option_secondId?: boolean
    price?: boolean
    sku?: boolean
    isWholesale?: boolean
    product?: boolean | productDefaultArgs<ExtArgs>
    product_option_first?: boolean | product_price$product_option_firstArgs<ExtArgs>
    product_option_second?: boolean | product_price$product_option_secondArgs<ExtArgs>
    cart?: boolean | product_price$cartArgs<ExtArgs>
    order_product?: boolean | product_price$order_productArgs<ExtArgs>
    _count?: boolean | Product_priceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product_price"]>

  export type product_priceSelectScalar = {
    id?: boolean
    productId?: boolean
    product_option_firstId?: boolean
    product_option_secondId?: boolean
    price?: boolean
    sku?: boolean
    isWholesale?: boolean
  }

  export type product_priceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | productDefaultArgs<ExtArgs>
    product_option_first?: boolean | product_price$product_option_firstArgs<ExtArgs>
    product_option_second?: boolean | product_price$product_option_secondArgs<ExtArgs>
    cart?: boolean | product_price$cartArgs<ExtArgs>
    order_product?: boolean | product_price$order_productArgs<ExtArgs>
    _count?: boolean | Product_priceCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $product_pricePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "product_price"
    objects: {
      product: Prisma.$productPayload<ExtArgs>
      product_option_first: Prisma.$product_option_firstPayload<ExtArgs> | null
      product_option_second: Prisma.$product_option_secondPayload<ExtArgs> | null
      cart: Prisma.$cartPayload<ExtArgs>[]
      order_product: Prisma.$order_productPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      productId: number
      product_option_firstId: number | null
      product_option_secondId: number | null
      price: number
      sku: string | null
      isWholesale: boolean
    }, ExtArgs["result"]["product_price"]>
    composites: {}
  }


  type product_priceGetPayload<S extends boolean | null | undefined | product_priceDefaultArgs> = $Result.GetResult<Prisma.$product_pricePayload, S>

  type product_priceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<product_priceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Product_priceCountAggregateInputType | true
    }

  export interface product_priceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['product_price'], meta: { name: 'product_price' } }
    /**
     * Find zero or one Product_price that matches the filter.
     * @param {product_priceFindUniqueArgs} args - Arguments to find a Product_price
     * @example
     * // Get one Product_price
     * const product_price = await prisma.product_price.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends product_priceFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, product_priceFindUniqueArgs<ExtArgs>>
    ): Prisma__product_priceClient<$Result.GetResult<Prisma.$product_pricePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Product_price that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {product_priceFindUniqueOrThrowArgs} args - Arguments to find a Product_price
     * @example
     * // Get one Product_price
     * const product_price = await prisma.product_price.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends product_priceFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, product_priceFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__product_priceClient<$Result.GetResult<Prisma.$product_pricePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Product_price that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {product_priceFindFirstArgs} args - Arguments to find a Product_price
     * @example
     * // Get one Product_price
     * const product_price = await prisma.product_price.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends product_priceFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, product_priceFindFirstArgs<ExtArgs>>
    ): Prisma__product_priceClient<$Result.GetResult<Prisma.$product_pricePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Product_price that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {product_priceFindFirstOrThrowArgs} args - Arguments to find a Product_price
     * @example
     * // Get one Product_price
     * const product_price = await prisma.product_price.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends product_priceFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, product_priceFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__product_priceClient<$Result.GetResult<Prisma.$product_pricePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Product_prices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {product_priceFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Product_prices
     * const product_prices = await prisma.product_price.findMany()
     * 
     * // Get first 10 Product_prices
     * const product_prices = await prisma.product_price.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const product_priceWithIdOnly = await prisma.product_price.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends product_priceFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, product_priceFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$product_pricePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Product_price.
     * @param {product_priceCreateArgs} args - Arguments to create a Product_price.
     * @example
     * // Create one Product_price
     * const Product_price = await prisma.product_price.create({
     *   data: {
     *     // ... data to create a Product_price
     *   }
     * })
     * 
    **/
    create<T extends product_priceCreateArgs<ExtArgs>>(
      args: SelectSubset<T, product_priceCreateArgs<ExtArgs>>
    ): Prisma__product_priceClient<$Result.GetResult<Prisma.$product_pricePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Product_prices.
     *     @param {product_priceCreateManyArgs} args - Arguments to create many Product_prices.
     *     @example
     *     // Create many Product_prices
     *     const product_price = await prisma.product_price.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends product_priceCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, product_priceCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Product_price.
     * @param {product_priceDeleteArgs} args - Arguments to delete one Product_price.
     * @example
     * // Delete one Product_price
     * const Product_price = await prisma.product_price.delete({
     *   where: {
     *     // ... filter to delete one Product_price
     *   }
     * })
     * 
    **/
    delete<T extends product_priceDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, product_priceDeleteArgs<ExtArgs>>
    ): Prisma__product_priceClient<$Result.GetResult<Prisma.$product_pricePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Product_price.
     * @param {product_priceUpdateArgs} args - Arguments to update one Product_price.
     * @example
     * // Update one Product_price
     * const product_price = await prisma.product_price.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends product_priceUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, product_priceUpdateArgs<ExtArgs>>
    ): Prisma__product_priceClient<$Result.GetResult<Prisma.$product_pricePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Product_prices.
     * @param {product_priceDeleteManyArgs} args - Arguments to filter Product_prices to delete.
     * @example
     * // Delete a few Product_prices
     * const { count } = await prisma.product_price.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends product_priceDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, product_priceDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Product_prices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {product_priceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Product_prices
     * const product_price = await prisma.product_price.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends product_priceUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, product_priceUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Product_price.
     * @param {product_priceUpsertArgs} args - Arguments to update or create a Product_price.
     * @example
     * // Update or create a Product_price
     * const product_price = await prisma.product_price.upsert({
     *   create: {
     *     // ... data to create a Product_price
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product_price we want to update
     *   }
     * })
    **/
    upsert<T extends product_priceUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, product_priceUpsertArgs<ExtArgs>>
    ): Prisma__product_priceClient<$Result.GetResult<Prisma.$product_pricePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Product_prices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {product_priceCountArgs} args - Arguments to filter Product_prices to count.
     * @example
     * // Count the number of Product_prices
     * const count = await prisma.product_price.count({
     *   where: {
     *     // ... the filter for the Product_prices we want to count
     *   }
     * })
    **/
    count<T extends product_priceCountArgs>(
      args?: Subset<T, product_priceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Product_priceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product_price.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Product_priceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Product_priceAggregateArgs>(args: Subset<T, Product_priceAggregateArgs>): Prisma.PrismaPromise<GetProduct_priceAggregateType<T>>

    /**
     * Group by Product_price.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {product_priceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends product_priceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: product_priceGroupByArgs['orderBy'] }
        : { orderBy?: product_priceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, product_priceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProduct_priceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the product_price model
   */
  readonly fields: product_priceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for product_price.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__product_priceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    product<T extends productDefaultArgs<ExtArgs> = {}>(args?: Subset<T, productDefaultArgs<ExtArgs>>): Prisma__productClient<$Result.GetResult<Prisma.$productPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    product_option_first<T extends product_price$product_option_firstArgs<ExtArgs> = {}>(args?: Subset<T, product_price$product_option_firstArgs<ExtArgs>>): Prisma__product_option_firstClient<$Result.GetResult<Prisma.$product_option_firstPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    product_option_second<T extends product_price$product_option_secondArgs<ExtArgs> = {}>(args?: Subset<T, product_price$product_option_secondArgs<ExtArgs>>): Prisma__product_option_secondClient<$Result.GetResult<Prisma.$product_option_secondPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    cart<T extends product_price$cartArgs<ExtArgs> = {}>(args?: Subset<T, product_price$cartArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$cartPayload<ExtArgs>, T, 'findMany'> | Null>;

    order_product<T extends product_price$order_productArgs<ExtArgs> = {}>(args?: Subset<T, product_price$order_productArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$order_productPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the product_price model
   */ 
  interface product_priceFieldRefs {
    readonly id: FieldRef<"product_price", 'Int'>
    readonly productId: FieldRef<"product_price", 'Int'>
    readonly product_option_firstId: FieldRef<"product_price", 'Int'>
    readonly product_option_secondId: FieldRef<"product_price", 'Int'>
    readonly price: FieldRef<"product_price", 'Float'>
    readonly sku: FieldRef<"product_price", 'String'>
    readonly isWholesale: FieldRef<"product_price", 'Boolean'>
  }
    

  // Custom InputTypes

  /**
   * product_price findUnique
   */
  export type product_priceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_price
     */
    select?: product_priceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: product_priceInclude<ExtArgs> | null
    /**
     * Filter, which product_price to fetch.
     */
    where: product_priceWhereUniqueInput
  }


  /**
   * product_price findUniqueOrThrow
   */
  export type product_priceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_price
     */
    select?: product_priceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: product_priceInclude<ExtArgs> | null
    /**
     * Filter, which product_price to fetch.
     */
    where: product_priceWhereUniqueInput
  }


  /**
   * product_price findFirst
   */
  export type product_priceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_price
     */
    select?: product_priceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: product_priceInclude<ExtArgs> | null
    /**
     * Filter, which product_price to fetch.
     */
    where?: product_priceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of product_prices to fetch.
     */
    orderBy?: product_priceOrderByWithRelationInput | product_priceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for product_prices.
     */
    cursor?: product_priceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` product_prices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` product_prices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of product_prices.
     */
    distinct?: Product_priceScalarFieldEnum | Product_priceScalarFieldEnum[]
  }


  /**
   * product_price findFirstOrThrow
   */
  export type product_priceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_price
     */
    select?: product_priceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: product_priceInclude<ExtArgs> | null
    /**
     * Filter, which product_price to fetch.
     */
    where?: product_priceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of product_prices to fetch.
     */
    orderBy?: product_priceOrderByWithRelationInput | product_priceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for product_prices.
     */
    cursor?: product_priceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` product_prices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` product_prices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of product_prices.
     */
    distinct?: Product_priceScalarFieldEnum | Product_priceScalarFieldEnum[]
  }


  /**
   * product_price findMany
   */
  export type product_priceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_price
     */
    select?: product_priceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: product_priceInclude<ExtArgs> | null
    /**
     * Filter, which product_prices to fetch.
     */
    where?: product_priceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of product_prices to fetch.
     */
    orderBy?: product_priceOrderByWithRelationInput | product_priceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing product_prices.
     */
    cursor?: product_priceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` product_prices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` product_prices.
     */
    skip?: number
    distinct?: Product_priceScalarFieldEnum | Product_priceScalarFieldEnum[]
  }


  /**
   * product_price create
   */
  export type product_priceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_price
     */
    select?: product_priceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: product_priceInclude<ExtArgs> | null
    /**
     * The data needed to create a product_price.
     */
    data: XOR<product_priceCreateInput, product_priceUncheckedCreateInput>
  }


  /**
   * product_price createMany
   */
  export type product_priceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many product_prices.
     */
    data: product_priceCreateManyInput | product_priceCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * product_price update
   */
  export type product_priceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_price
     */
    select?: product_priceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: product_priceInclude<ExtArgs> | null
    /**
     * The data needed to update a product_price.
     */
    data: XOR<product_priceUpdateInput, product_priceUncheckedUpdateInput>
    /**
     * Choose, which product_price to update.
     */
    where: product_priceWhereUniqueInput
  }


  /**
   * product_price updateMany
   */
  export type product_priceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update product_prices.
     */
    data: XOR<product_priceUpdateManyMutationInput, product_priceUncheckedUpdateManyInput>
    /**
     * Filter which product_prices to update
     */
    where?: product_priceWhereInput
  }


  /**
   * product_price upsert
   */
  export type product_priceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_price
     */
    select?: product_priceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: product_priceInclude<ExtArgs> | null
    /**
     * The filter to search for the product_price to update in case it exists.
     */
    where: product_priceWhereUniqueInput
    /**
     * In case the product_price found by the `where` argument doesn't exist, create a new product_price with this data.
     */
    create: XOR<product_priceCreateInput, product_priceUncheckedCreateInput>
    /**
     * In case the product_price was found with the provided `where` argument, update it with this data.
     */
    update: XOR<product_priceUpdateInput, product_priceUncheckedUpdateInput>
  }


  /**
   * product_price delete
   */
  export type product_priceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_price
     */
    select?: product_priceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: product_priceInclude<ExtArgs> | null
    /**
     * Filter which product_price to delete.
     */
    where: product_priceWhereUniqueInput
  }


  /**
   * product_price deleteMany
   */
  export type product_priceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which product_prices to delete
     */
    where?: product_priceWhereInput
  }


  /**
   * product_price.product_option_first
   */
  export type product_price$product_option_firstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_option_first
     */
    select?: product_option_firstSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: product_option_firstInclude<ExtArgs> | null
    where?: product_option_firstWhereInput
  }


  /**
   * product_price.product_option_second
   */
  export type product_price$product_option_secondArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_option_second
     */
    select?: product_option_secondSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: product_option_secondInclude<ExtArgs> | null
    where?: product_option_secondWhereInput
  }


  /**
   * product_price.cart
   */
  export type product_price$cartArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cart
     */
    select?: cartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: cartInclude<ExtArgs> | null
    where?: cartWhereInput
    orderBy?: cartOrderByWithRelationInput | cartOrderByWithRelationInput[]
    cursor?: cartWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CartScalarFieldEnum | CartScalarFieldEnum[]
  }


  /**
   * product_price.order_product
   */
  export type product_price$order_productArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_product
     */
    select?: order_productSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: order_productInclude<ExtArgs> | null
    where?: order_productWhereInput
    orderBy?: order_productOrderByWithRelationInput | order_productOrderByWithRelationInput[]
    cursor?: order_productWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Order_productScalarFieldEnum | Order_productScalarFieldEnum[]
  }


  /**
   * product_price without action
   */
  export type product_priceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_price
     */
    select?: product_priceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: product_priceInclude<ExtArgs> | null
  }



  /**
   * Model product_detail
   */

  export type AggregateProduct_detail = {
    _count: Product_detailCountAggregateOutputType | null
    _avg: Product_detailAvgAggregateOutputType | null
    _sum: Product_detailSumAggregateOutputType | null
    _min: Product_detailMinAggregateOutputType | null
    _max: Product_detailMaxAggregateOutputType | null
  }

  export type Product_detailAvgAggregateOutputType = {
    id: number | null
    productId: number | null
  }

  export type Product_detailSumAggregateOutputType = {
    id: number | null
    productId: number | null
  }

  export type Product_detailMinAggregateOutputType = {
    id: number | null
    productId: number | null
    name: string | null
    details: string | null
    imagePath: string | null
    imageSrc: string | null
    videoPath: string | null
    videoSrc: string | null
    videoType: string | null
    link: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Product_detailMaxAggregateOutputType = {
    id: number | null
    productId: number | null
    name: string | null
    details: string | null
    imagePath: string | null
    imageSrc: string | null
    videoPath: string | null
    videoSrc: string | null
    videoType: string | null
    link: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Product_detailCountAggregateOutputType = {
    id: number
    productId: number
    name: number
    details: number
    imagePath: number
    imageSrc: number
    videoPath: number
    videoSrc: number
    videoType: number
    link: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Product_detailAvgAggregateInputType = {
    id?: true
    productId?: true
  }

  export type Product_detailSumAggregateInputType = {
    id?: true
    productId?: true
  }

  export type Product_detailMinAggregateInputType = {
    id?: true
    productId?: true
    name?: true
    details?: true
    imagePath?: true
    imageSrc?: true
    videoPath?: true
    videoSrc?: true
    videoType?: true
    link?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Product_detailMaxAggregateInputType = {
    id?: true
    productId?: true
    name?: true
    details?: true
    imagePath?: true
    imageSrc?: true
    videoPath?: true
    videoSrc?: true
    videoType?: true
    link?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Product_detailCountAggregateInputType = {
    id?: true
    productId?: true
    name?: true
    details?: true
    imagePath?: true
    imageSrc?: true
    videoPath?: true
    videoSrc?: true
    videoType?: true
    link?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Product_detailAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which product_detail to aggregate.
     */
    where?: product_detailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of product_details to fetch.
     */
    orderBy?: product_detailOrderByWithRelationInput | product_detailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: product_detailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` product_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` product_details.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned product_details
    **/
    _count?: true | Product_detailCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Product_detailAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Product_detailSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Product_detailMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Product_detailMaxAggregateInputType
  }

  export type GetProduct_detailAggregateType<T extends Product_detailAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct_detail]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct_detail[P]>
      : GetScalarType<T[P], AggregateProduct_detail[P]>
  }




  export type product_detailGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: product_detailWhereInput
    orderBy?: product_detailOrderByWithAggregationInput | product_detailOrderByWithAggregationInput[]
    by: Product_detailScalarFieldEnum[] | Product_detailScalarFieldEnum
    having?: product_detailScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Product_detailCountAggregateInputType | true
    _avg?: Product_detailAvgAggregateInputType
    _sum?: Product_detailSumAggregateInputType
    _min?: Product_detailMinAggregateInputType
    _max?: Product_detailMaxAggregateInputType
  }

  export type Product_detailGroupByOutputType = {
    id: number
    productId: number
    name: string
    details: string | null
    imagePath: string | null
    imageSrc: string | null
    videoPath: string | null
    videoSrc: string | null
    videoType: string | null
    link: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: Product_detailCountAggregateOutputType | null
    _avg: Product_detailAvgAggregateOutputType | null
    _sum: Product_detailSumAggregateOutputType | null
    _min: Product_detailMinAggregateOutputType | null
    _max: Product_detailMaxAggregateOutputType | null
  }

  type GetProduct_detailGroupByPayload<T extends product_detailGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Product_detailGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Product_detailGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Product_detailGroupByOutputType[P]>
            : GetScalarType<T[P], Product_detailGroupByOutputType[P]>
        }
      >
    >


  export type product_detailSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    name?: boolean
    details?: boolean
    imagePath?: boolean
    imageSrc?: boolean
    videoPath?: boolean
    videoSrc?: boolean
    videoType?: boolean
    link?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | productDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product_detail"]>

  export type product_detailSelectScalar = {
    id?: boolean
    productId?: boolean
    name?: boolean
    details?: boolean
    imagePath?: boolean
    imageSrc?: boolean
    videoPath?: boolean
    videoSrc?: boolean
    videoType?: boolean
    link?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type product_detailInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | productDefaultArgs<ExtArgs>
  }


  export type $product_detailPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "product_detail"
    objects: {
      product: Prisma.$productPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      productId: number
      name: string
      details: string | null
      imagePath: string | null
      imageSrc: string | null
      videoPath: string | null
      videoSrc: string | null
      videoType: string | null
      link: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["product_detail"]>
    composites: {}
  }


  type product_detailGetPayload<S extends boolean | null | undefined | product_detailDefaultArgs> = $Result.GetResult<Prisma.$product_detailPayload, S>

  type product_detailCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<product_detailFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Product_detailCountAggregateInputType | true
    }

  export interface product_detailDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['product_detail'], meta: { name: 'product_detail' } }
    /**
     * Find zero or one Product_detail that matches the filter.
     * @param {product_detailFindUniqueArgs} args - Arguments to find a Product_detail
     * @example
     * // Get one Product_detail
     * const product_detail = await prisma.product_detail.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends product_detailFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, product_detailFindUniqueArgs<ExtArgs>>
    ): Prisma__product_detailClient<$Result.GetResult<Prisma.$product_detailPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Product_detail that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {product_detailFindUniqueOrThrowArgs} args - Arguments to find a Product_detail
     * @example
     * // Get one Product_detail
     * const product_detail = await prisma.product_detail.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends product_detailFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, product_detailFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__product_detailClient<$Result.GetResult<Prisma.$product_detailPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Product_detail that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {product_detailFindFirstArgs} args - Arguments to find a Product_detail
     * @example
     * // Get one Product_detail
     * const product_detail = await prisma.product_detail.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends product_detailFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, product_detailFindFirstArgs<ExtArgs>>
    ): Prisma__product_detailClient<$Result.GetResult<Prisma.$product_detailPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Product_detail that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {product_detailFindFirstOrThrowArgs} args - Arguments to find a Product_detail
     * @example
     * // Get one Product_detail
     * const product_detail = await prisma.product_detail.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends product_detailFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, product_detailFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__product_detailClient<$Result.GetResult<Prisma.$product_detailPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Product_details that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {product_detailFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Product_details
     * const product_details = await prisma.product_detail.findMany()
     * 
     * // Get first 10 Product_details
     * const product_details = await prisma.product_detail.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const product_detailWithIdOnly = await prisma.product_detail.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends product_detailFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, product_detailFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$product_detailPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Product_detail.
     * @param {product_detailCreateArgs} args - Arguments to create a Product_detail.
     * @example
     * // Create one Product_detail
     * const Product_detail = await prisma.product_detail.create({
     *   data: {
     *     // ... data to create a Product_detail
     *   }
     * })
     * 
    **/
    create<T extends product_detailCreateArgs<ExtArgs>>(
      args: SelectSubset<T, product_detailCreateArgs<ExtArgs>>
    ): Prisma__product_detailClient<$Result.GetResult<Prisma.$product_detailPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Product_details.
     *     @param {product_detailCreateManyArgs} args - Arguments to create many Product_details.
     *     @example
     *     // Create many Product_details
     *     const product_detail = await prisma.product_detail.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends product_detailCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, product_detailCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Product_detail.
     * @param {product_detailDeleteArgs} args - Arguments to delete one Product_detail.
     * @example
     * // Delete one Product_detail
     * const Product_detail = await prisma.product_detail.delete({
     *   where: {
     *     // ... filter to delete one Product_detail
     *   }
     * })
     * 
    **/
    delete<T extends product_detailDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, product_detailDeleteArgs<ExtArgs>>
    ): Prisma__product_detailClient<$Result.GetResult<Prisma.$product_detailPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Product_detail.
     * @param {product_detailUpdateArgs} args - Arguments to update one Product_detail.
     * @example
     * // Update one Product_detail
     * const product_detail = await prisma.product_detail.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends product_detailUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, product_detailUpdateArgs<ExtArgs>>
    ): Prisma__product_detailClient<$Result.GetResult<Prisma.$product_detailPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Product_details.
     * @param {product_detailDeleteManyArgs} args - Arguments to filter Product_details to delete.
     * @example
     * // Delete a few Product_details
     * const { count } = await prisma.product_detail.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends product_detailDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, product_detailDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Product_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {product_detailUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Product_details
     * const product_detail = await prisma.product_detail.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends product_detailUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, product_detailUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Product_detail.
     * @param {product_detailUpsertArgs} args - Arguments to update or create a Product_detail.
     * @example
     * // Update or create a Product_detail
     * const product_detail = await prisma.product_detail.upsert({
     *   create: {
     *     // ... data to create a Product_detail
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product_detail we want to update
     *   }
     * })
    **/
    upsert<T extends product_detailUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, product_detailUpsertArgs<ExtArgs>>
    ): Prisma__product_detailClient<$Result.GetResult<Prisma.$product_detailPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Product_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {product_detailCountArgs} args - Arguments to filter Product_details to count.
     * @example
     * // Count the number of Product_details
     * const count = await prisma.product_detail.count({
     *   where: {
     *     // ... the filter for the Product_details we want to count
     *   }
     * })
    **/
    count<T extends product_detailCountArgs>(
      args?: Subset<T, product_detailCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Product_detailCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product_detail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Product_detailAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Product_detailAggregateArgs>(args: Subset<T, Product_detailAggregateArgs>): Prisma.PrismaPromise<GetProduct_detailAggregateType<T>>

    /**
     * Group by Product_detail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {product_detailGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends product_detailGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: product_detailGroupByArgs['orderBy'] }
        : { orderBy?: product_detailGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, product_detailGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProduct_detailGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the product_detail model
   */
  readonly fields: product_detailFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for product_detail.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__product_detailClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    product<T extends productDefaultArgs<ExtArgs> = {}>(args?: Subset<T, productDefaultArgs<ExtArgs>>): Prisma__productClient<$Result.GetResult<Prisma.$productPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the product_detail model
   */ 
  interface product_detailFieldRefs {
    readonly id: FieldRef<"product_detail", 'Int'>
    readonly productId: FieldRef<"product_detail", 'Int'>
    readonly name: FieldRef<"product_detail", 'String'>
    readonly details: FieldRef<"product_detail", 'String'>
    readonly imagePath: FieldRef<"product_detail", 'String'>
    readonly imageSrc: FieldRef<"product_detail", 'String'>
    readonly videoPath: FieldRef<"product_detail", 'String'>
    readonly videoSrc: FieldRef<"product_detail", 'String'>
    readonly videoType: FieldRef<"product_detail", 'String'>
    readonly link: FieldRef<"product_detail", 'String'>
    readonly isActive: FieldRef<"product_detail", 'Boolean'>
    readonly createdAt: FieldRef<"product_detail", 'DateTime'>
    readonly updatedAt: FieldRef<"product_detail", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * product_detail findUnique
   */
  export type product_detailFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_detail
     */
    select?: product_detailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: product_detailInclude<ExtArgs> | null
    /**
     * Filter, which product_detail to fetch.
     */
    where: product_detailWhereUniqueInput
  }


  /**
   * product_detail findUniqueOrThrow
   */
  export type product_detailFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_detail
     */
    select?: product_detailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: product_detailInclude<ExtArgs> | null
    /**
     * Filter, which product_detail to fetch.
     */
    where: product_detailWhereUniqueInput
  }


  /**
   * product_detail findFirst
   */
  export type product_detailFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_detail
     */
    select?: product_detailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: product_detailInclude<ExtArgs> | null
    /**
     * Filter, which product_detail to fetch.
     */
    where?: product_detailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of product_details to fetch.
     */
    orderBy?: product_detailOrderByWithRelationInput | product_detailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for product_details.
     */
    cursor?: product_detailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` product_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` product_details.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of product_details.
     */
    distinct?: Product_detailScalarFieldEnum | Product_detailScalarFieldEnum[]
  }


  /**
   * product_detail findFirstOrThrow
   */
  export type product_detailFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_detail
     */
    select?: product_detailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: product_detailInclude<ExtArgs> | null
    /**
     * Filter, which product_detail to fetch.
     */
    where?: product_detailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of product_details to fetch.
     */
    orderBy?: product_detailOrderByWithRelationInput | product_detailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for product_details.
     */
    cursor?: product_detailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` product_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` product_details.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of product_details.
     */
    distinct?: Product_detailScalarFieldEnum | Product_detailScalarFieldEnum[]
  }


  /**
   * product_detail findMany
   */
  export type product_detailFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_detail
     */
    select?: product_detailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: product_detailInclude<ExtArgs> | null
    /**
     * Filter, which product_details to fetch.
     */
    where?: product_detailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of product_details to fetch.
     */
    orderBy?: product_detailOrderByWithRelationInput | product_detailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing product_details.
     */
    cursor?: product_detailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` product_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` product_details.
     */
    skip?: number
    distinct?: Product_detailScalarFieldEnum | Product_detailScalarFieldEnum[]
  }


  /**
   * product_detail create
   */
  export type product_detailCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_detail
     */
    select?: product_detailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: product_detailInclude<ExtArgs> | null
    /**
     * The data needed to create a product_detail.
     */
    data: XOR<product_detailCreateInput, product_detailUncheckedCreateInput>
  }


  /**
   * product_detail createMany
   */
  export type product_detailCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many product_details.
     */
    data: product_detailCreateManyInput | product_detailCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * product_detail update
   */
  export type product_detailUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_detail
     */
    select?: product_detailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: product_detailInclude<ExtArgs> | null
    /**
     * The data needed to update a product_detail.
     */
    data: XOR<product_detailUpdateInput, product_detailUncheckedUpdateInput>
    /**
     * Choose, which product_detail to update.
     */
    where: product_detailWhereUniqueInput
  }


  /**
   * product_detail updateMany
   */
  export type product_detailUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update product_details.
     */
    data: XOR<product_detailUpdateManyMutationInput, product_detailUncheckedUpdateManyInput>
    /**
     * Filter which product_details to update
     */
    where?: product_detailWhereInput
  }


  /**
   * product_detail upsert
   */
  export type product_detailUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_detail
     */
    select?: product_detailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: product_detailInclude<ExtArgs> | null
    /**
     * The filter to search for the product_detail to update in case it exists.
     */
    where: product_detailWhereUniqueInput
    /**
     * In case the product_detail found by the `where` argument doesn't exist, create a new product_detail with this data.
     */
    create: XOR<product_detailCreateInput, product_detailUncheckedCreateInput>
    /**
     * In case the product_detail was found with the provided `where` argument, update it with this data.
     */
    update: XOR<product_detailUpdateInput, product_detailUncheckedUpdateInput>
  }


  /**
   * product_detail delete
   */
  export type product_detailDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_detail
     */
    select?: product_detailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: product_detailInclude<ExtArgs> | null
    /**
     * Filter which product_detail to delete.
     */
    where: product_detailWhereUniqueInput
  }


  /**
   * product_detail deleteMany
   */
  export type product_detailDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which product_details to delete
     */
    where?: product_detailWhereInput
  }


  /**
   * product_detail without action
   */
  export type product_detailDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_detail
     */
    select?: product_detailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: product_detailInclude<ExtArgs> | null
  }



  /**
   * Model product_image
   */

  export type AggregateProduct_image = {
    _count: Product_imageCountAggregateOutputType | null
    _avg: Product_imageAvgAggregateOutputType | null
    _sum: Product_imageSumAggregateOutputType | null
    _min: Product_imageMinAggregateOutputType | null
    _max: Product_imageMaxAggregateOutputType | null
  }

  export type Product_imageAvgAggregateOutputType = {
    id: number | null
    sequence: number | null
    productId: number | null
  }

  export type Product_imageSumAggregateOutputType = {
    id: number | null
    sequence: number | null
    productId: number | null
  }

  export type Product_imageMinAggregateOutputType = {
    id: number | null
    name: string | null
    path: string | null
    src: string | null
    sequence: number | null
    productId: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Product_imageMaxAggregateOutputType = {
    id: number | null
    name: string | null
    path: string | null
    src: string | null
    sequence: number | null
    productId: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Product_imageCountAggregateOutputType = {
    id: number
    name: number
    path: number
    src: number
    sequence: number
    productId: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Product_imageAvgAggregateInputType = {
    id?: true
    sequence?: true
    productId?: true
  }

  export type Product_imageSumAggregateInputType = {
    id?: true
    sequence?: true
    productId?: true
  }

  export type Product_imageMinAggregateInputType = {
    id?: true
    name?: true
    path?: true
    src?: true
    sequence?: true
    productId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Product_imageMaxAggregateInputType = {
    id?: true
    name?: true
    path?: true
    src?: true
    sequence?: true
    productId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Product_imageCountAggregateInputType = {
    id?: true
    name?: true
    path?: true
    src?: true
    sequence?: true
    productId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Product_imageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which product_image to aggregate.
     */
    where?: product_imageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of product_images to fetch.
     */
    orderBy?: product_imageOrderByWithRelationInput | product_imageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: product_imageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` product_images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` product_images.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned product_images
    **/
    _count?: true | Product_imageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Product_imageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Product_imageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Product_imageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Product_imageMaxAggregateInputType
  }

  export type GetProduct_imageAggregateType<T extends Product_imageAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct_image]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct_image[P]>
      : GetScalarType<T[P], AggregateProduct_image[P]>
  }




  export type product_imageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: product_imageWhereInput
    orderBy?: product_imageOrderByWithAggregationInput | product_imageOrderByWithAggregationInput[]
    by: Product_imageScalarFieldEnum[] | Product_imageScalarFieldEnum
    having?: product_imageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Product_imageCountAggregateInputType | true
    _avg?: Product_imageAvgAggregateInputType
    _sum?: Product_imageSumAggregateInputType
    _min?: Product_imageMinAggregateInputType
    _max?: Product_imageMaxAggregateInputType
  }

  export type Product_imageGroupByOutputType = {
    id: number
    name: string
    path: string
    src: string
    sequence: number
    productId: number
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: Product_imageCountAggregateOutputType | null
    _avg: Product_imageAvgAggregateOutputType | null
    _sum: Product_imageSumAggregateOutputType | null
    _min: Product_imageMinAggregateOutputType | null
    _max: Product_imageMaxAggregateOutputType | null
  }

  type GetProduct_imageGroupByPayload<T extends product_imageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Product_imageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Product_imageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Product_imageGroupByOutputType[P]>
            : GetScalarType<T[P], Product_imageGroupByOutputType[P]>
        }
      >
    >


  export type product_imageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    path?: boolean
    src?: boolean
    sequence?: boolean
    productId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | productDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product_image"]>

  export type product_imageSelectScalar = {
    id?: boolean
    name?: boolean
    path?: boolean
    src?: boolean
    sequence?: boolean
    productId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type product_imageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | productDefaultArgs<ExtArgs>
  }


  export type $product_imagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "product_image"
    objects: {
      product: Prisma.$productPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      path: string
      src: string
      sequence: number
      productId: number
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["product_image"]>
    composites: {}
  }


  type product_imageGetPayload<S extends boolean | null | undefined | product_imageDefaultArgs> = $Result.GetResult<Prisma.$product_imagePayload, S>

  type product_imageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<product_imageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Product_imageCountAggregateInputType | true
    }

  export interface product_imageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['product_image'], meta: { name: 'product_image' } }
    /**
     * Find zero or one Product_image that matches the filter.
     * @param {product_imageFindUniqueArgs} args - Arguments to find a Product_image
     * @example
     * // Get one Product_image
     * const product_image = await prisma.product_image.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends product_imageFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, product_imageFindUniqueArgs<ExtArgs>>
    ): Prisma__product_imageClient<$Result.GetResult<Prisma.$product_imagePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Product_image that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {product_imageFindUniqueOrThrowArgs} args - Arguments to find a Product_image
     * @example
     * // Get one Product_image
     * const product_image = await prisma.product_image.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends product_imageFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, product_imageFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__product_imageClient<$Result.GetResult<Prisma.$product_imagePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Product_image that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {product_imageFindFirstArgs} args - Arguments to find a Product_image
     * @example
     * // Get one Product_image
     * const product_image = await prisma.product_image.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends product_imageFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, product_imageFindFirstArgs<ExtArgs>>
    ): Prisma__product_imageClient<$Result.GetResult<Prisma.$product_imagePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Product_image that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {product_imageFindFirstOrThrowArgs} args - Arguments to find a Product_image
     * @example
     * // Get one Product_image
     * const product_image = await prisma.product_image.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends product_imageFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, product_imageFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__product_imageClient<$Result.GetResult<Prisma.$product_imagePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Product_images that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {product_imageFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Product_images
     * const product_images = await prisma.product_image.findMany()
     * 
     * // Get first 10 Product_images
     * const product_images = await prisma.product_image.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const product_imageWithIdOnly = await prisma.product_image.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends product_imageFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, product_imageFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$product_imagePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Product_image.
     * @param {product_imageCreateArgs} args - Arguments to create a Product_image.
     * @example
     * // Create one Product_image
     * const Product_image = await prisma.product_image.create({
     *   data: {
     *     // ... data to create a Product_image
     *   }
     * })
     * 
    **/
    create<T extends product_imageCreateArgs<ExtArgs>>(
      args: SelectSubset<T, product_imageCreateArgs<ExtArgs>>
    ): Prisma__product_imageClient<$Result.GetResult<Prisma.$product_imagePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Product_images.
     *     @param {product_imageCreateManyArgs} args - Arguments to create many Product_images.
     *     @example
     *     // Create many Product_images
     *     const product_image = await prisma.product_image.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends product_imageCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, product_imageCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Product_image.
     * @param {product_imageDeleteArgs} args - Arguments to delete one Product_image.
     * @example
     * // Delete one Product_image
     * const Product_image = await prisma.product_image.delete({
     *   where: {
     *     // ... filter to delete one Product_image
     *   }
     * })
     * 
    **/
    delete<T extends product_imageDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, product_imageDeleteArgs<ExtArgs>>
    ): Prisma__product_imageClient<$Result.GetResult<Prisma.$product_imagePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Product_image.
     * @param {product_imageUpdateArgs} args - Arguments to update one Product_image.
     * @example
     * // Update one Product_image
     * const product_image = await prisma.product_image.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends product_imageUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, product_imageUpdateArgs<ExtArgs>>
    ): Prisma__product_imageClient<$Result.GetResult<Prisma.$product_imagePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Product_images.
     * @param {product_imageDeleteManyArgs} args - Arguments to filter Product_images to delete.
     * @example
     * // Delete a few Product_images
     * const { count } = await prisma.product_image.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends product_imageDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, product_imageDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Product_images.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {product_imageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Product_images
     * const product_image = await prisma.product_image.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends product_imageUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, product_imageUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Product_image.
     * @param {product_imageUpsertArgs} args - Arguments to update or create a Product_image.
     * @example
     * // Update or create a Product_image
     * const product_image = await prisma.product_image.upsert({
     *   create: {
     *     // ... data to create a Product_image
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product_image we want to update
     *   }
     * })
    **/
    upsert<T extends product_imageUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, product_imageUpsertArgs<ExtArgs>>
    ): Prisma__product_imageClient<$Result.GetResult<Prisma.$product_imagePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Product_images.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {product_imageCountArgs} args - Arguments to filter Product_images to count.
     * @example
     * // Count the number of Product_images
     * const count = await prisma.product_image.count({
     *   where: {
     *     // ... the filter for the Product_images we want to count
     *   }
     * })
    **/
    count<T extends product_imageCountArgs>(
      args?: Subset<T, product_imageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Product_imageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product_image.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Product_imageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Product_imageAggregateArgs>(args: Subset<T, Product_imageAggregateArgs>): Prisma.PrismaPromise<GetProduct_imageAggregateType<T>>

    /**
     * Group by Product_image.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {product_imageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends product_imageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: product_imageGroupByArgs['orderBy'] }
        : { orderBy?: product_imageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, product_imageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProduct_imageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the product_image model
   */
  readonly fields: product_imageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for product_image.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__product_imageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    product<T extends productDefaultArgs<ExtArgs> = {}>(args?: Subset<T, productDefaultArgs<ExtArgs>>): Prisma__productClient<$Result.GetResult<Prisma.$productPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the product_image model
   */ 
  interface product_imageFieldRefs {
    readonly id: FieldRef<"product_image", 'Int'>
    readonly name: FieldRef<"product_image", 'String'>
    readonly path: FieldRef<"product_image", 'String'>
    readonly src: FieldRef<"product_image", 'String'>
    readonly sequence: FieldRef<"product_image", 'Int'>
    readonly productId: FieldRef<"product_image", 'Int'>
    readonly isActive: FieldRef<"product_image", 'Boolean'>
    readonly createdAt: FieldRef<"product_image", 'DateTime'>
    readonly updatedAt: FieldRef<"product_image", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * product_image findUnique
   */
  export type product_imageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_image
     */
    select?: product_imageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: product_imageInclude<ExtArgs> | null
    /**
     * Filter, which product_image to fetch.
     */
    where: product_imageWhereUniqueInput
  }


  /**
   * product_image findUniqueOrThrow
   */
  export type product_imageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_image
     */
    select?: product_imageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: product_imageInclude<ExtArgs> | null
    /**
     * Filter, which product_image to fetch.
     */
    where: product_imageWhereUniqueInput
  }


  /**
   * product_image findFirst
   */
  export type product_imageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_image
     */
    select?: product_imageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: product_imageInclude<ExtArgs> | null
    /**
     * Filter, which product_image to fetch.
     */
    where?: product_imageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of product_images to fetch.
     */
    orderBy?: product_imageOrderByWithRelationInput | product_imageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for product_images.
     */
    cursor?: product_imageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` product_images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` product_images.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of product_images.
     */
    distinct?: Product_imageScalarFieldEnum | Product_imageScalarFieldEnum[]
  }


  /**
   * product_image findFirstOrThrow
   */
  export type product_imageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_image
     */
    select?: product_imageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: product_imageInclude<ExtArgs> | null
    /**
     * Filter, which product_image to fetch.
     */
    where?: product_imageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of product_images to fetch.
     */
    orderBy?: product_imageOrderByWithRelationInput | product_imageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for product_images.
     */
    cursor?: product_imageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` product_images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` product_images.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of product_images.
     */
    distinct?: Product_imageScalarFieldEnum | Product_imageScalarFieldEnum[]
  }


  /**
   * product_image findMany
   */
  export type product_imageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_image
     */
    select?: product_imageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: product_imageInclude<ExtArgs> | null
    /**
     * Filter, which product_images to fetch.
     */
    where?: product_imageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of product_images to fetch.
     */
    orderBy?: product_imageOrderByWithRelationInput | product_imageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing product_images.
     */
    cursor?: product_imageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` product_images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` product_images.
     */
    skip?: number
    distinct?: Product_imageScalarFieldEnum | Product_imageScalarFieldEnum[]
  }


  /**
   * product_image create
   */
  export type product_imageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_image
     */
    select?: product_imageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: product_imageInclude<ExtArgs> | null
    /**
     * The data needed to create a product_image.
     */
    data: XOR<product_imageCreateInput, product_imageUncheckedCreateInput>
  }


  /**
   * product_image createMany
   */
  export type product_imageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many product_images.
     */
    data: product_imageCreateManyInput | product_imageCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * product_image update
   */
  export type product_imageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_image
     */
    select?: product_imageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: product_imageInclude<ExtArgs> | null
    /**
     * The data needed to update a product_image.
     */
    data: XOR<product_imageUpdateInput, product_imageUncheckedUpdateInput>
    /**
     * Choose, which product_image to update.
     */
    where: product_imageWhereUniqueInput
  }


  /**
   * product_image updateMany
   */
  export type product_imageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update product_images.
     */
    data: XOR<product_imageUpdateManyMutationInput, product_imageUncheckedUpdateManyInput>
    /**
     * Filter which product_images to update
     */
    where?: product_imageWhereInput
  }


  /**
   * product_image upsert
   */
  export type product_imageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_image
     */
    select?: product_imageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: product_imageInclude<ExtArgs> | null
    /**
     * The filter to search for the product_image to update in case it exists.
     */
    where: product_imageWhereUniqueInput
    /**
     * In case the product_image found by the `where` argument doesn't exist, create a new product_image with this data.
     */
    create: XOR<product_imageCreateInput, product_imageUncheckedCreateInput>
    /**
     * In case the product_image was found with the provided `where` argument, update it with this data.
     */
    update: XOR<product_imageUpdateInput, product_imageUncheckedUpdateInput>
  }


  /**
   * product_image delete
   */
  export type product_imageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_image
     */
    select?: product_imageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: product_imageInclude<ExtArgs> | null
    /**
     * Filter which product_image to delete.
     */
    where: product_imageWhereUniqueInput
  }


  /**
   * product_image deleteMany
   */
  export type product_imageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which product_images to delete
     */
    where?: product_imageWhereInput
  }


  /**
   * product_image without action
   */
  export type product_imageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_image
     */
    select?: product_imageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: product_imageInclude<ExtArgs> | null
  }



  /**
   * Model product_spec
   */

  export type AggregateProduct_spec = {
    _count: Product_specCountAggregateOutputType | null
    _avg: Product_specAvgAggregateOutputType | null
    _sum: Product_specSumAggregateOutputType | null
    _min: Product_specMinAggregateOutputType | null
    _max: Product_specMaxAggregateOutputType | null
  }

  export type Product_specAvgAggregateOutputType = {
    id: number | null
    productId: number | null
  }

  export type Product_specSumAggregateOutputType = {
    id: number | null
    productId: number | null
  }

  export type Product_specMinAggregateOutputType = {
    id: number | null
    name: string | null
    productId: number | null
  }

  export type Product_specMaxAggregateOutputType = {
    id: number | null
    name: string | null
    productId: number | null
  }

  export type Product_specCountAggregateOutputType = {
    id: number
    name: number
    data: number
    productId: number
    _all: number
  }


  export type Product_specAvgAggregateInputType = {
    id?: true
    productId?: true
  }

  export type Product_specSumAggregateInputType = {
    id?: true
    productId?: true
  }

  export type Product_specMinAggregateInputType = {
    id?: true
    name?: true
    productId?: true
  }

  export type Product_specMaxAggregateInputType = {
    id?: true
    name?: true
    productId?: true
  }

  export type Product_specCountAggregateInputType = {
    id?: true
    name?: true
    data?: true
    productId?: true
    _all?: true
  }

  export type Product_specAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which product_spec to aggregate.
     */
    where?: product_specWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of product_specs to fetch.
     */
    orderBy?: product_specOrderByWithRelationInput | product_specOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: product_specWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` product_specs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` product_specs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned product_specs
    **/
    _count?: true | Product_specCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Product_specAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Product_specSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Product_specMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Product_specMaxAggregateInputType
  }

  export type GetProduct_specAggregateType<T extends Product_specAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct_spec]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct_spec[P]>
      : GetScalarType<T[P], AggregateProduct_spec[P]>
  }




  export type product_specGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: product_specWhereInput
    orderBy?: product_specOrderByWithAggregationInput | product_specOrderByWithAggregationInput[]
    by: Product_specScalarFieldEnum[] | Product_specScalarFieldEnum
    having?: product_specScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Product_specCountAggregateInputType | true
    _avg?: Product_specAvgAggregateInputType
    _sum?: Product_specSumAggregateInputType
    _min?: Product_specMinAggregateInputType
    _max?: Product_specMaxAggregateInputType
  }

  export type Product_specGroupByOutputType = {
    id: number
    name: string
    data: JsonValue
    productId: number
    _count: Product_specCountAggregateOutputType | null
    _avg: Product_specAvgAggregateOutputType | null
    _sum: Product_specSumAggregateOutputType | null
    _min: Product_specMinAggregateOutputType | null
    _max: Product_specMaxAggregateOutputType | null
  }

  type GetProduct_specGroupByPayload<T extends product_specGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Product_specGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Product_specGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Product_specGroupByOutputType[P]>
            : GetScalarType<T[P], Product_specGroupByOutputType[P]>
        }
      >
    >


  export type product_specSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    data?: boolean
    productId?: boolean
    product?: boolean | productDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product_spec"]>

  export type product_specSelectScalar = {
    id?: boolean
    name?: boolean
    data?: boolean
    productId?: boolean
  }

  export type product_specInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | productDefaultArgs<ExtArgs>
  }


  export type $product_specPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "product_spec"
    objects: {
      product: Prisma.$productPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      data: Prisma.JsonValue
      productId: number
    }, ExtArgs["result"]["product_spec"]>
    composites: {}
  }


  type product_specGetPayload<S extends boolean | null | undefined | product_specDefaultArgs> = $Result.GetResult<Prisma.$product_specPayload, S>

  type product_specCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<product_specFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Product_specCountAggregateInputType | true
    }

  export interface product_specDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['product_spec'], meta: { name: 'product_spec' } }
    /**
     * Find zero or one Product_spec that matches the filter.
     * @param {product_specFindUniqueArgs} args - Arguments to find a Product_spec
     * @example
     * // Get one Product_spec
     * const product_spec = await prisma.product_spec.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends product_specFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, product_specFindUniqueArgs<ExtArgs>>
    ): Prisma__product_specClient<$Result.GetResult<Prisma.$product_specPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Product_spec that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {product_specFindUniqueOrThrowArgs} args - Arguments to find a Product_spec
     * @example
     * // Get one Product_spec
     * const product_spec = await prisma.product_spec.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends product_specFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, product_specFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__product_specClient<$Result.GetResult<Prisma.$product_specPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Product_spec that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {product_specFindFirstArgs} args - Arguments to find a Product_spec
     * @example
     * // Get one Product_spec
     * const product_spec = await prisma.product_spec.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends product_specFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, product_specFindFirstArgs<ExtArgs>>
    ): Prisma__product_specClient<$Result.GetResult<Prisma.$product_specPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Product_spec that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {product_specFindFirstOrThrowArgs} args - Arguments to find a Product_spec
     * @example
     * // Get one Product_spec
     * const product_spec = await prisma.product_spec.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends product_specFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, product_specFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__product_specClient<$Result.GetResult<Prisma.$product_specPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Product_specs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {product_specFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Product_specs
     * const product_specs = await prisma.product_spec.findMany()
     * 
     * // Get first 10 Product_specs
     * const product_specs = await prisma.product_spec.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const product_specWithIdOnly = await prisma.product_spec.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends product_specFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, product_specFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$product_specPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Product_spec.
     * @param {product_specCreateArgs} args - Arguments to create a Product_spec.
     * @example
     * // Create one Product_spec
     * const Product_spec = await prisma.product_spec.create({
     *   data: {
     *     // ... data to create a Product_spec
     *   }
     * })
     * 
    **/
    create<T extends product_specCreateArgs<ExtArgs>>(
      args: SelectSubset<T, product_specCreateArgs<ExtArgs>>
    ): Prisma__product_specClient<$Result.GetResult<Prisma.$product_specPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Product_specs.
     *     @param {product_specCreateManyArgs} args - Arguments to create many Product_specs.
     *     @example
     *     // Create many Product_specs
     *     const product_spec = await prisma.product_spec.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends product_specCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, product_specCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Product_spec.
     * @param {product_specDeleteArgs} args - Arguments to delete one Product_spec.
     * @example
     * // Delete one Product_spec
     * const Product_spec = await prisma.product_spec.delete({
     *   where: {
     *     // ... filter to delete one Product_spec
     *   }
     * })
     * 
    **/
    delete<T extends product_specDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, product_specDeleteArgs<ExtArgs>>
    ): Prisma__product_specClient<$Result.GetResult<Prisma.$product_specPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Product_spec.
     * @param {product_specUpdateArgs} args - Arguments to update one Product_spec.
     * @example
     * // Update one Product_spec
     * const product_spec = await prisma.product_spec.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends product_specUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, product_specUpdateArgs<ExtArgs>>
    ): Prisma__product_specClient<$Result.GetResult<Prisma.$product_specPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Product_specs.
     * @param {product_specDeleteManyArgs} args - Arguments to filter Product_specs to delete.
     * @example
     * // Delete a few Product_specs
     * const { count } = await prisma.product_spec.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends product_specDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, product_specDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Product_specs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {product_specUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Product_specs
     * const product_spec = await prisma.product_spec.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends product_specUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, product_specUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Product_spec.
     * @param {product_specUpsertArgs} args - Arguments to update or create a Product_spec.
     * @example
     * // Update or create a Product_spec
     * const product_spec = await prisma.product_spec.upsert({
     *   create: {
     *     // ... data to create a Product_spec
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product_spec we want to update
     *   }
     * })
    **/
    upsert<T extends product_specUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, product_specUpsertArgs<ExtArgs>>
    ): Prisma__product_specClient<$Result.GetResult<Prisma.$product_specPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Product_specs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {product_specCountArgs} args - Arguments to filter Product_specs to count.
     * @example
     * // Count the number of Product_specs
     * const count = await prisma.product_spec.count({
     *   where: {
     *     // ... the filter for the Product_specs we want to count
     *   }
     * })
    **/
    count<T extends product_specCountArgs>(
      args?: Subset<T, product_specCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Product_specCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product_spec.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Product_specAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Product_specAggregateArgs>(args: Subset<T, Product_specAggregateArgs>): Prisma.PrismaPromise<GetProduct_specAggregateType<T>>

    /**
     * Group by Product_spec.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {product_specGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends product_specGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: product_specGroupByArgs['orderBy'] }
        : { orderBy?: product_specGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, product_specGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProduct_specGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the product_spec model
   */
  readonly fields: product_specFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for product_spec.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__product_specClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    product<T extends productDefaultArgs<ExtArgs> = {}>(args?: Subset<T, productDefaultArgs<ExtArgs>>): Prisma__productClient<$Result.GetResult<Prisma.$productPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the product_spec model
   */ 
  interface product_specFieldRefs {
    readonly id: FieldRef<"product_spec", 'Int'>
    readonly name: FieldRef<"product_spec", 'String'>
    readonly data: FieldRef<"product_spec", 'Json'>
    readonly productId: FieldRef<"product_spec", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * product_spec findUnique
   */
  export type product_specFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_spec
     */
    select?: product_specSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: product_specInclude<ExtArgs> | null
    /**
     * Filter, which product_spec to fetch.
     */
    where: product_specWhereUniqueInput
  }


  /**
   * product_spec findUniqueOrThrow
   */
  export type product_specFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_spec
     */
    select?: product_specSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: product_specInclude<ExtArgs> | null
    /**
     * Filter, which product_spec to fetch.
     */
    where: product_specWhereUniqueInput
  }


  /**
   * product_spec findFirst
   */
  export type product_specFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_spec
     */
    select?: product_specSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: product_specInclude<ExtArgs> | null
    /**
     * Filter, which product_spec to fetch.
     */
    where?: product_specWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of product_specs to fetch.
     */
    orderBy?: product_specOrderByWithRelationInput | product_specOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for product_specs.
     */
    cursor?: product_specWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` product_specs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` product_specs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of product_specs.
     */
    distinct?: Product_specScalarFieldEnum | Product_specScalarFieldEnum[]
  }


  /**
   * product_spec findFirstOrThrow
   */
  export type product_specFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_spec
     */
    select?: product_specSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: product_specInclude<ExtArgs> | null
    /**
     * Filter, which product_spec to fetch.
     */
    where?: product_specWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of product_specs to fetch.
     */
    orderBy?: product_specOrderByWithRelationInput | product_specOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for product_specs.
     */
    cursor?: product_specWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` product_specs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` product_specs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of product_specs.
     */
    distinct?: Product_specScalarFieldEnum | Product_specScalarFieldEnum[]
  }


  /**
   * product_spec findMany
   */
  export type product_specFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_spec
     */
    select?: product_specSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: product_specInclude<ExtArgs> | null
    /**
     * Filter, which product_specs to fetch.
     */
    where?: product_specWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of product_specs to fetch.
     */
    orderBy?: product_specOrderByWithRelationInput | product_specOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing product_specs.
     */
    cursor?: product_specWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` product_specs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` product_specs.
     */
    skip?: number
    distinct?: Product_specScalarFieldEnum | Product_specScalarFieldEnum[]
  }


  /**
   * product_spec create
   */
  export type product_specCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_spec
     */
    select?: product_specSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: product_specInclude<ExtArgs> | null
    /**
     * The data needed to create a product_spec.
     */
    data: XOR<product_specCreateInput, product_specUncheckedCreateInput>
  }


  /**
   * product_spec createMany
   */
  export type product_specCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many product_specs.
     */
    data: product_specCreateManyInput | product_specCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * product_spec update
   */
  export type product_specUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_spec
     */
    select?: product_specSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: product_specInclude<ExtArgs> | null
    /**
     * The data needed to update a product_spec.
     */
    data: XOR<product_specUpdateInput, product_specUncheckedUpdateInput>
    /**
     * Choose, which product_spec to update.
     */
    where: product_specWhereUniqueInput
  }


  /**
   * product_spec updateMany
   */
  export type product_specUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update product_specs.
     */
    data: XOR<product_specUpdateManyMutationInput, product_specUncheckedUpdateManyInput>
    /**
     * Filter which product_specs to update
     */
    where?: product_specWhereInput
  }


  /**
   * product_spec upsert
   */
  export type product_specUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_spec
     */
    select?: product_specSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: product_specInclude<ExtArgs> | null
    /**
     * The filter to search for the product_spec to update in case it exists.
     */
    where: product_specWhereUniqueInput
    /**
     * In case the product_spec found by the `where` argument doesn't exist, create a new product_spec with this data.
     */
    create: XOR<product_specCreateInput, product_specUncheckedCreateInput>
    /**
     * In case the product_spec was found with the provided `where` argument, update it with this data.
     */
    update: XOR<product_specUpdateInput, product_specUncheckedUpdateInput>
  }


  /**
   * product_spec delete
   */
  export type product_specDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_spec
     */
    select?: product_specSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: product_specInclude<ExtArgs> | null
    /**
     * Filter which product_spec to delete.
     */
    where: product_specWhereUniqueInput
  }


  /**
   * product_spec deleteMany
   */
  export type product_specDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which product_specs to delete
     */
    where?: product_specWhereInput
  }


  /**
   * product_spec without action
   */
  export type product_specDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_spec
     */
    select?: product_specSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: product_specInclude<ExtArgs> | null
  }



  /**
   * Model cart
   */

  export type AggregateCart = {
    _count: CartCountAggregateOutputType | null
    _avg: CartAvgAggregateOutputType | null
    _sum: CartSumAggregateOutputType | null
    _min: CartMinAggregateOutputType | null
    _max: CartMaxAggregateOutputType | null
  }

  export type CartAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    productId: number | null
    product_priceId: number | null
    qty: number | null
    price: number | null
  }

  export type CartSumAggregateOutputType = {
    id: number | null
    userId: number | null
    productId: number | null
    product_priceId: number | null
    qty: number | null
    price: number | null
  }

  export type CartMinAggregateOutputType = {
    id: number | null
    userId: number | null
    productId: number | null
    product_priceId: number | null
    qty: number | null
    price: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CartMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    productId: number | null
    product_priceId: number | null
    qty: number | null
    price: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CartCountAggregateOutputType = {
    id: number
    userId: number
    productId: number
    product_priceId: number
    qty: number
    price: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CartAvgAggregateInputType = {
    id?: true
    userId?: true
    productId?: true
    product_priceId?: true
    qty?: true
    price?: true
  }

  export type CartSumAggregateInputType = {
    id?: true
    userId?: true
    productId?: true
    product_priceId?: true
    qty?: true
    price?: true
  }

  export type CartMinAggregateInputType = {
    id?: true
    userId?: true
    productId?: true
    product_priceId?: true
    qty?: true
    price?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CartMaxAggregateInputType = {
    id?: true
    userId?: true
    productId?: true
    product_priceId?: true
    qty?: true
    price?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CartCountAggregateInputType = {
    id?: true
    userId?: true
    productId?: true
    product_priceId?: true
    qty?: true
    price?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CartAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which cart to aggregate.
     */
    where?: cartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of carts to fetch.
     */
    orderBy?: cartOrderByWithRelationInput | cartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: cartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` carts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` carts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned carts
    **/
    _count?: true | CartCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CartAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CartSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CartMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CartMaxAggregateInputType
  }

  export type GetCartAggregateType<T extends CartAggregateArgs> = {
        [P in keyof T & keyof AggregateCart]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCart[P]>
      : GetScalarType<T[P], AggregateCart[P]>
  }




  export type cartGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: cartWhereInput
    orderBy?: cartOrderByWithAggregationInput | cartOrderByWithAggregationInput[]
    by: CartScalarFieldEnum[] | CartScalarFieldEnum
    having?: cartScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CartCountAggregateInputType | true
    _avg?: CartAvgAggregateInputType
    _sum?: CartSumAggregateInputType
    _min?: CartMinAggregateInputType
    _max?: CartMaxAggregateInputType
  }

  export type CartGroupByOutputType = {
    id: number
    userId: number
    productId: number
    product_priceId: number
    qty: number
    price: number
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: CartCountAggregateOutputType | null
    _avg: CartAvgAggregateOutputType | null
    _sum: CartSumAggregateOutputType | null
    _min: CartMinAggregateOutputType | null
    _max: CartMaxAggregateOutputType | null
  }

  type GetCartGroupByPayload<T extends cartGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CartGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CartGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CartGroupByOutputType[P]>
            : GetScalarType<T[P], CartGroupByOutputType[P]>
        }
      >
    >


  export type cartSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    productId?: boolean
    product_priceId?: boolean
    qty?: boolean
    price?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
    product?: boolean | productDefaultArgs<ExtArgs>
    product_price?: boolean | product_priceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cart"]>

  export type cartSelectScalar = {
    id?: boolean
    userId?: boolean
    productId?: boolean
    product_priceId?: boolean
    qty?: boolean
    price?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type cartInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
    product?: boolean | productDefaultArgs<ExtArgs>
    product_price?: boolean | product_priceDefaultArgs<ExtArgs>
  }


  export type $cartPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "cart"
    objects: {
      user: Prisma.$userPayload<ExtArgs>
      product: Prisma.$productPayload<ExtArgs>
      product_price: Prisma.$product_pricePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      productId: number
      product_priceId: number
      qty: number
      price: number
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["cart"]>
    composites: {}
  }


  type cartGetPayload<S extends boolean | null | undefined | cartDefaultArgs> = $Result.GetResult<Prisma.$cartPayload, S>

  type cartCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<cartFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CartCountAggregateInputType | true
    }

  export interface cartDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['cart'], meta: { name: 'cart' } }
    /**
     * Find zero or one Cart that matches the filter.
     * @param {cartFindUniqueArgs} args - Arguments to find a Cart
     * @example
     * // Get one Cart
     * const cart = await prisma.cart.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends cartFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, cartFindUniqueArgs<ExtArgs>>
    ): Prisma__cartClient<$Result.GetResult<Prisma.$cartPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Cart that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {cartFindUniqueOrThrowArgs} args - Arguments to find a Cart
     * @example
     * // Get one Cart
     * const cart = await prisma.cart.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends cartFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, cartFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__cartClient<$Result.GetResult<Prisma.$cartPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Cart that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cartFindFirstArgs} args - Arguments to find a Cart
     * @example
     * // Get one Cart
     * const cart = await prisma.cart.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends cartFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, cartFindFirstArgs<ExtArgs>>
    ): Prisma__cartClient<$Result.GetResult<Prisma.$cartPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Cart that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cartFindFirstOrThrowArgs} args - Arguments to find a Cart
     * @example
     * // Get one Cart
     * const cart = await prisma.cart.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends cartFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, cartFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__cartClient<$Result.GetResult<Prisma.$cartPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Carts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cartFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Carts
     * const carts = await prisma.cart.findMany()
     * 
     * // Get first 10 Carts
     * const carts = await prisma.cart.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cartWithIdOnly = await prisma.cart.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends cartFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, cartFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$cartPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Cart.
     * @param {cartCreateArgs} args - Arguments to create a Cart.
     * @example
     * // Create one Cart
     * const Cart = await prisma.cart.create({
     *   data: {
     *     // ... data to create a Cart
     *   }
     * })
     * 
    **/
    create<T extends cartCreateArgs<ExtArgs>>(
      args: SelectSubset<T, cartCreateArgs<ExtArgs>>
    ): Prisma__cartClient<$Result.GetResult<Prisma.$cartPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Carts.
     *     @param {cartCreateManyArgs} args - Arguments to create many Carts.
     *     @example
     *     // Create many Carts
     *     const cart = await prisma.cart.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends cartCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, cartCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Cart.
     * @param {cartDeleteArgs} args - Arguments to delete one Cart.
     * @example
     * // Delete one Cart
     * const Cart = await prisma.cart.delete({
     *   where: {
     *     // ... filter to delete one Cart
     *   }
     * })
     * 
    **/
    delete<T extends cartDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, cartDeleteArgs<ExtArgs>>
    ): Prisma__cartClient<$Result.GetResult<Prisma.$cartPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Cart.
     * @param {cartUpdateArgs} args - Arguments to update one Cart.
     * @example
     * // Update one Cart
     * const cart = await prisma.cart.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends cartUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, cartUpdateArgs<ExtArgs>>
    ): Prisma__cartClient<$Result.GetResult<Prisma.$cartPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Carts.
     * @param {cartDeleteManyArgs} args - Arguments to filter Carts to delete.
     * @example
     * // Delete a few Carts
     * const { count } = await prisma.cart.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends cartDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, cartDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Carts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cartUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Carts
     * const cart = await prisma.cart.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends cartUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, cartUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Cart.
     * @param {cartUpsertArgs} args - Arguments to update or create a Cart.
     * @example
     * // Update or create a Cart
     * const cart = await prisma.cart.upsert({
     *   create: {
     *     // ... data to create a Cart
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cart we want to update
     *   }
     * })
    **/
    upsert<T extends cartUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, cartUpsertArgs<ExtArgs>>
    ): Prisma__cartClient<$Result.GetResult<Prisma.$cartPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Carts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cartCountArgs} args - Arguments to filter Carts to count.
     * @example
     * // Count the number of Carts
     * const count = await prisma.cart.count({
     *   where: {
     *     // ... the filter for the Carts we want to count
     *   }
     * })
    **/
    count<T extends cartCountArgs>(
      args?: Subset<T, cartCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CartCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cart.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CartAggregateArgs>(args: Subset<T, CartAggregateArgs>): Prisma.PrismaPromise<GetCartAggregateType<T>>

    /**
     * Group by Cart.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cartGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends cartGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: cartGroupByArgs['orderBy'] }
        : { orderBy?: cartGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, cartGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCartGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the cart model
   */
  readonly fields: cartFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for cart.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__cartClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    product<T extends productDefaultArgs<ExtArgs> = {}>(args?: Subset<T, productDefaultArgs<ExtArgs>>): Prisma__productClient<$Result.GetResult<Prisma.$productPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    product_price<T extends product_priceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, product_priceDefaultArgs<ExtArgs>>): Prisma__product_priceClient<$Result.GetResult<Prisma.$product_pricePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the cart model
   */ 
  interface cartFieldRefs {
    readonly id: FieldRef<"cart", 'Int'>
    readonly userId: FieldRef<"cart", 'Int'>
    readonly productId: FieldRef<"cart", 'Int'>
    readonly product_priceId: FieldRef<"cart", 'Int'>
    readonly qty: FieldRef<"cart", 'Int'>
    readonly price: FieldRef<"cart", 'Float'>
    readonly isActive: FieldRef<"cart", 'Boolean'>
    readonly createdAt: FieldRef<"cart", 'DateTime'>
    readonly updatedAt: FieldRef<"cart", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * cart findUnique
   */
  export type cartFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cart
     */
    select?: cartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: cartInclude<ExtArgs> | null
    /**
     * Filter, which cart to fetch.
     */
    where: cartWhereUniqueInput
  }


  /**
   * cart findUniqueOrThrow
   */
  export type cartFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cart
     */
    select?: cartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: cartInclude<ExtArgs> | null
    /**
     * Filter, which cart to fetch.
     */
    where: cartWhereUniqueInput
  }


  /**
   * cart findFirst
   */
  export type cartFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cart
     */
    select?: cartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: cartInclude<ExtArgs> | null
    /**
     * Filter, which cart to fetch.
     */
    where?: cartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of carts to fetch.
     */
    orderBy?: cartOrderByWithRelationInput | cartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for carts.
     */
    cursor?: cartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` carts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` carts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of carts.
     */
    distinct?: CartScalarFieldEnum | CartScalarFieldEnum[]
  }


  /**
   * cart findFirstOrThrow
   */
  export type cartFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cart
     */
    select?: cartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: cartInclude<ExtArgs> | null
    /**
     * Filter, which cart to fetch.
     */
    where?: cartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of carts to fetch.
     */
    orderBy?: cartOrderByWithRelationInput | cartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for carts.
     */
    cursor?: cartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` carts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` carts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of carts.
     */
    distinct?: CartScalarFieldEnum | CartScalarFieldEnum[]
  }


  /**
   * cart findMany
   */
  export type cartFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cart
     */
    select?: cartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: cartInclude<ExtArgs> | null
    /**
     * Filter, which carts to fetch.
     */
    where?: cartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of carts to fetch.
     */
    orderBy?: cartOrderByWithRelationInput | cartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing carts.
     */
    cursor?: cartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` carts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` carts.
     */
    skip?: number
    distinct?: CartScalarFieldEnum | CartScalarFieldEnum[]
  }


  /**
   * cart create
   */
  export type cartCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cart
     */
    select?: cartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: cartInclude<ExtArgs> | null
    /**
     * The data needed to create a cart.
     */
    data: XOR<cartCreateInput, cartUncheckedCreateInput>
  }


  /**
   * cart createMany
   */
  export type cartCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many carts.
     */
    data: cartCreateManyInput | cartCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * cart update
   */
  export type cartUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cart
     */
    select?: cartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: cartInclude<ExtArgs> | null
    /**
     * The data needed to update a cart.
     */
    data: XOR<cartUpdateInput, cartUncheckedUpdateInput>
    /**
     * Choose, which cart to update.
     */
    where: cartWhereUniqueInput
  }


  /**
   * cart updateMany
   */
  export type cartUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update carts.
     */
    data: XOR<cartUpdateManyMutationInput, cartUncheckedUpdateManyInput>
    /**
     * Filter which carts to update
     */
    where?: cartWhereInput
  }


  /**
   * cart upsert
   */
  export type cartUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cart
     */
    select?: cartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: cartInclude<ExtArgs> | null
    /**
     * The filter to search for the cart to update in case it exists.
     */
    where: cartWhereUniqueInput
    /**
     * In case the cart found by the `where` argument doesn't exist, create a new cart with this data.
     */
    create: XOR<cartCreateInput, cartUncheckedCreateInput>
    /**
     * In case the cart was found with the provided `where` argument, update it with this data.
     */
    update: XOR<cartUpdateInput, cartUncheckedUpdateInput>
  }


  /**
   * cart delete
   */
  export type cartDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cart
     */
    select?: cartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: cartInclude<ExtArgs> | null
    /**
     * Filter which cart to delete.
     */
    where: cartWhereUniqueInput
  }


  /**
   * cart deleteMany
   */
  export type cartDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which carts to delete
     */
    where?: cartWhereInput
  }


  /**
   * cart without action
   */
  export type cartDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cart
     */
    select?: cartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: cartInclude<ExtArgs> | null
  }



  /**
   * Model order
   */

  export type AggregateOrder = {
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  export type OrderAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    createUsing: number | null
    pointUsing: number | null
    orderPrice: number | null
    deliveryPrice: number | null
    netPrice: number | null
    orderDiscount: number | null
    deliveryDiscount: number | null
    addressId: number | null
  }

  export type OrderSumAggregateOutputType = {
    id: number | null
    userId: number | null
    createUsing: number | null
    pointUsing: number | null
    orderPrice: number | null
    deliveryPrice: number | null
    netPrice: number | null
    orderDiscount: number | null
    deliveryDiscount: number | null
    addressId: number | null
  }

  export type OrderMinAggregateOutputType = {
    id: number | null
    userId: number | null
    statusNow: string | null
    paymentType: string | null
    paymentStatus: string | null
    createUsing: number | null
    pointUsing: number | null
    orderPrice: number | null
    deliveryPrice: number | null
    netPrice: number | null
    orderDiscount: number | null
    deliveryDiscount: number | null
    orderDiscountCode: string | null
    deliveryDiscountCode: string | null
    addressId: number | null
    isReject: boolean | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrderMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    statusNow: string | null
    paymentType: string | null
    paymentStatus: string | null
    createUsing: number | null
    pointUsing: number | null
    orderPrice: number | null
    deliveryPrice: number | null
    netPrice: number | null
    orderDiscount: number | null
    deliveryDiscount: number | null
    orderDiscountCode: string | null
    deliveryDiscountCode: string | null
    addressId: number | null
    isReject: boolean | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrderCountAggregateOutputType = {
    id: number
    userId: number
    statusNow: number
    status: number
    paymentType: number
    paymentStatus: number
    createUsing: number
    pointUsing: number
    orderPrice: number
    deliveryPrice: number
    netPrice: number
    orderDiscount: number
    deliveryDiscount: number
    orderDiscountCode: number
    deliveryDiscountCode: number
    addressId: number
    addressData: number
    userData: number
    isReject: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OrderAvgAggregateInputType = {
    id?: true
    userId?: true
    createUsing?: true
    pointUsing?: true
    orderPrice?: true
    deliveryPrice?: true
    netPrice?: true
    orderDiscount?: true
    deliveryDiscount?: true
    addressId?: true
  }

  export type OrderSumAggregateInputType = {
    id?: true
    userId?: true
    createUsing?: true
    pointUsing?: true
    orderPrice?: true
    deliveryPrice?: true
    netPrice?: true
    orderDiscount?: true
    deliveryDiscount?: true
    addressId?: true
  }

  export type OrderMinAggregateInputType = {
    id?: true
    userId?: true
    statusNow?: true
    paymentType?: true
    paymentStatus?: true
    createUsing?: true
    pointUsing?: true
    orderPrice?: true
    deliveryPrice?: true
    netPrice?: true
    orderDiscount?: true
    deliveryDiscount?: true
    orderDiscountCode?: true
    deliveryDiscountCode?: true
    addressId?: true
    isReject?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrderMaxAggregateInputType = {
    id?: true
    userId?: true
    statusNow?: true
    paymentType?: true
    paymentStatus?: true
    createUsing?: true
    pointUsing?: true
    orderPrice?: true
    deliveryPrice?: true
    netPrice?: true
    orderDiscount?: true
    deliveryDiscount?: true
    orderDiscountCode?: true
    deliveryDiscountCode?: true
    addressId?: true
    isReject?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrderCountAggregateInputType = {
    id?: true
    userId?: true
    statusNow?: true
    status?: true
    paymentType?: true
    paymentStatus?: true
    createUsing?: true
    pointUsing?: true
    orderPrice?: true
    deliveryPrice?: true
    netPrice?: true
    orderDiscount?: true
    deliveryDiscount?: true
    orderDiscountCode?: true
    deliveryDiscountCode?: true
    addressId?: true
    addressData?: true
    userData?: true
    isReject?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which order to aggregate.
     */
    where?: orderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of orders to fetch.
     */
    orderBy?: orderOrderByWithRelationInput | orderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: orderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned orders
    **/
    _count?: true | OrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderMaxAggregateInputType
  }

  export type GetOrderAggregateType<T extends OrderAggregateArgs> = {
        [P in keyof T & keyof AggregateOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrder[P]>
      : GetScalarType<T[P], AggregateOrder[P]>
  }




  export type orderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: orderWhereInput
    orderBy?: orderOrderByWithAggregationInput | orderOrderByWithAggregationInput[]
    by: OrderScalarFieldEnum[] | OrderScalarFieldEnum
    having?: orderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderCountAggregateInputType | true
    _avg?: OrderAvgAggregateInputType
    _sum?: OrderSumAggregateInputType
    _min?: OrderMinAggregateInputType
    _max?: OrderMaxAggregateInputType
  }

  export type OrderGroupByOutputType = {
    id: number
    userId: number
    statusNow: string
    status: JsonValue
    paymentType: string
    paymentStatus: string
    createUsing: number
    pointUsing: number
    orderPrice: number
    deliveryPrice: number
    netPrice: number
    orderDiscount: number
    deliveryDiscount: number
    orderDiscountCode: string
    deliveryDiscountCode: string
    addressId: number
    addressData: JsonValue
    userData: JsonValue
    isReject: boolean
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  type GetOrderGroupByPayload<T extends orderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderGroupByOutputType[P]>
            : GetScalarType<T[P], OrderGroupByOutputType[P]>
        }
      >
    >


  export type orderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    statusNow?: boolean
    status?: boolean
    paymentType?: boolean
    paymentStatus?: boolean
    createUsing?: boolean
    pointUsing?: boolean
    orderPrice?: boolean
    deliveryPrice?: boolean
    netPrice?: boolean
    orderDiscount?: boolean
    deliveryDiscount?: boolean
    orderDiscountCode?: boolean
    deliveryDiscountCode?: boolean
    addressId?: boolean
    addressData?: boolean
    userData?: boolean
    isReject?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
    address?: boolean | addressDefaultArgs<ExtArgs>
    order_product?: boolean | order$order_productArgs<ExtArgs>
    _count?: boolean | OrderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type orderSelectScalar = {
    id?: boolean
    userId?: boolean
    statusNow?: boolean
    status?: boolean
    paymentType?: boolean
    paymentStatus?: boolean
    createUsing?: boolean
    pointUsing?: boolean
    orderPrice?: boolean
    deliveryPrice?: boolean
    netPrice?: boolean
    orderDiscount?: boolean
    deliveryDiscount?: boolean
    orderDiscountCode?: boolean
    deliveryDiscountCode?: boolean
    addressId?: boolean
    addressData?: boolean
    userData?: boolean
    isReject?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type orderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
    address?: boolean | addressDefaultArgs<ExtArgs>
    order_product?: boolean | order$order_productArgs<ExtArgs>
    _count?: boolean | OrderCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $orderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "order"
    objects: {
      user: Prisma.$userPayload<ExtArgs>
      address: Prisma.$addressPayload<ExtArgs>
      order_product: Prisma.$order_productPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      statusNow: string
      status: Prisma.JsonValue
      paymentType: string
      paymentStatus: string
      createUsing: number
      pointUsing: number
      orderPrice: number
      deliveryPrice: number
      netPrice: number
      orderDiscount: number
      deliveryDiscount: number
      orderDiscountCode: string
      deliveryDiscountCode: string
      addressId: number
      addressData: Prisma.JsonValue
      userData: Prisma.JsonValue
      isReject: boolean
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["order"]>
    composites: {}
  }


  type orderGetPayload<S extends boolean | null | undefined | orderDefaultArgs> = $Result.GetResult<Prisma.$orderPayload, S>

  type orderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<orderFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OrderCountAggregateInputType | true
    }

  export interface orderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['order'], meta: { name: 'order' } }
    /**
     * Find zero or one Order that matches the filter.
     * @param {orderFindUniqueArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends orderFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, orderFindUniqueArgs<ExtArgs>>
    ): Prisma__orderClient<$Result.GetResult<Prisma.$orderPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Order that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {orderFindUniqueOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends orderFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, orderFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__orderClient<$Result.GetResult<Prisma.$orderPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Order that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {orderFindFirstArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends orderFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, orderFindFirstArgs<ExtArgs>>
    ): Prisma__orderClient<$Result.GetResult<Prisma.$orderPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Order that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {orderFindFirstOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends orderFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, orderFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__orderClient<$Result.GetResult<Prisma.$orderPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {orderFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Orders
     * const orders = await prisma.order.findMany()
     * 
     * // Get first 10 Orders
     * const orders = await prisma.order.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderWithIdOnly = await prisma.order.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends orderFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, orderFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$orderPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Order.
     * @param {orderCreateArgs} args - Arguments to create a Order.
     * @example
     * // Create one Order
     * const Order = await prisma.order.create({
     *   data: {
     *     // ... data to create a Order
     *   }
     * })
     * 
    **/
    create<T extends orderCreateArgs<ExtArgs>>(
      args: SelectSubset<T, orderCreateArgs<ExtArgs>>
    ): Prisma__orderClient<$Result.GetResult<Prisma.$orderPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Orders.
     *     @param {orderCreateManyArgs} args - Arguments to create many Orders.
     *     @example
     *     // Create many Orders
     *     const order = await prisma.order.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends orderCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, orderCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Order.
     * @param {orderDeleteArgs} args - Arguments to delete one Order.
     * @example
     * // Delete one Order
     * const Order = await prisma.order.delete({
     *   where: {
     *     // ... filter to delete one Order
     *   }
     * })
     * 
    **/
    delete<T extends orderDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, orderDeleteArgs<ExtArgs>>
    ): Prisma__orderClient<$Result.GetResult<Prisma.$orderPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Order.
     * @param {orderUpdateArgs} args - Arguments to update one Order.
     * @example
     * // Update one Order
     * const order = await prisma.order.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends orderUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, orderUpdateArgs<ExtArgs>>
    ): Prisma__orderClient<$Result.GetResult<Prisma.$orderPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Orders.
     * @param {orderDeleteManyArgs} args - Arguments to filter Orders to delete.
     * @example
     * // Delete a few Orders
     * const { count } = await prisma.order.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends orderDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, orderDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {orderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends orderUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, orderUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Order.
     * @param {orderUpsertArgs} args - Arguments to update or create a Order.
     * @example
     * // Update or create a Order
     * const order = await prisma.order.upsert({
     *   create: {
     *     // ... data to create a Order
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Order we want to update
     *   }
     * })
    **/
    upsert<T extends orderUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, orderUpsertArgs<ExtArgs>>
    ): Prisma__orderClient<$Result.GetResult<Prisma.$orderPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {orderCountArgs} args - Arguments to filter Orders to count.
     * @example
     * // Count the number of Orders
     * const count = await prisma.order.count({
     *   where: {
     *     // ... the filter for the Orders we want to count
     *   }
     * })
    **/
    count<T extends orderCountArgs>(
      args?: Subset<T, orderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderAggregateArgs>(args: Subset<T, OrderAggregateArgs>): Prisma.PrismaPromise<GetOrderAggregateType<T>>

    /**
     * Group by Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {orderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends orderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: orderGroupByArgs['orderBy'] }
        : { orderBy?: orderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, orderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the order model
   */
  readonly fields: orderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for order.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__orderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    address<T extends addressDefaultArgs<ExtArgs> = {}>(args?: Subset<T, addressDefaultArgs<ExtArgs>>): Prisma__addressClient<$Result.GetResult<Prisma.$addressPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    order_product<T extends order$order_productArgs<ExtArgs> = {}>(args?: Subset<T, order$order_productArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$order_productPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the order model
   */ 
  interface orderFieldRefs {
    readonly id: FieldRef<"order", 'Int'>
    readonly userId: FieldRef<"order", 'Int'>
    readonly statusNow: FieldRef<"order", 'String'>
    readonly status: FieldRef<"order", 'Json'>
    readonly paymentType: FieldRef<"order", 'String'>
    readonly paymentStatus: FieldRef<"order", 'String'>
    readonly createUsing: FieldRef<"order", 'Float'>
    readonly pointUsing: FieldRef<"order", 'Float'>
    readonly orderPrice: FieldRef<"order", 'Float'>
    readonly deliveryPrice: FieldRef<"order", 'Float'>
    readonly netPrice: FieldRef<"order", 'Float'>
    readonly orderDiscount: FieldRef<"order", 'Float'>
    readonly deliveryDiscount: FieldRef<"order", 'Float'>
    readonly orderDiscountCode: FieldRef<"order", 'String'>
    readonly deliveryDiscountCode: FieldRef<"order", 'String'>
    readonly addressId: FieldRef<"order", 'Int'>
    readonly addressData: FieldRef<"order", 'Json'>
    readonly userData: FieldRef<"order", 'Json'>
    readonly isReject: FieldRef<"order", 'Boolean'>
    readonly isActive: FieldRef<"order", 'Boolean'>
    readonly createdAt: FieldRef<"order", 'DateTime'>
    readonly updatedAt: FieldRef<"order", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * order findUnique
   */
  export type orderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order
     */
    select?: orderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: orderInclude<ExtArgs> | null
    /**
     * Filter, which order to fetch.
     */
    where: orderWhereUniqueInput
  }


  /**
   * order findUniqueOrThrow
   */
  export type orderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order
     */
    select?: orderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: orderInclude<ExtArgs> | null
    /**
     * Filter, which order to fetch.
     */
    where: orderWhereUniqueInput
  }


  /**
   * order findFirst
   */
  export type orderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order
     */
    select?: orderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: orderInclude<ExtArgs> | null
    /**
     * Filter, which order to fetch.
     */
    where?: orderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of orders to fetch.
     */
    orderBy?: orderOrderByWithRelationInput | orderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for orders.
     */
    cursor?: orderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }


  /**
   * order findFirstOrThrow
   */
  export type orderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order
     */
    select?: orderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: orderInclude<ExtArgs> | null
    /**
     * Filter, which order to fetch.
     */
    where?: orderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of orders to fetch.
     */
    orderBy?: orderOrderByWithRelationInput | orderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for orders.
     */
    cursor?: orderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }


  /**
   * order findMany
   */
  export type orderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order
     */
    select?: orderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: orderInclude<ExtArgs> | null
    /**
     * Filter, which orders to fetch.
     */
    where?: orderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of orders to fetch.
     */
    orderBy?: orderOrderByWithRelationInput | orderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing orders.
     */
    cursor?: orderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` orders.
     */
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }


  /**
   * order create
   */
  export type orderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order
     */
    select?: orderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: orderInclude<ExtArgs> | null
    /**
     * The data needed to create a order.
     */
    data: XOR<orderCreateInput, orderUncheckedCreateInput>
  }


  /**
   * order createMany
   */
  export type orderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many orders.
     */
    data: orderCreateManyInput | orderCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * order update
   */
  export type orderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order
     */
    select?: orderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: orderInclude<ExtArgs> | null
    /**
     * The data needed to update a order.
     */
    data: XOR<orderUpdateInput, orderUncheckedUpdateInput>
    /**
     * Choose, which order to update.
     */
    where: orderWhereUniqueInput
  }


  /**
   * order updateMany
   */
  export type orderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update orders.
     */
    data: XOR<orderUpdateManyMutationInput, orderUncheckedUpdateManyInput>
    /**
     * Filter which orders to update
     */
    where?: orderWhereInput
  }


  /**
   * order upsert
   */
  export type orderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order
     */
    select?: orderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: orderInclude<ExtArgs> | null
    /**
     * The filter to search for the order to update in case it exists.
     */
    where: orderWhereUniqueInput
    /**
     * In case the order found by the `where` argument doesn't exist, create a new order with this data.
     */
    create: XOR<orderCreateInput, orderUncheckedCreateInput>
    /**
     * In case the order was found with the provided `where` argument, update it with this data.
     */
    update: XOR<orderUpdateInput, orderUncheckedUpdateInput>
  }


  /**
   * order delete
   */
  export type orderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order
     */
    select?: orderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: orderInclude<ExtArgs> | null
    /**
     * Filter which order to delete.
     */
    where: orderWhereUniqueInput
  }


  /**
   * order deleteMany
   */
  export type orderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which orders to delete
     */
    where?: orderWhereInput
  }


  /**
   * order.order_product
   */
  export type order$order_productArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_product
     */
    select?: order_productSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: order_productInclude<ExtArgs> | null
    where?: order_productWhereInput
    orderBy?: order_productOrderByWithRelationInput | order_productOrderByWithRelationInput[]
    cursor?: order_productWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Order_productScalarFieldEnum | Order_productScalarFieldEnum[]
  }


  /**
   * order without action
   */
  export type orderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order
     */
    select?: orderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: orderInclude<ExtArgs> | null
  }



  /**
   * Model order_product
   */

  export type AggregateOrder_product = {
    _count: Order_productCountAggregateOutputType | null
    _avg: Order_productAvgAggregateOutputType | null
    _sum: Order_productSumAggregateOutputType | null
    _min: Order_productMinAggregateOutputType | null
    _max: Order_productMaxAggregateOutputType | null
  }

  export type Order_productAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    productId: number | null
    orderId: number | null
    product_priceId: number | null
    qty: number | null
    price: number | null
  }

  export type Order_productSumAggregateOutputType = {
    id: number | null
    userId: number | null
    productId: number | null
    orderId: number | null
    product_priceId: number | null
    qty: number | null
    price: number | null
  }

  export type Order_productMinAggregateOutputType = {
    id: number | null
    userId: number | null
    productId: number | null
    orderId: number | null
    product_priceId: number | null
    qty: number | null
    price: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Order_productMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    productId: number | null
    orderId: number | null
    product_priceId: number | null
    qty: number | null
    price: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Order_productCountAggregateOutputType = {
    id: number
    userId: number
    productId: number
    orderId: number
    product_priceId: number
    qty: number
    price: number
    productData: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Order_productAvgAggregateInputType = {
    id?: true
    userId?: true
    productId?: true
    orderId?: true
    product_priceId?: true
    qty?: true
    price?: true
  }

  export type Order_productSumAggregateInputType = {
    id?: true
    userId?: true
    productId?: true
    orderId?: true
    product_priceId?: true
    qty?: true
    price?: true
  }

  export type Order_productMinAggregateInputType = {
    id?: true
    userId?: true
    productId?: true
    orderId?: true
    product_priceId?: true
    qty?: true
    price?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Order_productMaxAggregateInputType = {
    id?: true
    userId?: true
    productId?: true
    orderId?: true
    product_priceId?: true
    qty?: true
    price?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Order_productCountAggregateInputType = {
    id?: true
    userId?: true
    productId?: true
    orderId?: true
    product_priceId?: true
    qty?: true
    price?: true
    productData?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Order_productAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which order_product to aggregate.
     */
    where?: order_productWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of order_products to fetch.
     */
    orderBy?: order_productOrderByWithRelationInput | order_productOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: order_productWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` order_products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` order_products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned order_products
    **/
    _count?: true | Order_productCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Order_productAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Order_productSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Order_productMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Order_productMaxAggregateInputType
  }

  export type GetOrder_productAggregateType<T extends Order_productAggregateArgs> = {
        [P in keyof T & keyof AggregateOrder_product]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrder_product[P]>
      : GetScalarType<T[P], AggregateOrder_product[P]>
  }




  export type order_productGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: order_productWhereInput
    orderBy?: order_productOrderByWithAggregationInput | order_productOrderByWithAggregationInput[]
    by: Order_productScalarFieldEnum[] | Order_productScalarFieldEnum
    having?: order_productScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Order_productCountAggregateInputType | true
    _avg?: Order_productAvgAggregateInputType
    _sum?: Order_productSumAggregateInputType
    _min?: Order_productMinAggregateInputType
    _max?: Order_productMaxAggregateInputType
  }

  export type Order_productGroupByOutputType = {
    id: number
    userId: number
    productId: number
    orderId: number
    product_priceId: number
    qty: number
    price: number
    productData: JsonValue
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: Order_productCountAggregateOutputType | null
    _avg: Order_productAvgAggregateOutputType | null
    _sum: Order_productSumAggregateOutputType | null
    _min: Order_productMinAggregateOutputType | null
    _max: Order_productMaxAggregateOutputType | null
  }

  type GetOrder_productGroupByPayload<T extends order_productGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Order_productGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Order_productGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Order_productGroupByOutputType[P]>
            : GetScalarType<T[P], Order_productGroupByOutputType[P]>
        }
      >
    >


  export type order_productSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    productId?: boolean
    orderId?: boolean
    product_priceId?: boolean
    qty?: boolean
    price?: boolean
    productData?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
    product?: boolean | productDefaultArgs<ExtArgs>
    order?: boolean | orderDefaultArgs<ExtArgs>
    product_price?: boolean | product_priceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["order_product"]>

  export type order_productSelectScalar = {
    id?: boolean
    userId?: boolean
    productId?: boolean
    orderId?: boolean
    product_priceId?: boolean
    qty?: boolean
    price?: boolean
    productData?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type order_productInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
    product?: boolean | productDefaultArgs<ExtArgs>
    order?: boolean | orderDefaultArgs<ExtArgs>
    product_price?: boolean | product_priceDefaultArgs<ExtArgs>
  }


  export type $order_productPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "order_product"
    objects: {
      user: Prisma.$userPayload<ExtArgs>
      product: Prisma.$productPayload<ExtArgs>
      order: Prisma.$orderPayload<ExtArgs>
      product_price: Prisma.$product_pricePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      productId: number
      orderId: number
      product_priceId: number
      qty: number
      price: number
      productData: Prisma.JsonValue
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["order_product"]>
    composites: {}
  }


  type order_productGetPayload<S extends boolean | null | undefined | order_productDefaultArgs> = $Result.GetResult<Prisma.$order_productPayload, S>

  type order_productCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<order_productFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Order_productCountAggregateInputType | true
    }

  export interface order_productDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['order_product'], meta: { name: 'order_product' } }
    /**
     * Find zero or one Order_product that matches the filter.
     * @param {order_productFindUniqueArgs} args - Arguments to find a Order_product
     * @example
     * // Get one Order_product
     * const order_product = await prisma.order_product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends order_productFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, order_productFindUniqueArgs<ExtArgs>>
    ): Prisma__order_productClient<$Result.GetResult<Prisma.$order_productPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Order_product that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {order_productFindUniqueOrThrowArgs} args - Arguments to find a Order_product
     * @example
     * // Get one Order_product
     * const order_product = await prisma.order_product.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends order_productFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, order_productFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__order_productClient<$Result.GetResult<Prisma.$order_productPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Order_product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {order_productFindFirstArgs} args - Arguments to find a Order_product
     * @example
     * // Get one Order_product
     * const order_product = await prisma.order_product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends order_productFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, order_productFindFirstArgs<ExtArgs>>
    ): Prisma__order_productClient<$Result.GetResult<Prisma.$order_productPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Order_product that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {order_productFindFirstOrThrowArgs} args - Arguments to find a Order_product
     * @example
     * // Get one Order_product
     * const order_product = await prisma.order_product.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends order_productFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, order_productFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__order_productClient<$Result.GetResult<Prisma.$order_productPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Order_products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {order_productFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Order_products
     * const order_products = await prisma.order_product.findMany()
     * 
     * // Get first 10 Order_products
     * const order_products = await prisma.order_product.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const order_productWithIdOnly = await prisma.order_product.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends order_productFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, order_productFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$order_productPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Order_product.
     * @param {order_productCreateArgs} args - Arguments to create a Order_product.
     * @example
     * // Create one Order_product
     * const Order_product = await prisma.order_product.create({
     *   data: {
     *     // ... data to create a Order_product
     *   }
     * })
     * 
    **/
    create<T extends order_productCreateArgs<ExtArgs>>(
      args: SelectSubset<T, order_productCreateArgs<ExtArgs>>
    ): Prisma__order_productClient<$Result.GetResult<Prisma.$order_productPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Order_products.
     *     @param {order_productCreateManyArgs} args - Arguments to create many Order_products.
     *     @example
     *     // Create many Order_products
     *     const order_product = await prisma.order_product.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends order_productCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, order_productCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Order_product.
     * @param {order_productDeleteArgs} args - Arguments to delete one Order_product.
     * @example
     * // Delete one Order_product
     * const Order_product = await prisma.order_product.delete({
     *   where: {
     *     // ... filter to delete one Order_product
     *   }
     * })
     * 
    **/
    delete<T extends order_productDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, order_productDeleteArgs<ExtArgs>>
    ): Prisma__order_productClient<$Result.GetResult<Prisma.$order_productPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Order_product.
     * @param {order_productUpdateArgs} args - Arguments to update one Order_product.
     * @example
     * // Update one Order_product
     * const order_product = await prisma.order_product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends order_productUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, order_productUpdateArgs<ExtArgs>>
    ): Prisma__order_productClient<$Result.GetResult<Prisma.$order_productPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Order_products.
     * @param {order_productDeleteManyArgs} args - Arguments to filter Order_products to delete.
     * @example
     * // Delete a few Order_products
     * const { count } = await prisma.order_product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends order_productDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, order_productDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Order_products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {order_productUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Order_products
     * const order_product = await prisma.order_product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends order_productUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, order_productUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Order_product.
     * @param {order_productUpsertArgs} args - Arguments to update or create a Order_product.
     * @example
     * // Update or create a Order_product
     * const order_product = await prisma.order_product.upsert({
     *   create: {
     *     // ... data to create a Order_product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Order_product we want to update
     *   }
     * })
    **/
    upsert<T extends order_productUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, order_productUpsertArgs<ExtArgs>>
    ): Prisma__order_productClient<$Result.GetResult<Prisma.$order_productPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Order_products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {order_productCountArgs} args - Arguments to filter Order_products to count.
     * @example
     * // Count the number of Order_products
     * const count = await prisma.order_product.count({
     *   where: {
     *     // ... the filter for the Order_products we want to count
     *   }
     * })
    **/
    count<T extends order_productCountArgs>(
      args?: Subset<T, order_productCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Order_productCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Order_product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Order_productAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Order_productAggregateArgs>(args: Subset<T, Order_productAggregateArgs>): Prisma.PrismaPromise<GetOrder_productAggregateType<T>>

    /**
     * Group by Order_product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {order_productGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends order_productGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: order_productGroupByArgs['orderBy'] }
        : { orderBy?: order_productGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, order_productGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrder_productGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the order_product model
   */
  readonly fields: order_productFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for order_product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__order_productClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    product<T extends productDefaultArgs<ExtArgs> = {}>(args?: Subset<T, productDefaultArgs<ExtArgs>>): Prisma__productClient<$Result.GetResult<Prisma.$productPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    order<T extends orderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, orderDefaultArgs<ExtArgs>>): Prisma__orderClient<$Result.GetResult<Prisma.$orderPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    product_price<T extends product_priceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, product_priceDefaultArgs<ExtArgs>>): Prisma__product_priceClient<$Result.GetResult<Prisma.$product_pricePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the order_product model
   */ 
  interface order_productFieldRefs {
    readonly id: FieldRef<"order_product", 'Int'>
    readonly userId: FieldRef<"order_product", 'Int'>
    readonly productId: FieldRef<"order_product", 'Int'>
    readonly orderId: FieldRef<"order_product", 'Int'>
    readonly product_priceId: FieldRef<"order_product", 'Int'>
    readonly qty: FieldRef<"order_product", 'Int'>
    readonly price: FieldRef<"order_product", 'Float'>
    readonly productData: FieldRef<"order_product", 'Json'>
    readonly isActive: FieldRef<"order_product", 'Boolean'>
    readonly createdAt: FieldRef<"order_product", 'DateTime'>
    readonly updatedAt: FieldRef<"order_product", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * order_product findUnique
   */
  export type order_productFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_product
     */
    select?: order_productSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: order_productInclude<ExtArgs> | null
    /**
     * Filter, which order_product to fetch.
     */
    where: order_productWhereUniqueInput
  }


  /**
   * order_product findUniqueOrThrow
   */
  export type order_productFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_product
     */
    select?: order_productSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: order_productInclude<ExtArgs> | null
    /**
     * Filter, which order_product to fetch.
     */
    where: order_productWhereUniqueInput
  }


  /**
   * order_product findFirst
   */
  export type order_productFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_product
     */
    select?: order_productSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: order_productInclude<ExtArgs> | null
    /**
     * Filter, which order_product to fetch.
     */
    where?: order_productWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of order_products to fetch.
     */
    orderBy?: order_productOrderByWithRelationInput | order_productOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for order_products.
     */
    cursor?: order_productWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` order_products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` order_products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of order_products.
     */
    distinct?: Order_productScalarFieldEnum | Order_productScalarFieldEnum[]
  }


  /**
   * order_product findFirstOrThrow
   */
  export type order_productFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_product
     */
    select?: order_productSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: order_productInclude<ExtArgs> | null
    /**
     * Filter, which order_product to fetch.
     */
    where?: order_productWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of order_products to fetch.
     */
    orderBy?: order_productOrderByWithRelationInput | order_productOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for order_products.
     */
    cursor?: order_productWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` order_products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` order_products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of order_products.
     */
    distinct?: Order_productScalarFieldEnum | Order_productScalarFieldEnum[]
  }


  /**
   * order_product findMany
   */
  export type order_productFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_product
     */
    select?: order_productSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: order_productInclude<ExtArgs> | null
    /**
     * Filter, which order_products to fetch.
     */
    where?: order_productWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of order_products to fetch.
     */
    orderBy?: order_productOrderByWithRelationInput | order_productOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing order_products.
     */
    cursor?: order_productWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` order_products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` order_products.
     */
    skip?: number
    distinct?: Order_productScalarFieldEnum | Order_productScalarFieldEnum[]
  }


  /**
   * order_product create
   */
  export type order_productCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_product
     */
    select?: order_productSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: order_productInclude<ExtArgs> | null
    /**
     * The data needed to create a order_product.
     */
    data: XOR<order_productCreateInput, order_productUncheckedCreateInput>
  }


  /**
   * order_product createMany
   */
  export type order_productCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many order_products.
     */
    data: order_productCreateManyInput | order_productCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * order_product update
   */
  export type order_productUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_product
     */
    select?: order_productSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: order_productInclude<ExtArgs> | null
    /**
     * The data needed to update a order_product.
     */
    data: XOR<order_productUpdateInput, order_productUncheckedUpdateInput>
    /**
     * Choose, which order_product to update.
     */
    where: order_productWhereUniqueInput
  }


  /**
   * order_product updateMany
   */
  export type order_productUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update order_products.
     */
    data: XOR<order_productUpdateManyMutationInput, order_productUncheckedUpdateManyInput>
    /**
     * Filter which order_products to update
     */
    where?: order_productWhereInput
  }


  /**
   * order_product upsert
   */
  export type order_productUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_product
     */
    select?: order_productSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: order_productInclude<ExtArgs> | null
    /**
     * The filter to search for the order_product to update in case it exists.
     */
    where: order_productWhereUniqueInput
    /**
     * In case the order_product found by the `where` argument doesn't exist, create a new order_product with this data.
     */
    create: XOR<order_productCreateInput, order_productUncheckedCreateInput>
    /**
     * In case the order_product was found with the provided `where` argument, update it with this data.
     */
    update: XOR<order_productUpdateInput, order_productUncheckedUpdateInput>
  }


  /**
   * order_product delete
   */
  export type order_productDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_product
     */
    select?: order_productSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: order_productInclude<ExtArgs> | null
    /**
     * Filter which order_product to delete.
     */
    where: order_productWhereUniqueInput
  }


  /**
   * order_product deleteMany
   */
  export type order_productDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which order_products to delete
     */
    where?: order_productWhereInput
  }


  /**
   * order_product without action
   */
  export type order_productDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_product
     */
    select?: order_productSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: order_productInclude<ExtArgs> | null
  }



  /**
   * Model setting
   */

  export type AggregateSetting = {
    _count: SettingCountAggregateOutputType | null
    _avg: SettingAvgAggregateOutputType | null
    _sum: SettingSumAggregateOutputType | null
    _min: SettingMinAggregateOutputType | null
    _max: SettingMaxAggregateOutputType | null
  }

  export type SettingAvgAggregateOutputType = {
    id: number | null
  }

  export type SettingSumAggregateOutputType = {
    id: number | null
  }

  export type SettingMinAggregateOutputType = {
    id: number | null
    facebook: string | null
    line: string | null
    instagram: string | null
    tiktok: string | null
    email: string | null
    phone: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SettingMaxAggregateOutputType = {
    id: number | null
    facebook: string | null
    line: string | null
    instagram: string | null
    tiktok: string | null
    email: string | null
    phone: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SettingCountAggregateOutputType = {
    id: number
    facebook: number
    line: number
    instagram: number
    tiktok: number
    email: number
    phone: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SettingAvgAggregateInputType = {
    id?: true
  }

  export type SettingSumAggregateInputType = {
    id?: true
  }

  export type SettingMinAggregateInputType = {
    id?: true
    facebook?: true
    line?: true
    instagram?: true
    tiktok?: true
    email?: true
    phone?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SettingMaxAggregateInputType = {
    id?: true
    facebook?: true
    line?: true
    instagram?: true
    tiktok?: true
    email?: true
    phone?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SettingCountAggregateInputType = {
    id?: true
    facebook?: true
    line?: true
    instagram?: true
    tiktok?: true
    email?: true
    phone?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SettingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which setting to aggregate.
     */
    where?: settingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of settings to fetch.
     */
    orderBy?: settingOrderByWithRelationInput | settingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: settingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned settings
    **/
    _count?: true | SettingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SettingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SettingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SettingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SettingMaxAggregateInputType
  }

  export type GetSettingAggregateType<T extends SettingAggregateArgs> = {
        [P in keyof T & keyof AggregateSetting]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSetting[P]>
      : GetScalarType<T[P], AggregateSetting[P]>
  }




  export type settingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: settingWhereInput
    orderBy?: settingOrderByWithAggregationInput | settingOrderByWithAggregationInput[]
    by: SettingScalarFieldEnum[] | SettingScalarFieldEnum
    having?: settingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SettingCountAggregateInputType | true
    _avg?: SettingAvgAggregateInputType
    _sum?: SettingSumAggregateInputType
    _min?: SettingMinAggregateInputType
    _max?: SettingMaxAggregateInputType
  }

  export type SettingGroupByOutputType = {
    id: number
    facebook: string | null
    line: string | null
    instagram: string | null
    tiktok: string | null
    email: string | null
    phone: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: SettingCountAggregateOutputType | null
    _avg: SettingAvgAggregateOutputType | null
    _sum: SettingSumAggregateOutputType | null
    _min: SettingMinAggregateOutputType | null
    _max: SettingMaxAggregateOutputType | null
  }

  type GetSettingGroupByPayload<T extends settingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SettingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SettingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SettingGroupByOutputType[P]>
            : GetScalarType<T[P], SettingGroupByOutputType[P]>
        }
      >
    >


  export type settingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    facebook?: boolean
    line?: boolean
    instagram?: boolean
    tiktok?: boolean
    email?: boolean
    phone?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["setting"]>

  export type settingSelectScalar = {
    id?: boolean
    facebook?: boolean
    line?: boolean
    instagram?: boolean
    tiktok?: boolean
    email?: boolean
    phone?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $settingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "setting"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      facebook: string | null
      line: string | null
      instagram: string | null
      tiktok: string | null
      email: string | null
      phone: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["setting"]>
    composites: {}
  }


  type settingGetPayload<S extends boolean | null | undefined | settingDefaultArgs> = $Result.GetResult<Prisma.$settingPayload, S>

  type settingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<settingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SettingCountAggregateInputType | true
    }

  export interface settingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['setting'], meta: { name: 'setting' } }
    /**
     * Find zero or one Setting that matches the filter.
     * @param {settingFindUniqueArgs} args - Arguments to find a Setting
     * @example
     * // Get one Setting
     * const setting = await prisma.setting.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends settingFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, settingFindUniqueArgs<ExtArgs>>
    ): Prisma__settingClient<$Result.GetResult<Prisma.$settingPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Setting that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {settingFindUniqueOrThrowArgs} args - Arguments to find a Setting
     * @example
     * // Get one Setting
     * const setting = await prisma.setting.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends settingFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, settingFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__settingClient<$Result.GetResult<Prisma.$settingPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Setting that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {settingFindFirstArgs} args - Arguments to find a Setting
     * @example
     * // Get one Setting
     * const setting = await prisma.setting.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends settingFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, settingFindFirstArgs<ExtArgs>>
    ): Prisma__settingClient<$Result.GetResult<Prisma.$settingPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Setting that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {settingFindFirstOrThrowArgs} args - Arguments to find a Setting
     * @example
     * // Get one Setting
     * const setting = await prisma.setting.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends settingFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, settingFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__settingClient<$Result.GetResult<Prisma.$settingPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Settings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {settingFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Settings
     * const settings = await prisma.setting.findMany()
     * 
     * // Get first 10 Settings
     * const settings = await prisma.setting.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const settingWithIdOnly = await prisma.setting.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends settingFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, settingFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$settingPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Setting.
     * @param {settingCreateArgs} args - Arguments to create a Setting.
     * @example
     * // Create one Setting
     * const Setting = await prisma.setting.create({
     *   data: {
     *     // ... data to create a Setting
     *   }
     * })
     * 
    **/
    create<T extends settingCreateArgs<ExtArgs>>(
      args: SelectSubset<T, settingCreateArgs<ExtArgs>>
    ): Prisma__settingClient<$Result.GetResult<Prisma.$settingPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Settings.
     *     @param {settingCreateManyArgs} args - Arguments to create many Settings.
     *     @example
     *     // Create many Settings
     *     const setting = await prisma.setting.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends settingCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, settingCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Setting.
     * @param {settingDeleteArgs} args - Arguments to delete one Setting.
     * @example
     * // Delete one Setting
     * const Setting = await prisma.setting.delete({
     *   where: {
     *     // ... filter to delete one Setting
     *   }
     * })
     * 
    **/
    delete<T extends settingDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, settingDeleteArgs<ExtArgs>>
    ): Prisma__settingClient<$Result.GetResult<Prisma.$settingPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Setting.
     * @param {settingUpdateArgs} args - Arguments to update one Setting.
     * @example
     * // Update one Setting
     * const setting = await prisma.setting.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends settingUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, settingUpdateArgs<ExtArgs>>
    ): Prisma__settingClient<$Result.GetResult<Prisma.$settingPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Settings.
     * @param {settingDeleteManyArgs} args - Arguments to filter Settings to delete.
     * @example
     * // Delete a few Settings
     * const { count } = await prisma.setting.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends settingDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, settingDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {settingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Settings
     * const setting = await prisma.setting.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends settingUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, settingUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Setting.
     * @param {settingUpsertArgs} args - Arguments to update or create a Setting.
     * @example
     * // Update or create a Setting
     * const setting = await prisma.setting.upsert({
     *   create: {
     *     // ... data to create a Setting
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Setting we want to update
     *   }
     * })
    **/
    upsert<T extends settingUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, settingUpsertArgs<ExtArgs>>
    ): Prisma__settingClient<$Result.GetResult<Prisma.$settingPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {settingCountArgs} args - Arguments to filter Settings to count.
     * @example
     * // Count the number of Settings
     * const count = await prisma.setting.count({
     *   where: {
     *     // ... the filter for the Settings we want to count
     *   }
     * })
    **/
    count<T extends settingCountArgs>(
      args?: Subset<T, settingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SettingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Setting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SettingAggregateArgs>(args: Subset<T, SettingAggregateArgs>): Prisma.PrismaPromise<GetSettingAggregateType<T>>

    /**
     * Group by Setting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {settingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends settingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: settingGroupByArgs['orderBy'] }
        : { orderBy?: settingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, settingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSettingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the setting model
   */
  readonly fields: settingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for setting.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__settingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the setting model
   */ 
  interface settingFieldRefs {
    readonly id: FieldRef<"setting", 'Int'>
    readonly facebook: FieldRef<"setting", 'String'>
    readonly line: FieldRef<"setting", 'String'>
    readonly instagram: FieldRef<"setting", 'String'>
    readonly tiktok: FieldRef<"setting", 'String'>
    readonly email: FieldRef<"setting", 'String'>
    readonly phone: FieldRef<"setting", 'String'>
    readonly isActive: FieldRef<"setting", 'Boolean'>
    readonly createdAt: FieldRef<"setting", 'DateTime'>
    readonly updatedAt: FieldRef<"setting", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * setting findUnique
   */
  export type settingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the setting
     */
    select?: settingSelect<ExtArgs> | null
    /**
     * Filter, which setting to fetch.
     */
    where: settingWhereUniqueInput
  }


  /**
   * setting findUniqueOrThrow
   */
  export type settingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the setting
     */
    select?: settingSelect<ExtArgs> | null
    /**
     * Filter, which setting to fetch.
     */
    where: settingWhereUniqueInput
  }


  /**
   * setting findFirst
   */
  export type settingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the setting
     */
    select?: settingSelect<ExtArgs> | null
    /**
     * Filter, which setting to fetch.
     */
    where?: settingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of settings to fetch.
     */
    orderBy?: settingOrderByWithRelationInput | settingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for settings.
     */
    cursor?: settingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of settings.
     */
    distinct?: SettingScalarFieldEnum | SettingScalarFieldEnum[]
  }


  /**
   * setting findFirstOrThrow
   */
  export type settingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the setting
     */
    select?: settingSelect<ExtArgs> | null
    /**
     * Filter, which setting to fetch.
     */
    where?: settingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of settings to fetch.
     */
    orderBy?: settingOrderByWithRelationInput | settingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for settings.
     */
    cursor?: settingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of settings.
     */
    distinct?: SettingScalarFieldEnum | SettingScalarFieldEnum[]
  }


  /**
   * setting findMany
   */
  export type settingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the setting
     */
    select?: settingSelect<ExtArgs> | null
    /**
     * Filter, which settings to fetch.
     */
    where?: settingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of settings to fetch.
     */
    orderBy?: settingOrderByWithRelationInput | settingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing settings.
     */
    cursor?: settingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` settings.
     */
    skip?: number
    distinct?: SettingScalarFieldEnum | SettingScalarFieldEnum[]
  }


  /**
   * setting create
   */
  export type settingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the setting
     */
    select?: settingSelect<ExtArgs> | null
    /**
     * The data needed to create a setting.
     */
    data: XOR<settingCreateInput, settingUncheckedCreateInput>
  }


  /**
   * setting createMany
   */
  export type settingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many settings.
     */
    data: settingCreateManyInput | settingCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * setting update
   */
  export type settingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the setting
     */
    select?: settingSelect<ExtArgs> | null
    /**
     * The data needed to update a setting.
     */
    data: XOR<settingUpdateInput, settingUncheckedUpdateInput>
    /**
     * Choose, which setting to update.
     */
    where: settingWhereUniqueInput
  }


  /**
   * setting updateMany
   */
  export type settingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update settings.
     */
    data: XOR<settingUpdateManyMutationInput, settingUncheckedUpdateManyInput>
    /**
     * Filter which settings to update
     */
    where?: settingWhereInput
  }


  /**
   * setting upsert
   */
  export type settingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the setting
     */
    select?: settingSelect<ExtArgs> | null
    /**
     * The filter to search for the setting to update in case it exists.
     */
    where: settingWhereUniqueInput
    /**
     * In case the setting found by the `where` argument doesn't exist, create a new setting with this data.
     */
    create: XOR<settingCreateInput, settingUncheckedCreateInput>
    /**
     * In case the setting was found with the provided `where` argument, update it with this data.
     */
    update: XOR<settingUpdateInput, settingUncheckedUpdateInput>
  }


  /**
   * setting delete
   */
  export type settingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the setting
     */
    select?: settingSelect<ExtArgs> | null
    /**
     * Filter which setting to delete.
     */
    where: settingWhereUniqueInput
  }


  /**
   * setting deleteMany
   */
  export type settingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which settings to delete
     */
    where?: settingWhereInput
  }


  /**
   * setting without action
   */
  export type settingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the setting
     */
    select?: settingSelect<ExtArgs> | null
  }



  /**
   * Model setting_service
   */

  export type AggregateSetting_service = {
    _count: Setting_serviceCountAggregateOutputType | null
    _avg: Setting_serviceAvgAggregateOutputType | null
    _sum: Setting_serviceSumAggregateOutputType | null
    _min: Setting_serviceMinAggregateOutputType | null
    _max: Setting_serviceMaxAggregateOutputType | null
  }

  export type Setting_serviceAvgAggregateOutputType = {
    id: number | null
  }

  export type Setting_serviceSumAggregateOutputType = {
    id: number | null
  }

  export type Setting_serviceMinAggregateOutputType = {
    id: number | null
    lineNotiToken: string | null
    gmpayToken: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Setting_serviceMaxAggregateOutputType = {
    id: number | null
    lineNotiToken: string | null
    gmpayToken: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Setting_serviceCountAggregateOutputType = {
    id: number
    lineNotiToken: number
    gmpayToken: number
    seo: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Setting_serviceAvgAggregateInputType = {
    id?: true
  }

  export type Setting_serviceSumAggregateInputType = {
    id?: true
  }

  export type Setting_serviceMinAggregateInputType = {
    id?: true
    lineNotiToken?: true
    gmpayToken?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Setting_serviceMaxAggregateInputType = {
    id?: true
    lineNotiToken?: true
    gmpayToken?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Setting_serviceCountAggregateInputType = {
    id?: true
    lineNotiToken?: true
    gmpayToken?: true
    seo?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Setting_serviceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which setting_service to aggregate.
     */
    where?: setting_serviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of setting_services to fetch.
     */
    orderBy?: setting_serviceOrderByWithRelationInput | setting_serviceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: setting_serviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` setting_services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` setting_services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned setting_services
    **/
    _count?: true | Setting_serviceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Setting_serviceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Setting_serviceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Setting_serviceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Setting_serviceMaxAggregateInputType
  }

  export type GetSetting_serviceAggregateType<T extends Setting_serviceAggregateArgs> = {
        [P in keyof T & keyof AggregateSetting_service]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSetting_service[P]>
      : GetScalarType<T[P], AggregateSetting_service[P]>
  }




  export type setting_serviceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: setting_serviceWhereInput
    orderBy?: setting_serviceOrderByWithAggregationInput | setting_serviceOrderByWithAggregationInput[]
    by: Setting_serviceScalarFieldEnum[] | Setting_serviceScalarFieldEnum
    having?: setting_serviceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Setting_serviceCountAggregateInputType | true
    _avg?: Setting_serviceAvgAggregateInputType
    _sum?: Setting_serviceSumAggregateInputType
    _min?: Setting_serviceMinAggregateInputType
    _max?: Setting_serviceMaxAggregateInputType
  }

  export type Setting_serviceGroupByOutputType = {
    id: number
    lineNotiToken: string | null
    gmpayToken: string | null
    seo: JsonValue | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: Setting_serviceCountAggregateOutputType | null
    _avg: Setting_serviceAvgAggregateOutputType | null
    _sum: Setting_serviceSumAggregateOutputType | null
    _min: Setting_serviceMinAggregateOutputType | null
    _max: Setting_serviceMaxAggregateOutputType | null
  }

  type GetSetting_serviceGroupByPayload<T extends setting_serviceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Setting_serviceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Setting_serviceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Setting_serviceGroupByOutputType[P]>
            : GetScalarType<T[P], Setting_serviceGroupByOutputType[P]>
        }
      >
    >


  export type setting_serviceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lineNotiToken?: boolean
    gmpayToken?: boolean
    seo?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["setting_service"]>

  export type setting_serviceSelectScalar = {
    id?: boolean
    lineNotiToken?: boolean
    gmpayToken?: boolean
    seo?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $setting_servicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "setting_service"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      lineNotiToken: string | null
      gmpayToken: string | null
      seo: Prisma.JsonValue | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["setting_service"]>
    composites: {}
  }


  type setting_serviceGetPayload<S extends boolean | null | undefined | setting_serviceDefaultArgs> = $Result.GetResult<Prisma.$setting_servicePayload, S>

  type setting_serviceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<setting_serviceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Setting_serviceCountAggregateInputType | true
    }

  export interface setting_serviceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['setting_service'], meta: { name: 'setting_service' } }
    /**
     * Find zero or one Setting_service that matches the filter.
     * @param {setting_serviceFindUniqueArgs} args - Arguments to find a Setting_service
     * @example
     * // Get one Setting_service
     * const setting_service = await prisma.setting_service.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends setting_serviceFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, setting_serviceFindUniqueArgs<ExtArgs>>
    ): Prisma__setting_serviceClient<$Result.GetResult<Prisma.$setting_servicePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Setting_service that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {setting_serviceFindUniqueOrThrowArgs} args - Arguments to find a Setting_service
     * @example
     * // Get one Setting_service
     * const setting_service = await prisma.setting_service.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends setting_serviceFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, setting_serviceFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__setting_serviceClient<$Result.GetResult<Prisma.$setting_servicePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Setting_service that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {setting_serviceFindFirstArgs} args - Arguments to find a Setting_service
     * @example
     * // Get one Setting_service
     * const setting_service = await prisma.setting_service.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends setting_serviceFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, setting_serviceFindFirstArgs<ExtArgs>>
    ): Prisma__setting_serviceClient<$Result.GetResult<Prisma.$setting_servicePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Setting_service that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {setting_serviceFindFirstOrThrowArgs} args - Arguments to find a Setting_service
     * @example
     * // Get one Setting_service
     * const setting_service = await prisma.setting_service.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends setting_serviceFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, setting_serviceFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__setting_serviceClient<$Result.GetResult<Prisma.$setting_servicePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Setting_services that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {setting_serviceFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Setting_services
     * const setting_services = await prisma.setting_service.findMany()
     * 
     * // Get first 10 Setting_services
     * const setting_services = await prisma.setting_service.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const setting_serviceWithIdOnly = await prisma.setting_service.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends setting_serviceFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, setting_serviceFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$setting_servicePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Setting_service.
     * @param {setting_serviceCreateArgs} args - Arguments to create a Setting_service.
     * @example
     * // Create one Setting_service
     * const Setting_service = await prisma.setting_service.create({
     *   data: {
     *     // ... data to create a Setting_service
     *   }
     * })
     * 
    **/
    create<T extends setting_serviceCreateArgs<ExtArgs>>(
      args: SelectSubset<T, setting_serviceCreateArgs<ExtArgs>>
    ): Prisma__setting_serviceClient<$Result.GetResult<Prisma.$setting_servicePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Setting_services.
     *     @param {setting_serviceCreateManyArgs} args - Arguments to create many Setting_services.
     *     @example
     *     // Create many Setting_services
     *     const setting_service = await prisma.setting_service.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends setting_serviceCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, setting_serviceCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Setting_service.
     * @param {setting_serviceDeleteArgs} args - Arguments to delete one Setting_service.
     * @example
     * // Delete one Setting_service
     * const Setting_service = await prisma.setting_service.delete({
     *   where: {
     *     // ... filter to delete one Setting_service
     *   }
     * })
     * 
    **/
    delete<T extends setting_serviceDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, setting_serviceDeleteArgs<ExtArgs>>
    ): Prisma__setting_serviceClient<$Result.GetResult<Prisma.$setting_servicePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Setting_service.
     * @param {setting_serviceUpdateArgs} args - Arguments to update one Setting_service.
     * @example
     * // Update one Setting_service
     * const setting_service = await prisma.setting_service.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends setting_serviceUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, setting_serviceUpdateArgs<ExtArgs>>
    ): Prisma__setting_serviceClient<$Result.GetResult<Prisma.$setting_servicePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Setting_services.
     * @param {setting_serviceDeleteManyArgs} args - Arguments to filter Setting_services to delete.
     * @example
     * // Delete a few Setting_services
     * const { count } = await prisma.setting_service.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends setting_serviceDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, setting_serviceDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Setting_services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {setting_serviceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Setting_services
     * const setting_service = await prisma.setting_service.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends setting_serviceUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, setting_serviceUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Setting_service.
     * @param {setting_serviceUpsertArgs} args - Arguments to update or create a Setting_service.
     * @example
     * // Update or create a Setting_service
     * const setting_service = await prisma.setting_service.upsert({
     *   create: {
     *     // ... data to create a Setting_service
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Setting_service we want to update
     *   }
     * })
    **/
    upsert<T extends setting_serviceUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, setting_serviceUpsertArgs<ExtArgs>>
    ): Prisma__setting_serviceClient<$Result.GetResult<Prisma.$setting_servicePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Setting_services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {setting_serviceCountArgs} args - Arguments to filter Setting_services to count.
     * @example
     * // Count the number of Setting_services
     * const count = await prisma.setting_service.count({
     *   where: {
     *     // ... the filter for the Setting_services we want to count
     *   }
     * })
    **/
    count<T extends setting_serviceCountArgs>(
      args?: Subset<T, setting_serviceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Setting_serviceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Setting_service.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Setting_serviceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Setting_serviceAggregateArgs>(args: Subset<T, Setting_serviceAggregateArgs>): Prisma.PrismaPromise<GetSetting_serviceAggregateType<T>>

    /**
     * Group by Setting_service.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {setting_serviceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends setting_serviceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: setting_serviceGroupByArgs['orderBy'] }
        : { orderBy?: setting_serviceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, setting_serviceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSetting_serviceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the setting_service model
   */
  readonly fields: setting_serviceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for setting_service.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__setting_serviceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the setting_service model
   */ 
  interface setting_serviceFieldRefs {
    readonly id: FieldRef<"setting_service", 'Int'>
    readonly lineNotiToken: FieldRef<"setting_service", 'String'>
    readonly gmpayToken: FieldRef<"setting_service", 'String'>
    readonly seo: FieldRef<"setting_service", 'Json'>
    readonly isActive: FieldRef<"setting_service", 'Boolean'>
    readonly createdAt: FieldRef<"setting_service", 'DateTime'>
    readonly updatedAt: FieldRef<"setting_service", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * setting_service findUnique
   */
  export type setting_serviceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the setting_service
     */
    select?: setting_serviceSelect<ExtArgs> | null
    /**
     * Filter, which setting_service to fetch.
     */
    where: setting_serviceWhereUniqueInput
  }


  /**
   * setting_service findUniqueOrThrow
   */
  export type setting_serviceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the setting_service
     */
    select?: setting_serviceSelect<ExtArgs> | null
    /**
     * Filter, which setting_service to fetch.
     */
    where: setting_serviceWhereUniqueInput
  }


  /**
   * setting_service findFirst
   */
  export type setting_serviceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the setting_service
     */
    select?: setting_serviceSelect<ExtArgs> | null
    /**
     * Filter, which setting_service to fetch.
     */
    where?: setting_serviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of setting_services to fetch.
     */
    orderBy?: setting_serviceOrderByWithRelationInput | setting_serviceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for setting_services.
     */
    cursor?: setting_serviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` setting_services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` setting_services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of setting_services.
     */
    distinct?: Setting_serviceScalarFieldEnum | Setting_serviceScalarFieldEnum[]
  }


  /**
   * setting_service findFirstOrThrow
   */
  export type setting_serviceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the setting_service
     */
    select?: setting_serviceSelect<ExtArgs> | null
    /**
     * Filter, which setting_service to fetch.
     */
    where?: setting_serviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of setting_services to fetch.
     */
    orderBy?: setting_serviceOrderByWithRelationInput | setting_serviceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for setting_services.
     */
    cursor?: setting_serviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` setting_services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` setting_services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of setting_services.
     */
    distinct?: Setting_serviceScalarFieldEnum | Setting_serviceScalarFieldEnum[]
  }


  /**
   * setting_service findMany
   */
  export type setting_serviceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the setting_service
     */
    select?: setting_serviceSelect<ExtArgs> | null
    /**
     * Filter, which setting_services to fetch.
     */
    where?: setting_serviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of setting_services to fetch.
     */
    orderBy?: setting_serviceOrderByWithRelationInput | setting_serviceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing setting_services.
     */
    cursor?: setting_serviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` setting_services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` setting_services.
     */
    skip?: number
    distinct?: Setting_serviceScalarFieldEnum | Setting_serviceScalarFieldEnum[]
  }


  /**
   * setting_service create
   */
  export type setting_serviceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the setting_service
     */
    select?: setting_serviceSelect<ExtArgs> | null
    /**
     * The data needed to create a setting_service.
     */
    data: XOR<setting_serviceCreateInput, setting_serviceUncheckedCreateInput>
  }


  /**
   * setting_service createMany
   */
  export type setting_serviceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many setting_services.
     */
    data: setting_serviceCreateManyInput | setting_serviceCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * setting_service update
   */
  export type setting_serviceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the setting_service
     */
    select?: setting_serviceSelect<ExtArgs> | null
    /**
     * The data needed to update a setting_service.
     */
    data: XOR<setting_serviceUpdateInput, setting_serviceUncheckedUpdateInput>
    /**
     * Choose, which setting_service to update.
     */
    where: setting_serviceWhereUniqueInput
  }


  /**
   * setting_service updateMany
   */
  export type setting_serviceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update setting_services.
     */
    data: XOR<setting_serviceUpdateManyMutationInput, setting_serviceUncheckedUpdateManyInput>
    /**
     * Filter which setting_services to update
     */
    where?: setting_serviceWhereInput
  }


  /**
   * setting_service upsert
   */
  export type setting_serviceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the setting_service
     */
    select?: setting_serviceSelect<ExtArgs> | null
    /**
     * The filter to search for the setting_service to update in case it exists.
     */
    where: setting_serviceWhereUniqueInput
    /**
     * In case the setting_service found by the `where` argument doesn't exist, create a new setting_service with this data.
     */
    create: XOR<setting_serviceCreateInput, setting_serviceUncheckedCreateInput>
    /**
     * In case the setting_service was found with the provided `where` argument, update it with this data.
     */
    update: XOR<setting_serviceUpdateInput, setting_serviceUncheckedUpdateInput>
  }


  /**
   * setting_service delete
   */
  export type setting_serviceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the setting_service
     */
    select?: setting_serviceSelect<ExtArgs> | null
    /**
     * Filter which setting_service to delete.
     */
    where: setting_serviceWhereUniqueInput
  }


  /**
   * setting_service deleteMany
   */
  export type setting_serviceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which setting_services to delete
     */
    where?: setting_serviceWhereInput
  }


  /**
   * setting_service without action
   */
  export type setting_serviceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the setting_service
     */
    select?: setting_serviceSelect<ExtArgs> | null
  }



  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const AdminScalarFieldEnum: {
    id: 'id',
    userName: 'userName',
    fname: 'fname',
    lname: 'lname',
    fullname: 'fullname',
    role: 'role',
    permission: 'permission',
    email: 'email',
    avatarPath: 'avatarPath',
    avatarSrc: 'avatarSrc',
    phone: 'phone',
    refreshToken: 'refreshToken',
    password: 'password',
    passwordRt: 'passwordRt',
    ipv4: 'ipv4',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AdminScalarFieldEnum = (typeof AdminScalarFieldEnum)[keyof typeof AdminScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    avatarPath: 'avatarPath',
    avatarSrc: 'avatarSrc',
    fname: 'fname',
    lname: 'lname',
    fullname: 'fullname',
    email: 'email',
    phone: 'phone',
    credit: 'credit',
    point: 'point',
    lineId: 'lineId',
    baned: 'baned',
    ipv4: 'ipv4',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const User_credit_transactionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    adminId: 'adminId',
    updateBy: 'updateBy',
    updateType: 'updateType',
    beforeUpdate: 'beforeUpdate',
    afterUpdate: 'afterUpdate',
    credit: 'credit',
    remark: 'remark',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type User_credit_transactionScalarFieldEnum = (typeof User_credit_transactionScalarFieldEnum)[keyof typeof User_credit_transactionScalarFieldEnum]


  export const User_point_transactionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    adminId: 'adminId',
    updateBy: 'updateBy',
    updateType: 'updateType',
    beforeUpdate: 'beforeUpdate',
    afterUpdate: 'afterUpdate',
    point: 'point',
    remark: 'remark',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type User_point_transactionScalarFieldEnum = (typeof User_point_transactionScalarFieldEnum)[keyof typeof User_point_transactionScalarFieldEnum]


  export const Payment_transactionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    price: 'price',
    refCode: 'refCode',
    status: 'status',
    base64: 'base64',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Payment_transactionScalarFieldEnum = (typeof Payment_transactionScalarFieldEnum)[keyof typeof Payment_transactionScalarFieldEnum]


  export const AddressScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    default: 'default',
    addressName: 'addressName',
    details: 'details',
    remarks: 'remarks',
    receiverFname: 'receiverFname',
    receiverLname: 'receiverLname',
    receiverFullname: 'receiverFullname',
    receiverPhone: 'receiverPhone',
    houseNo: 'houseNo',
    villageNo: 'villageNo',
    road: 'road',
    province: 'province',
    district: 'district',
    subDistrict: 'subDistrict',
    postCode: 'postCode',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AddressScalarFieldEnum = (typeof AddressScalarFieldEnum)[keyof typeof AddressScalarFieldEnum]


  export const BrandScalarFieldEnum: {
    id: 'id',
    name: 'name',
    detail: 'detail',
    imagePath: 'imagePath',
    imageSrc: 'imageSrc',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BrandScalarFieldEnum = (typeof BrandScalarFieldEnum)[keyof typeof BrandScalarFieldEnum]


  export const TagScalarFieldEnum: {
    id: 'id',
    name: 'name',
    detail: 'detail',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TagScalarFieldEnum = (typeof TagScalarFieldEnum)[keyof typeof TagScalarFieldEnum]


  export const CategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    detail: 'detail',
    imagePath: 'imagePath',
    imageSrc: 'imageSrc',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CategoryScalarFieldEnum = (typeof CategoryScalarFieldEnum)[keyof typeof CategoryScalarFieldEnum]


  export const Sub_categoryScalarFieldEnum: {
    id: 'id',
    categoryId: 'categoryId',
    name: 'name',
    detail: 'detail',
    imagePath: 'imagePath',
    imageSrc: 'imageSrc',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Sub_categoryScalarFieldEnum = (typeof Sub_categoryScalarFieldEnum)[keyof typeof Sub_categoryScalarFieldEnum]


  export const Product_reviewScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    productId: 'productId',
    adminId: 'adminId',
    detail: 'detail',
    rating: 'rating',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Product_reviewScalarFieldEnum = (typeof Product_reviewScalarFieldEnum)[keyof typeof Product_reviewScalarFieldEnum]


  export const Review_imageScalarFieldEnum: {
    id: 'id',
    imagePath: 'imagePath',
    imageSrc: 'imageSrc',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Review_imageScalarFieldEnum = (typeof Review_imageScalarFieldEnum)[keyof typeof Review_imageScalarFieldEnum]


  export const ProductScalarFieldEnum: {
    id: 'id',
    brandId: 'brandId',
    adminId: 'adminId',
    name: 'name',
    shortName: 'shortName',
    detail: 'detail',
    isDiscount: 'isDiscount',
    discountPercent: 'discountPercent',
    minPrice: 'minPrice',
    maxPrice: 'maxPrice',
    slug: 'slug',
    cardImgPath: 'cardImgPath',
    cardImgSrc: 'cardImgSrc',
    optionFirst: 'optionFirst',
    optionSecond: 'optionSecond',
    isWholesale: 'isWholesale',
    rating: 'rating',
    sold: 'sold',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


  export const Product_tagScalarFieldEnum: {
    id: 'id',
    productId: 'productId',
    tagId: 'tagId',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Product_tagScalarFieldEnum = (typeof Product_tagScalarFieldEnum)[keyof typeof Product_tagScalarFieldEnum]


  export const Product_wholesaleScalarFieldEnum: {
    id: 'id',
    productId: 'productId',
    min: 'min',
    price: 'price',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Product_wholesaleScalarFieldEnum = (typeof Product_wholesaleScalarFieldEnum)[keyof typeof Product_wholesaleScalarFieldEnum]


  export const Product_option_firstScalarFieldEnum: {
    id: 'id',
    productId: 'productId',
    name: 'name',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Product_option_firstScalarFieldEnum = (typeof Product_option_firstScalarFieldEnum)[keyof typeof Product_option_firstScalarFieldEnum]


  export const Product_option_secondScalarFieldEnum: {
    id: 'id',
    productId: 'productId',
    name: 'name',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Product_option_secondScalarFieldEnum = (typeof Product_option_secondScalarFieldEnum)[keyof typeof Product_option_secondScalarFieldEnum]


  export const Product_priceScalarFieldEnum: {
    id: 'id',
    productId: 'productId',
    product_option_firstId: 'product_option_firstId',
    product_option_secondId: 'product_option_secondId',
    price: 'price',
    sku: 'sku',
    isWholesale: 'isWholesale'
  };

  export type Product_priceScalarFieldEnum = (typeof Product_priceScalarFieldEnum)[keyof typeof Product_priceScalarFieldEnum]


  export const Product_detailScalarFieldEnum: {
    id: 'id',
    productId: 'productId',
    name: 'name',
    details: 'details',
    imagePath: 'imagePath',
    imageSrc: 'imageSrc',
    videoPath: 'videoPath',
    videoSrc: 'videoSrc',
    videoType: 'videoType',
    link: 'link',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Product_detailScalarFieldEnum = (typeof Product_detailScalarFieldEnum)[keyof typeof Product_detailScalarFieldEnum]


  export const Product_imageScalarFieldEnum: {
    id: 'id',
    name: 'name',
    path: 'path',
    src: 'src',
    sequence: 'sequence',
    productId: 'productId',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Product_imageScalarFieldEnum = (typeof Product_imageScalarFieldEnum)[keyof typeof Product_imageScalarFieldEnum]


  export const Product_specScalarFieldEnum: {
    id: 'id',
    name: 'name',
    data: 'data',
    productId: 'productId'
  };

  export type Product_specScalarFieldEnum = (typeof Product_specScalarFieldEnum)[keyof typeof Product_specScalarFieldEnum]


  export const CartScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    productId: 'productId',
    product_priceId: 'product_priceId',
    qty: 'qty',
    price: 'price',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CartScalarFieldEnum = (typeof CartScalarFieldEnum)[keyof typeof CartScalarFieldEnum]


  export const OrderScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    statusNow: 'statusNow',
    status: 'status',
    paymentType: 'paymentType',
    paymentStatus: 'paymentStatus',
    createUsing: 'createUsing',
    pointUsing: 'pointUsing',
    orderPrice: 'orderPrice',
    deliveryPrice: 'deliveryPrice',
    netPrice: 'netPrice',
    orderDiscount: 'orderDiscount',
    deliveryDiscount: 'deliveryDiscount',
    orderDiscountCode: 'orderDiscountCode',
    deliveryDiscountCode: 'deliveryDiscountCode',
    addressId: 'addressId',
    addressData: 'addressData',
    userData: 'userData',
    isReject: 'isReject',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OrderScalarFieldEnum = (typeof OrderScalarFieldEnum)[keyof typeof OrderScalarFieldEnum]


  export const Order_productScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    productId: 'productId',
    orderId: 'orderId',
    product_priceId: 'product_priceId',
    qty: 'qty',
    price: 'price',
    productData: 'productData',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Order_productScalarFieldEnum = (typeof Order_productScalarFieldEnum)[keyof typeof Order_productScalarFieldEnum]


  export const SettingScalarFieldEnum: {
    id: 'id',
    facebook: 'facebook',
    line: 'line',
    instagram: 'instagram',
    tiktok: 'tiktok',
    email: 'email',
    phone: 'phone',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SettingScalarFieldEnum = (typeof SettingScalarFieldEnum)[keyof typeof SettingScalarFieldEnum]


  export const Setting_serviceScalarFieldEnum: {
    id: 'id',
    lineNotiToken: 'lineNotiToken',
    gmpayToken: 'gmpayToken',
    seo: 'seo',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Setting_serviceScalarFieldEnum = (typeof Setting_serviceScalarFieldEnum)[keyof typeof Setting_serviceScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type adminWhereInput = {
    AND?: adminWhereInput | adminWhereInput[]
    OR?: adminWhereInput[]
    NOT?: adminWhereInput | adminWhereInput[]
    id?: IntFilter<"admin"> | number
    userName?: StringFilter<"admin"> | string
    fname?: StringNullableFilter<"admin"> | string | null
    lname?: StringNullableFilter<"admin"> | string | null
    fullname?: StringNullableFilter<"admin"> | string | null
    role?: StringFilter<"admin"> | string
    permission?: JsonNullableFilter<"admin">
    email?: StringFilter<"admin"> | string
    avatarPath?: StringNullableFilter<"admin"> | string | null
    avatarSrc?: StringNullableFilter<"admin"> | string | null
    phone?: StringFilter<"admin"> | string
    refreshToken?: StringNullableFilter<"admin"> | string | null
    password?: StringFilter<"admin"> | string
    passwordRt?: StringNullableFilter<"admin"> | string | null
    ipv4?: StringNullableFilter<"admin"> | string | null
    isActive?: BoolFilter<"admin"> | boolean
    createdAt?: DateTimeFilter<"admin"> | Date | string
    updatedAt?: DateTimeFilter<"admin"> | Date | string
    user_credit_transaction?: User_credit_transactionListRelationFilter
    user_point_transaction?: User_point_transactionListRelationFilter
    product_review?: Product_reviewListRelationFilter
    product?: ProductListRelationFilter
  }

  export type adminOrderByWithRelationInput = {
    id?: SortOrder
    userName?: SortOrder
    fname?: SortOrderInput | SortOrder
    lname?: SortOrderInput | SortOrder
    fullname?: SortOrderInput | SortOrder
    role?: SortOrder
    permission?: SortOrderInput | SortOrder
    email?: SortOrder
    avatarPath?: SortOrderInput | SortOrder
    avatarSrc?: SortOrderInput | SortOrder
    phone?: SortOrder
    refreshToken?: SortOrderInput | SortOrder
    password?: SortOrder
    passwordRt?: SortOrderInput | SortOrder
    ipv4?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user_credit_transaction?: user_credit_transactionOrderByRelationAggregateInput
    user_point_transaction?: user_point_transactionOrderByRelationAggregateInput
    product_review?: product_reviewOrderByRelationAggregateInput
    product?: productOrderByRelationAggregateInput
  }

  export type adminWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userName?: string
    email?: string
    AND?: adminWhereInput | adminWhereInput[]
    OR?: adminWhereInput[]
    NOT?: adminWhereInput | adminWhereInput[]
    fname?: StringNullableFilter<"admin"> | string | null
    lname?: StringNullableFilter<"admin"> | string | null
    fullname?: StringNullableFilter<"admin"> | string | null
    role?: StringFilter<"admin"> | string
    permission?: JsonNullableFilter<"admin">
    avatarPath?: StringNullableFilter<"admin"> | string | null
    avatarSrc?: StringNullableFilter<"admin"> | string | null
    phone?: StringFilter<"admin"> | string
    refreshToken?: StringNullableFilter<"admin"> | string | null
    password?: StringFilter<"admin"> | string
    passwordRt?: StringNullableFilter<"admin"> | string | null
    ipv4?: StringNullableFilter<"admin"> | string | null
    isActive?: BoolFilter<"admin"> | boolean
    createdAt?: DateTimeFilter<"admin"> | Date | string
    updatedAt?: DateTimeFilter<"admin"> | Date | string
    user_credit_transaction?: User_credit_transactionListRelationFilter
    user_point_transaction?: User_point_transactionListRelationFilter
    product_review?: Product_reviewListRelationFilter
    product?: ProductListRelationFilter
  }, "id" | "userName" | "email">

  export type adminOrderByWithAggregationInput = {
    id?: SortOrder
    userName?: SortOrder
    fname?: SortOrderInput | SortOrder
    lname?: SortOrderInput | SortOrder
    fullname?: SortOrderInput | SortOrder
    role?: SortOrder
    permission?: SortOrderInput | SortOrder
    email?: SortOrder
    avatarPath?: SortOrderInput | SortOrder
    avatarSrc?: SortOrderInput | SortOrder
    phone?: SortOrder
    refreshToken?: SortOrderInput | SortOrder
    password?: SortOrder
    passwordRt?: SortOrderInput | SortOrder
    ipv4?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: adminCountOrderByAggregateInput
    _avg?: adminAvgOrderByAggregateInput
    _max?: adminMaxOrderByAggregateInput
    _min?: adminMinOrderByAggregateInput
    _sum?: adminSumOrderByAggregateInput
  }

  export type adminScalarWhereWithAggregatesInput = {
    AND?: adminScalarWhereWithAggregatesInput | adminScalarWhereWithAggregatesInput[]
    OR?: adminScalarWhereWithAggregatesInput[]
    NOT?: adminScalarWhereWithAggregatesInput | adminScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"admin"> | number
    userName?: StringWithAggregatesFilter<"admin"> | string
    fname?: StringNullableWithAggregatesFilter<"admin"> | string | null
    lname?: StringNullableWithAggregatesFilter<"admin"> | string | null
    fullname?: StringNullableWithAggregatesFilter<"admin"> | string | null
    role?: StringWithAggregatesFilter<"admin"> | string
    permission?: JsonNullableWithAggregatesFilter<"admin">
    email?: StringWithAggregatesFilter<"admin"> | string
    avatarPath?: StringNullableWithAggregatesFilter<"admin"> | string | null
    avatarSrc?: StringNullableWithAggregatesFilter<"admin"> | string | null
    phone?: StringWithAggregatesFilter<"admin"> | string
    refreshToken?: StringNullableWithAggregatesFilter<"admin"> | string | null
    password?: StringWithAggregatesFilter<"admin"> | string
    passwordRt?: StringNullableWithAggregatesFilter<"admin"> | string | null
    ipv4?: StringNullableWithAggregatesFilter<"admin"> | string | null
    isActive?: BoolWithAggregatesFilter<"admin"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"admin"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"admin"> | Date | string
  }

  export type userWhereInput = {
    AND?: userWhereInput | userWhereInput[]
    OR?: userWhereInput[]
    NOT?: userWhereInput | userWhereInput[]
    id?: IntFilter<"user"> | number
    avatarPath?: StringNullableFilter<"user"> | string | null
    avatarSrc?: StringNullableFilter<"user"> | string | null
    fname?: StringNullableFilter<"user"> | string | null
    lname?: StringNullableFilter<"user"> | string | null
    fullname?: StringNullableFilter<"user"> | string | null
    email?: StringFilter<"user"> | string
    phone?: StringFilter<"user"> | string
    credit?: FloatFilter<"user"> | number
    point?: FloatFilter<"user"> | number
    lineId?: StringNullableFilter<"user"> | string | null
    baned?: BoolFilter<"user"> | boolean
    ipv4?: StringNullableFilter<"user"> | string | null
    isActive?: BoolFilter<"user"> | boolean
    createdAt?: DateTimeFilter<"user"> | Date | string
    updatedAt?: DateTimeFilter<"user"> | Date | string
    address?: AddressListRelationFilter
    user_credit_transaction?: User_credit_transactionListRelationFilter
    payment_transaction?: Payment_transactionListRelationFilter
    user_point_transaction?: User_point_transactionListRelationFilter
    product_review?: Product_reviewListRelationFilter
    cart?: CartListRelationFilter
    order?: OrderListRelationFilter
    order_product?: Order_productListRelationFilter
  }

  export type userOrderByWithRelationInput = {
    id?: SortOrder
    avatarPath?: SortOrderInput | SortOrder
    avatarSrc?: SortOrderInput | SortOrder
    fname?: SortOrderInput | SortOrder
    lname?: SortOrderInput | SortOrder
    fullname?: SortOrderInput | SortOrder
    email?: SortOrder
    phone?: SortOrder
    credit?: SortOrder
    point?: SortOrder
    lineId?: SortOrderInput | SortOrder
    baned?: SortOrder
    ipv4?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    address?: addressOrderByRelationAggregateInput
    user_credit_transaction?: user_credit_transactionOrderByRelationAggregateInput
    payment_transaction?: payment_transactionOrderByRelationAggregateInput
    user_point_transaction?: user_point_transactionOrderByRelationAggregateInput
    product_review?: product_reviewOrderByRelationAggregateInput
    cart?: cartOrderByRelationAggregateInput
    order?: orderOrderByRelationAggregateInput
    order_product?: order_productOrderByRelationAggregateInput
  }

  export type userWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    phone?: string
    AND?: userWhereInput | userWhereInput[]
    OR?: userWhereInput[]
    NOT?: userWhereInput | userWhereInput[]
    avatarPath?: StringNullableFilter<"user"> | string | null
    avatarSrc?: StringNullableFilter<"user"> | string | null
    fname?: StringNullableFilter<"user"> | string | null
    lname?: StringNullableFilter<"user"> | string | null
    fullname?: StringNullableFilter<"user"> | string | null
    credit?: FloatFilter<"user"> | number
    point?: FloatFilter<"user"> | number
    lineId?: StringNullableFilter<"user"> | string | null
    baned?: BoolFilter<"user"> | boolean
    ipv4?: StringNullableFilter<"user"> | string | null
    isActive?: BoolFilter<"user"> | boolean
    createdAt?: DateTimeFilter<"user"> | Date | string
    updatedAt?: DateTimeFilter<"user"> | Date | string
    address?: AddressListRelationFilter
    user_credit_transaction?: User_credit_transactionListRelationFilter
    payment_transaction?: Payment_transactionListRelationFilter
    user_point_transaction?: User_point_transactionListRelationFilter
    product_review?: Product_reviewListRelationFilter
    cart?: CartListRelationFilter
    order?: OrderListRelationFilter
    order_product?: Order_productListRelationFilter
  }, "id" | "email" | "phone">

  export type userOrderByWithAggregationInput = {
    id?: SortOrder
    avatarPath?: SortOrderInput | SortOrder
    avatarSrc?: SortOrderInput | SortOrder
    fname?: SortOrderInput | SortOrder
    lname?: SortOrderInput | SortOrder
    fullname?: SortOrderInput | SortOrder
    email?: SortOrder
    phone?: SortOrder
    credit?: SortOrder
    point?: SortOrder
    lineId?: SortOrderInput | SortOrder
    baned?: SortOrder
    ipv4?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: userCountOrderByAggregateInput
    _avg?: userAvgOrderByAggregateInput
    _max?: userMaxOrderByAggregateInput
    _min?: userMinOrderByAggregateInput
    _sum?: userSumOrderByAggregateInput
  }

  export type userScalarWhereWithAggregatesInput = {
    AND?: userScalarWhereWithAggregatesInput | userScalarWhereWithAggregatesInput[]
    OR?: userScalarWhereWithAggregatesInput[]
    NOT?: userScalarWhereWithAggregatesInput | userScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"user"> | number
    avatarPath?: StringNullableWithAggregatesFilter<"user"> | string | null
    avatarSrc?: StringNullableWithAggregatesFilter<"user"> | string | null
    fname?: StringNullableWithAggregatesFilter<"user"> | string | null
    lname?: StringNullableWithAggregatesFilter<"user"> | string | null
    fullname?: StringNullableWithAggregatesFilter<"user"> | string | null
    email?: StringWithAggregatesFilter<"user"> | string
    phone?: StringWithAggregatesFilter<"user"> | string
    credit?: FloatWithAggregatesFilter<"user"> | number
    point?: FloatWithAggregatesFilter<"user"> | number
    lineId?: StringNullableWithAggregatesFilter<"user"> | string | null
    baned?: BoolWithAggregatesFilter<"user"> | boolean
    ipv4?: StringNullableWithAggregatesFilter<"user"> | string | null
    isActive?: BoolWithAggregatesFilter<"user"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"user"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"user"> | Date | string
  }

  export type user_credit_transactionWhereInput = {
    AND?: user_credit_transactionWhereInput | user_credit_transactionWhereInput[]
    OR?: user_credit_transactionWhereInput[]
    NOT?: user_credit_transactionWhereInput | user_credit_transactionWhereInput[]
    id?: IntFilter<"user_credit_transaction"> | number
    userId?: IntFilter<"user_credit_transaction"> | number
    adminId?: IntNullableFilter<"user_credit_transaction"> | number | null
    updateBy?: StringFilter<"user_credit_transaction"> | string
    updateType?: StringFilter<"user_credit_transaction"> | string
    beforeUpdate?: FloatFilter<"user_credit_transaction"> | number
    afterUpdate?: FloatFilter<"user_credit_transaction"> | number
    credit?: FloatFilter<"user_credit_transaction"> | number
    remark?: StringNullableFilter<"user_credit_transaction"> | string | null
    isActive?: BoolFilter<"user_credit_transaction"> | boolean
    createdAt?: DateTimeFilter<"user_credit_transaction"> | Date | string
    updatedAt?: DateTimeFilter<"user_credit_transaction"> | Date | string
    user?: XOR<UserRelationFilter, userWhereInput>
    admin?: XOR<AdminNullableRelationFilter, adminWhereInput> | null
  }

  export type user_credit_transactionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    adminId?: SortOrderInput | SortOrder
    updateBy?: SortOrder
    updateType?: SortOrder
    beforeUpdate?: SortOrder
    afterUpdate?: SortOrder
    credit?: SortOrder
    remark?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: userOrderByWithRelationInput
    admin?: adminOrderByWithRelationInput
  }

  export type user_credit_transactionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: user_credit_transactionWhereInput | user_credit_transactionWhereInput[]
    OR?: user_credit_transactionWhereInput[]
    NOT?: user_credit_transactionWhereInput | user_credit_transactionWhereInput[]
    userId?: IntFilter<"user_credit_transaction"> | number
    adminId?: IntNullableFilter<"user_credit_transaction"> | number | null
    updateBy?: StringFilter<"user_credit_transaction"> | string
    updateType?: StringFilter<"user_credit_transaction"> | string
    beforeUpdate?: FloatFilter<"user_credit_transaction"> | number
    afterUpdate?: FloatFilter<"user_credit_transaction"> | number
    credit?: FloatFilter<"user_credit_transaction"> | number
    remark?: StringNullableFilter<"user_credit_transaction"> | string | null
    isActive?: BoolFilter<"user_credit_transaction"> | boolean
    createdAt?: DateTimeFilter<"user_credit_transaction"> | Date | string
    updatedAt?: DateTimeFilter<"user_credit_transaction"> | Date | string
    user?: XOR<UserRelationFilter, userWhereInput>
    admin?: XOR<AdminNullableRelationFilter, adminWhereInput> | null
  }, "id">

  export type user_credit_transactionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    adminId?: SortOrderInput | SortOrder
    updateBy?: SortOrder
    updateType?: SortOrder
    beforeUpdate?: SortOrder
    afterUpdate?: SortOrder
    credit?: SortOrder
    remark?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: user_credit_transactionCountOrderByAggregateInput
    _avg?: user_credit_transactionAvgOrderByAggregateInput
    _max?: user_credit_transactionMaxOrderByAggregateInput
    _min?: user_credit_transactionMinOrderByAggregateInput
    _sum?: user_credit_transactionSumOrderByAggregateInput
  }

  export type user_credit_transactionScalarWhereWithAggregatesInput = {
    AND?: user_credit_transactionScalarWhereWithAggregatesInput | user_credit_transactionScalarWhereWithAggregatesInput[]
    OR?: user_credit_transactionScalarWhereWithAggregatesInput[]
    NOT?: user_credit_transactionScalarWhereWithAggregatesInput | user_credit_transactionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"user_credit_transaction"> | number
    userId?: IntWithAggregatesFilter<"user_credit_transaction"> | number
    adminId?: IntNullableWithAggregatesFilter<"user_credit_transaction"> | number | null
    updateBy?: StringWithAggregatesFilter<"user_credit_transaction"> | string
    updateType?: StringWithAggregatesFilter<"user_credit_transaction"> | string
    beforeUpdate?: FloatWithAggregatesFilter<"user_credit_transaction"> | number
    afterUpdate?: FloatWithAggregatesFilter<"user_credit_transaction"> | number
    credit?: FloatWithAggregatesFilter<"user_credit_transaction"> | number
    remark?: StringNullableWithAggregatesFilter<"user_credit_transaction"> | string | null
    isActive?: BoolWithAggregatesFilter<"user_credit_transaction"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"user_credit_transaction"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"user_credit_transaction"> | Date | string
  }

  export type user_point_transactionWhereInput = {
    AND?: user_point_transactionWhereInput | user_point_transactionWhereInput[]
    OR?: user_point_transactionWhereInput[]
    NOT?: user_point_transactionWhereInput | user_point_transactionWhereInput[]
    id?: IntFilter<"user_point_transaction"> | number
    userId?: IntFilter<"user_point_transaction"> | number
    adminId?: IntNullableFilter<"user_point_transaction"> | number | null
    updateBy?: StringFilter<"user_point_transaction"> | string
    updateType?: StringFilter<"user_point_transaction"> | string
    beforeUpdate?: FloatFilter<"user_point_transaction"> | number
    afterUpdate?: FloatFilter<"user_point_transaction"> | number
    point?: FloatFilter<"user_point_transaction"> | number
    remark?: StringNullableFilter<"user_point_transaction"> | string | null
    isActive?: BoolFilter<"user_point_transaction"> | boolean
    createdAt?: DateTimeFilter<"user_point_transaction"> | Date | string
    updatedAt?: DateTimeFilter<"user_point_transaction"> | Date | string
    user?: XOR<UserRelationFilter, userWhereInput>
    admin?: XOR<AdminNullableRelationFilter, adminWhereInput> | null
  }

  export type user_point_transactionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    adminId?: SortOrderInput | SortOrder
    updateBy?: SortOrder
    updateType?: SortOrder
    beforeUpdate?: SortOrder
    afterUpdate?: SortOrder
    point?: SortOrder
    remark?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: userOrderByWithRelationInput
    admin?: adminOrderByWithRelationInput
  }

  export type user_point_transactionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: user_point_transactionWhereInput | user_point_transactionWhereInput[]
    OR?: user_point_transactionWhereInput[]
    NOT?: user_point_transactionWhereInput | user_point_transactionWhereInput[]
    userId?: IntFilter<"user_point_transaction"> | number
    adminId?: IntNullableFilter<"user_point_transaction"> | number | null
    updateBy?: StringFilter<"user_point_transaction"> | string
    updateType?: StringFilter<"user_point_transaction"> | string
    beforeUpdate?: FloatFilter<"user_point_transaction"> | number
    afterUpdate?: FloatFilter<"user_point_transaction"> | number
    point?: FloatFilter<"user_point_transaction"> | number
    remark?: StringNullableFilter<"user_point_transaction"> | string | null
    isActive?: BoolFilter<"user_point_transaction"> | boolean
    createdAt?: DateTimeFilter<"user_point_transaction"> | Date | string
    updatedAt?: DateTimeFilter<"user_point_transaction"> | Date | string
    user?: XOR<UserRelationFilter, userWhereInput>
    admin?: XOR<AdminNullableRelationFilter, adminWhereInput> | null
  }, "id">

  export type user_point_transactionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    adminId?: SortOrderInput | SortOrder
    updateBy?: SortOrder
    updateType?: SortOrder
    beforeUpdate?: SortOrder
    afterUpdate?: SortOrder
    point?: SortOrder
    remark?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: user_point_transactionCountOrderByAggregateInput
    _avg?: user_point_transactionAvgOrderByAggregateInput
    _max?: user_point_transactionMaxOrderByAggregateInput
    _min?: user_point_transactionMinOrderByAggregateInput
    _sum?: user_point_transactionSumOrderByAggregateInput
  }

  export type user_point_transactionScalarWhereWithAggregatesInput = {
    AND?: user_point_transactionScalarWhereWithAggregatesInput | user_point_transactionScalarWhereWithAggregatesInput[]
    OR?: user_point_transactionScalarWhereWithAggregatesInput[]
    NOT?: user_point_transactionScalarWhereWithAggregatesInput | user_point_transactionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"user_point_transaction"> | number
    userId?: IntWithAggregatesFilter<"user_point_transaction"> | number
    adminId?: IntNullableWithAggregatesFilter<"user_point_transaction"> | number | null
    updateBy?: StringWithAggregatesFilter<"user_point_transaction"> | string
    updateType?: StringWithAggregatesFilter<"user_point_transaction"> | string
    beforeUpdate?: FloatWithAggregatesFilter<"user_point_transaction"> | number
    afterUpdate?: FloatWithAggregatesFilter<"user_point_transaction"> | number
    point?: FloatWithAggregatesFilter<"user_point_transaction"> | number
    remark?: StringNullableWithAggregatesFilter<"user_point_transaction"> | string | null
    isActive?: BoolWithAggregatesFilter<"user_point_transaction"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"user_point_transaction"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"user_point_transaction"> | Date | string
  }

  export type payment_transactionWhereInput = {
    AND?: payment_transactionWhereInput | payment_transactionWhereInput[]
    OR?: payment_transactionWhereInput[]
    NOT?: payment_transactionWhereInput | payment_transactionWhereInput[]
    id?: IntFilter<"payment_transaction"> | number
    userId?: IntFilter<"payment_transaction"> | number
    price?: FloatFilter<"payment_transaction"> | number
    refCode?: StringFilter<"payment_transaction"> | string
    status?: StringFilter<"payment_transaction"> | string
    base64?: StringNullableFilter<"payment_transaction"> | string | null
    isActive?: BoolFilter<"payment_transaction"> | boolean
    createdAt?: DateTimeFilter<"payment_transaction"> | Date | string
    updatedAt?: DateTimeFilter<"payment_transaction"> | Date | string
    user?: XOR<UserRelationFilter, userWhereInput>
  }

  export type payment_transactionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    price?: SortOrder
    refCode?: SortOrder
    status?: SortOrder
    base64?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: userOrderByWithRelationInput
  }

  export type payment_transactionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    refCode?: string
    AND?: payment_transactionWhereInput | payment_transactionWhereInput[]
    OR?: payment_transactionWhereInput[]
    NOT?: payment_transactionWhereInput | payment_transactionWhereInput[]
    userId?: IntFilter<"payment_transaction"> | number
    price?: FloatFilter<"payment_transaction"> | number
    status?: StringFilter<"payment_transaction"> | string
    base64?: StringNullableFilter<"payment_transaction"> | string | null
    isActive?: BoolFilter<"payment_transaction"> | boolean
    createdAt?: DateTimeFilter<"payment_transaction"> | Date | string
    updatedAt?: DateTimeFilter<"payment_transaction"> | Date | string
    user?: XOR<UserRelationFilter, userWhereInput>
  }, "id" | "refCode">

  export type payment_transactionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    price?: SortOrder
    refCode?: SortOrder
    status?: SortOrder
    base64?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: payment_transactionCountOrderByAggregateInput
    _avg?: payment_transactionAvgOrderByAggregateInput
    _max?: payment_transactionMaxOrderByAggregateInput
    _min?: payment_transactionMinOrderByAggregateInput
    _sum?: payment_transactionSumOrderByAggregateInput
  }

  export type payment_transactionScalarWhereWithAggregatesInput = {
    AND?: payment_transactionScalarWhereWithAggregatesInput | payment_transactionScalarWhereWithAggregatesInput[]
    OR?: payment_transactionScalarWhereWithAggregatesInput[]
    NOT?: payment_transactionScalarWhereWithAggregatesInput | payment_transactionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"payment_transaction"> | number
    userId?: IntWithAggregatesFilter<"payment_transaction"> | number
    price?: FloatWithAggregatesFilter<"payment_transaction"> | number
    refCode?: StringWithAggregatesFilter<"payment_transaction"> | string
    status?: StringWithAggregatesFilter<"payment_transaction"> | string
    base64?: StringNullableWithAggregatesFilter<"payment_transaction"> | string | null
    isActive?: BoolWithAggregatesFilter<"payment_transaction"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"payment_transaction"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"payment_transaction"> | Date | string
  }

  export type addressWhereInput = {
    AND?: addressWhereInput | addressWhereInput[]
    OR?: addressWhereInput[]
    NOT?: addressWhereInput | addressWhereInput[]
    id?: IntFilter<"address"> | number
    userId?: IntFilter<"address"> | number
    default?: BoolFilter<"address"> | boolean
    addressName?: StringFilter<"address"> | string
    details?: StringNullableFilter<"address"> | string | null
    remarks?: StringNullableFilter<"address"> | string | null
    receiverFname?: StringFilter<"address"> | string
    receiverLname?: StringFilter<"address"> | string
    receiverFullname?: StringFilter<"address"> | string
    receiverPhone?: StringFilter<"address"> | string
    houseNo?: StringFilter<"address"> | string
    villageNo?: StringNullableFilter<"address"> | string | null
    road?: StringNullableFilter<"address"> | string | null
    province?: StringFilter<"address"> | string
    district?: StringFilter<"address"> | string
    subDistrict?: StringFilter<"address"> | string
    postCode?: StringFilter<"address"> | string
    isActive?: BoolFilter<"address"> | boolean
    createdAt?: DateTimeFilter<"address"> | Date | string
    updatedAt?: DateTimeFilter<"address"> | Date | string
    user?: XOR<UserRelationFilter, userWhereInput>
    order?: OrderListRelationFilter
  }

  export type addressOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    default?: SortOrder
    addressName?: SortOrder
    details?: SortOrderInput | SortOrder
    remarks?: SortOrderInput | SortOrder
    receiverFname?: SortOrder
    receiverLname?: SortOrder
    receiverFullname?: SortOrder
    receiverPhone?: SortOrder
    houseNo?: SortOrder
    villageNo?: SortOrderInput | SortOrder
    road?: SortOrderInput | SortOrder
    province?: SortOrder
    district?: SortOrder
    subDistrict?: SortOrder
    postCode?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: userOrderByWithRelationInput
    order?: orderOrderByRelationAggregateInput
  }

  export type addressWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: addressWhereInput | addressWhereInput[]
    OR?: addressWhereInput[]
    NOT?: addressWhereInput | addressWhereInput[]
    userId?: IntFilter<"address"> | number
    default?: BoolFilter<"address"> | boolean
    addressName?: StringFilter<"address"> | string
    details?: StringNullableFilter<"address"> | string | null
    remarks?: StringNullableFilter<"address"> | string | null
    receiverFname?: StringFilter<"address"> | string
    receiverLname?: StringFilter<"address"> | string
    receiverFullname?: StringFilter<"address"> | string
    receiverPhone?: StringFilter<"address"> | string
    houseNo?: StringFilter<"address"> | string
    villageNo?: StringNullableFilter<"address"> | string | null
    road?: StringNullableFilter<"address"> | string | null
    province?: StringFilter<"address"> | string
    district?: StringFilter<"address"> | string
    subDistrict?: StringFilter<"address"> | string
    postCode?: StringFilter<"address"> | string
    isActive?: BoolFilter<"address"> | boolean
    createdAt?: DateTimeFilter<"address"> | Date | string
    updatedAt?: DateTimeFilter<"address"> | Date | string
    user?: XOR<UserRelationFilter, userWhereInput>
    order?: OrderListRelationFilter
  }, "id">

  export type addressOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    default?: SortOrder
    addressName?: SortOrder
    details?: SortOrderInput | SortOrder
    remarks?: SortOrderInput | SortOrder
    receiverFname?: SortOrder
    receiverLname?: SortOrder
    receiverFullname?: SortOrder
    receiverPhone?: SortOrder
    houseNo?: SortOrder
    villageNo?: SortOrderInput | SortOrder
    road?: SortOrderInput | SortOrder
    province?: SortOrder
    district?: SortOrder
    subDistrict?: SortOrder
    postCode?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: addressCountOrderByAggregateInput
    _avg?: addressAvgOrderByAggregateInput
    _max?: addressMaxOrderByAggregateInput
    _min?: addressMinOrderByAggregateInput
    _sum?: addressSumOrderByAggregateInput
  }

  export type addressScalarWhereWithAggregatesInput = {
    AND?: addressScalarWhereWithAggregatesInput | addressScalarWhereWithAggregatesInput[]
    OR?: addressScalarWhereWithAggregatesInput[]
    NOT?: addressScalarWhereWithAggregatesInput | addressScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"address"> | number
    userId?: IntWithAggregatesFilter<"address"> | number
    default?: BoolWithAggregatesFilter<"address"> | boolean
    addressName?: StringWithAggregatesFilter<"address"> | string
    details?: StringNullableWithAggregatesFilter<"address"> | string | null
    remarks?: StringNullableWithAggregatesFilter<"address"> | string | null
    receiverFname?: StringWithAggregatesFilter<"address"> | string
    receiverLname?: StringWithAggregatesFilter<"address"> | string
    receiverFullname?: StringWithAggregatesFilter<"address"> | string
    receiverPhone?: StringWithAggregatesFilter<"address"> | string
    houseNo?: StringWithAggregatesFilter<"address"> | string
    villageNo?: StringNullableWithAggregatesFilter<"address"> | string | null
    road?: StringNullableWithAggregatesFilter<"address"> | string | null
    province?: StringWithAggregatesFilter<"address"> | string
    district?: StringWithAggregatesFilter<"address"> | string
    subDistrict?: StringWithAggregatesFilter<"address"> | string
    postCode?: StringWithAggregatesFilter<"address"> | string
    isActive?: BoolWithAggregatesFilter<"address"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"address"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"address"> | Date | string
  }

  export type brandWhereInput = {
    AND?: brandWhereInput | brandWhereInput[]
    OR?: brandWhereInput[]
    NOT?: brandWhereInput | brandWhereInput[]
    id?: IntFilter<"brand"> | number
    name?: StringFilter<"brand"> | string
    detail?: StringNullableFilter<"brand"> | string | null
    imagePath?: StringNullableFilter<"brand"> | string | null
    imageSrc?: StringNullableFilter<"brand"> | string | null
    isActive?: BoolFilter<"brand"> | boolean
    createdAt?: DateTimeFilter<"brand"> | Date | string
    updatedAt?: DateTimeFilter<"brand"> | Date | string
    product?: ProductListRelationFilter
  }

  export type brandOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    detail?: SortOrderInput | SortOrder
    imagePath?: SortOrderInput | SortOrder
    imageSrc?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    product?: productOrderByRelationAggregateInput
  }

  export type brandWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: brandWhereInput | brandWhereInput[]
    OR?: brandWhereInput[]
    NOT?: brandWhereInput | brandWhereInput[]
    detail?: StringNullableFilter<"brand"> | string | null
    imagePath?: StringNullableFilter<"brand"> | string | null
    imageSrc?: StringNullableFilter<"brand"> | string | null
    isActive?: BoolFilter<"brand"> | boolean
    createdAt?: DateTimeFilter<"brand"> | Date | string
    updatedAt?: DateTimeFilter<"brand"> | Date | string
    product?: ProductListRelationFilter
  }, "id" | "name">

  export type brandOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    detail?: SortOrderInput | SortOrder
    imagePath?: SortOrderInput | SortOrder
    imageSrc?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: brandCountOrderByAggregateInput
    _avg?: brandAvgOrderByAggregateInput
    _max?: brandMaxOrderByAggregateInput
    _min?: brandMinOrderByAggregateInput
    _sum?: brandSumOrderByAggregateInput
  }

  export type brandScalarWhereWithAggregatesInput = {
    AND?: brandScalarWhereWithAggregatesInput | brandScalarWhereWithAggregatesInput[]
    OR?: brandScalarWhereWithAggregatesInput[]
    NOT?: brandScalarWhereWithAggregatesInput | brandScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"brand"> | number
    name?: StringWithAggregatesFilter<"brand"> | string
    detail?: StringNullableWithAggregatesFilter<"brand"> | string | null
    imagePath?: StringNullableWithAggregatesFilter<"brand"> | string | null
    imageSrc?: StringNullableWithAggregatesFilter<"brand"> | string | null
    isActive?: BoolWithAggregatesFilter<"brand"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"brand"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"brand"> | Date | string
  }

  export type tagWhereInput = {
    AND?: tagWhereInput | tagWhereInput[]
    OR?: tagWhereInput[]
    NOT?: tagWhereInput | tagWhereInput[]
    id?: IntFilter<"tag"> | number
    name?: StringFilter<"tag"> | string
    detail?: StringNullableFilter<"tag"> | string | null
    isActive?: BoolFilter<"tag"> | boolean
    createdAt?: DateTimeFilter<"tag"> | Date | string
    updatedAt?: DateTimeFilter<"tag"> | Date | string
    product_tag?: Product_tagListRelationFilter
  }

  export type tagOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    detail?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    product_tag?: product_tagOrderByRelationAggregateInput
  }

  export type tagWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: tagWhereInput | tagWhereInput[]
    OR?: tagWhereInput[]
    NOT?: tagWhereInput | tagWhereInput[]
    detail?: StringNullableFilter<"tag"> | string | null
    isActive?: BoolFilter<"tag"> | boolean
    createdAt?: DateTimeFilter<"tag"> | Date | string
    updatedAt?: DateTimeFilter<"tag"> | Date | string
    product_tag?: Product_tagListRelationFilter
  }, "id" | "name">

  export type tagOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    detail?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: tagCountOrderByAggregateInput
    _avg?: tagAvgOrderByAggregateInput
    _max?: tagMaxOrderByAggregateInput
    _min?: tagMinOrderByAggregateInput
    _sum?: tagSumOrderByAggregateInput
  }

  export type tagScalarWhereWithAggregatesInput = {
    AND?: tagScalarWhereWithAggregatesInput | tagScalarWhereWithAggregatesInput[]
    OR?: tagScalarWhereWithAggregatesInput[]
    NOT?: tagScalarWhereWithAggregatesInput | tagScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"tag"> | number
    name?: StringWithAggregatesFilter<"tag"> | string
    detail?: StringNullableWithAggregatesFilter<"tag"> | string | null
    isActive?: BoolWithAggregatesFilter<"tag"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"tag"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"tag"> | Date | string
  }

  export type categoryWhereInput = {
    AND?: categoryWhereInput | categoryWhereInput[]
    OR?: categoryWhereInput[]
    NOT?: categoryWhereInput | categoryWhereInput[]
    id?: IntFilter<"category"> | number
    name?: StringFilter<"category"> | string
    detail?: StringNullableFilter<"category"> | string | null
    imagePath?: StringNullableFilter<"category"> | string | null
    imageSrc?: StringNullableFilter<"category"> | string | null
    isActive?: BoolFilter<"category"> | boolean
    createdAt?: DateTimeFilter<"category"> | Date | string
    updatedAt?: DateTimeFilter<"category"> | Date | string
    sub_category?: Sub_categoryListRelationFilter
  }

  export type categoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    detail?: SortOrderInput | SortOrder
    imagePath?: SortOrderInput | SortOrder
    imageSrc?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sub_category?: sub_categoryOrderByRelationAggregateInput
  }

  export type categoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: categoryWhereInput | categoryWhereInput[]
    OR?: categoryWhereInput[]
    NOT?: categoryWhereInput | categoryWhereInput[]
    name?: StringFilter<"category"> | string
    detail?: StringNullableFilter<"category"> | string | null
    imagePath?: StringNullableFilter<"category"> | string | null
    imageSrc?: StringNullableFilter<"category"> | string | null
    isActive?: BoolFilter<"category"> | boolean
    createdAt?: DateTimeFilter<"category"> | Date | string
    updatedAt?: DateTimeFilter<"category"> | Date | string
    sub_category?: Sub_categoryListRelationFilter
  }, "id">

  export type categoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    detail?: SortOrderInput | SortOrder
    imagePath?: SortOrderInput | SortOrder
    imageSrc?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: categoryCountOrderByAggregateInput
    _avg?: categoryAvgOrderByAggregateInput
    _max?: categoryMaxOrderByAggregateInput
    _min?: categoryMinOrderByAggregateInput
    _sum?: categorySumOrderByAggregateInput
  }

  export type categoryScalarWhereWithAggregatesInput = {
    AND?: categoryScalarWhereWithAggregatesInput | categoryScalarWhereWithAggregatesInput[]
    OR?: categoryScalarWhereWithAggregatesInput[]
    NOT?: categoryScalarWhereWithAggregatesInput | categoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"category"> | number
    name?: StringWithAggregatesFilter<"category"> | string
    detail?: StringNullableWithAggregatesFilter<"category"> | string | null
    imagePath?: StringNullableWithAggregatesFilter<"category"> | string | null
    imageSrc?: StringNullableWithAggregatesFilter<"category"> | string | null
    isActive?: BoolWithAggregatesFilter<"category"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"category"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"category"> | Date | string
  }

  export type sub_categoryWhereInput = {
    AND?: sub_categoryWhereInput | sub_categoryWhereInput[]
    OR?: sub_categoryWhereInput[]
    NOT?: sub_categoryWhereInput | sub_categoryWhereInput[]
    id?: IntFilter<"sub_category"> | number
    categoryId?: IntFilter<"sub_category"> | number
    name?: StringFilter<"sub_category"> | string
    detail?: StringNullableFilter<"sub_category"> | string | null
    imagePath?: StringNullableFilter<"sub_category"> | string | null
    imageSrc?: StringNullableFilter<"sub_category"> | string | null
    isActive?: BoolFilter<"sub_category"> | boolean
    createdAt?: DateTimeFilter<"sub_category"> | Date | string
    updatedAt?: DateTimeFilter<"sub_category"> | Date | string
    category?: XOR<CategoryRelationFilter, categoryWhereInput>
  }

  export type sub_categoryOrderByWithRelationInput = {
    id?: SortOrder
    categoryId?: SortOrder
    name?: SortOrder
    detail?: SortOrderInput | SortOrder
    imagePath?: SortOrderInput | SortOrder
    imageSrc?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    category?: categoryOrderByWithRelationInput
  }

  export type sub_categoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: sub_categoryWhereInput | sub_categoryWhereInput[]
    OR?: sub_categoryWhereInput[]
    NOT?: sub_categoryWhereInput | sub_categoryWhereInput[]
    categoryId?: IntFilter<"sub_category"> | number
    name?: StringFilter<"sub_category"> | string
    detail?: StringNullableFilter<"sub_category"> | string | null
    imagePath?: StringNullableFilter<"sub_category"> | string | null
    imageSrc?: StringNullableFilter<"sub_category"> | string | null
    isActive?: BoolFilter<"sub_category"> | boolean
    createdAt?: DateTimeFilter<"sub_category"> | Date | string
    updatedAt?: DateTimeFilter<"sub_category"> | Date | string
    category?: XOR<CategoryRelationFilter, categoryWhereInput>
  }, "id">

  export type sub_categoryOrderByWithAggregationInput = {
    id?: SortOrder
    categoryId?: SortOrder
    name?: SortOrder
    detail?: SortOrderInput | SortOrder
    imagePath?: SortOrderInput | SortOrder
    imageSrc?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: sub_categoryCountOrderByAggregateInput
    _avg?: sub_categoryAvgOrderByAggregateInput
    _max?: sub_categoryMaxOrderByAggregateInput
    _min?: sub_categoryMinOrderByAggregateInput
    _sum?: sub_categorySumOrderByAggregateInput
  }

  export type sub_categoryScalarWhereWithAggregatesInput = {
    AND?: sub_categoryScalarWhereWithAggregatesInput | sub_categoryScalarWhereWithAggregatesInput[]
    OR?: sub_categoryScalarWhereWithAggregatesInput[]
    NOT?: sub_categoryScalarWhereWithAggregatesInput | sub_categoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"sub_category"> | number
    categoryId?: IntWithAggregatesFilter<"sub_category"> | number
    name?: StringWithAggregatesFilter<"sub_category"> | string
    detail?: StringNullableWithAggregatesFilter<"sub_category"> | string | null
    imagePath?: StringNullableWithAggregatesFilter<"sub_category"> | string | null
    imageSrc?: StringNullableWithAggregatesFilter<"sub_category"> | string | null
    isActive?: BoolWithAggregatesFilter<"sub_category"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"sub_category"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"sub_category"> | Date | string
  }

  export type product_reviewWhereInput = {
    AND?: product_reviewWhereInput | product_reviewWhereInput[]
    OR?: product_reviewWhereInput[]
    NOT?: product_reviewWhereInput | product_reviewWhereInput[]
    id?: IntFilter<"product_review"> | number
    userId?: IntFilter<"product_review"> | number
    productId?: IntFilter<"product_review"> | number
    adminId?: IntFilter<"product_review"> | number
    detail?: StringNullableFilter<"product_review"> | string | null
    rating?: IntFilter<"product_review"> | number
    isActive?: BoolFilter<"product_review"> | boolean
    createdAt?: DateTimeFilter<"product_review"> | Date | string
    updatedAt?: DateTimeFilter<"product_review"> | Date | string
    user?: XOR<UserRelationFilter, userWhereInput>
    product?: XOR<ProductRelationFilter, productWhereInput>
    admin?: XOR<AdminRelationFilter, adminWhereInput>
  }

  export type product_reviewOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
    adminId?: SortOrder
    detail?: SortOrderInput | SortOrder
    rating?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: userOrderByWithRelationInput
    product?: productOrderByWithRelationInput
    admin?: adminOrderByWithRelationInput
  }

  export type product_reviewWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: product_reviewWhereInput | product_reviewWhereInput[]
    OR?: product_reviewWhereInput[]
    NOT?: product_reviewWhereInput | product_reviewWhereInput[]
    userId?: IntFilter<"product_review"> | number
    productId?: IntFilter<"product_review"> | number
    adminId?: IntFilter<"product_review"> | number
    detail?: StringNullableFilter<"product_review"> | string | null
    rating?: IntFilter<"product_review"> | number
    isActive?: BoolFilter<"product_review"> | boolean
    createdAt?: DateTimeFilter<"product_review"> | Date | string
    updatedAt?: DateTimeFilter<"product_review"> | Date | string
    user?: XOR<UserRelationFilter, userWhereInput>
    product?: XOR<ProductRelationFilter, productWhereInput>
    admin?: XOR<AdminRelationFilter, adminWhereInput>
  }, "id">

  export type product_reviewOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
    adminId?: SortOrder
    detail?: SortOrderInput | SortOrder
    rating?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: product_reviewCountOrderByAggregateInput
    _avg?: product_reviewAvgOrderByAggregateInput
    _max?: product_reviewMaxOrderByAggregateInput
    _min?: product_reviewMinOrderByAggregateInput
    _sum?: product_reviewSumOrderByAggregateInput
  }

  export type product_reviewScalarWhereWithAggregatesInput = {
    AND?: product_reviewScalarWhereWithAggregatesInput | product_reviewScalarWhereWithAggregatesInput[]
    OR?: product_reviewScalarWhereWithAggregatesInput[]
    NOT?: product_reviewScalarWhereWithAggregatesInput | product_reviewScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"product_review"> | number
    userId?: IntWithAggregatesFilter<"product_review"> | number
    productId?: IntWithAggregatesFilter<"product_review"> | number
    adminId?: IntWithAggregatesFilter<"product_review"> | number
    detail?: StringNullableWithAggregatesFilter<"product_review"> | string | null
    rating?: IntWithAggregatesFilter<"product_review"> | number
    isActive?: BoolWithAggregatesFilter<"product_review"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"product_review"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"product_review"> | Date | string
  }

  export type review_imageWhereInput = {
    AND?: review_imageWhereInput | review_imageWhereInput[]
    OR?: review_imageWhereInput[]
    NOT?: review_imageWhereInput | review_imageWhereInput[]
    id?: IntFilter<"review_image"> | number
    imagePath?: StringNullableFilter<"review_image"> | string | null
    imageSrc?: StringNullableFilter<"review_image"> | string | null
    isActive?: BoolFilter<"review_image"> | boolean
    createdAt?: DateTimeFilter<"review_image"> | Date | string
    updatedAt?: DateTimeFilter<"review_image"> | Date | string
  }

  export type review_imageOrderByWithRelationInput = {
    id?: SortOrder
    imagePath?: SortOrderInput | SortOrder
    imageSrc?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type review_imageWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: review_imageWhereInput | review_imageWhereInput[]
    OR?: review_imageWhereInput[]
    NOT?: review_imageWhereInput | review_imageWhereInput[]
    imagePath?: StringNullableFilter<"review_image"> | string | null
    imageSrc?: StringNullableFilter<"review_image"> | string | null
    isActive?: BoolFilter<"review_image"> | boolean
    createdAt?: DateTimeFilter<"review_image"> | Date | string
    updatedAt?: DateTimeFilter<"review_image"> | Date | string
  }, "id">

  export type review_imageOrderByWithAggregationInput = {
    id?: SortOrder
    imagePath?: SortOrderInput | SortOrder
    imageSrc?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: review_imageCountOrderByAggregateInput
    _avg?: review_imageAvgOrderByAggregateInput
    _max?: review_imageMaxOrderByAggregateInput
    _min?: review_imageMinOrderByAggregateInput
    _sum?: review_imageSumOrderByAggregateInput
  }

  export type review_imageScalarWhereWithAggregatesInput = {
    AND?: review_imageScalarWhereWithAggregatesInput | review_imageScalarWhereWithAggregatesInput[]
    OR?: review_imageScalarWhereWithAggregatesInput[]
    NOT?: review_imageScalarWhereWithAggregatesInput | review_imageScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"review_image"> | number
    imagePath?: StringNullableWithAggregatesFilter<"review_image"> | string | null
    imageSrc?: StringNullableWithAggregatesFilter<"review_image"> | string | null
    isActive?: BoolWithAggregatesFilter<"review_image"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"review_image"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"review_image"> | Date | string
  }

  export type productWhereInput = {
    AND?: productWhereInput | productWhereInput[]
    OR?: productWhereInput[]
    NOT?: productWhereInput | productWhereInput[]
    id?: IntFilter<"product"> | number
    brandId?: IntFilter<"product"> | number
    adminId?: IntFilter<"product"> | number
    name?: StringFilter<"product"> | string
    shortName?: StringNullableFilter<"product"> | string | null
    detail?: StringNullableFilter<"product"> | string | null
    isDiscount?: BoolFilter<"product"> | boolean
    discountPercent?: IntFilter<"product"> | number
    minPrice?: FloatFilter<"product"> | number
    maxPrice?: FloatFilter<"product"> | number
    slug?: StringFilter<"product"> | string
    cardImgPath?: StringFilter<"product"> | string
    cardImgSrc?: StringFilter<"product"> | string
    optionFirst?: StringNullableFilter<"product"> | string | null
    optionSecond?: StringNullableFilter<"product"> | string | null
    isWholesale?: BoolFilter<"product"> | boolean
    rating?: IntFilter<"product"> | number
    sold?: IntFilter<"product"> | number
    isActive?: BoolFilter<"product"> | boolean
    createdAt?: DateTimeFilter<"product"> | Date | string
    updatedAt?: DateTimeFilter<"product"> | Date | string
    brand?: XOR<BrandRelationFilter, brandWhereInput>
    admin?: XOR<AdminRelationFilter, adminWhereInput>
    product_image?: Product_imageListRelationFilter
    product_spec?: Product_specListRelationFilter
    product_detail?: Product_detailListRelationFilter
    product_option_first?: Product_option_firstListRelationFilter
    product_option_second?: Product_option_secondListRelationFilter
    product_price?: Product_priceListRelationFilter
    product_wholesale?: Product_wholesaleListRelationFilter
    product_review?: Product_reviewListRelationFilter
    product_tag?: Product_tagListRelationFilter
    cart?: CartListRelationFilter
    order_product?: Order_productListRelationFilter
  }

  export type productOrderByWithRelationInput = {
    id?: SortOrder
    brandId?: SortOrder
    adminId?: SortOrder
    name?: SortOrder
    shortName?: SortOrderInput | SortOrder
    detail?: SortOrderInput | SortOrder
    isDiscount?: SortOrder
    discountPercent?: SortOrder
    minPrice?: SortOrder
    maxPrice?: SortOrder
    slug?: SortOrder
    cardImgPath?: SortOrder
    cardImgSrc?: SortOrder
    optionFirst?: SortOrderInput | SortOrder
    optionSecond?: SortOrderInput | SortOrder
    isWholesale?: SortOrder
    rating?: SortOrder
    sold?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    brand?: brandOrderByWithRelationInput
    admin?: adminOrderByWithRelationInput
    product_image?: product_imageOrderByRelationAggregateInput
    product_spec?: product_specOrderByRelationAggregateInput
    product_detail?: product_detailOrderByRelationAggregateInput
    product_option_first?: product_option_firstOrderByRelationAggregateInput
    product_option_second?: product_option_secondOrderByRelationAggregateInput
    product_price?: product_priceOrderByRelationAggregateInput
    product_wholesale?: product_wholesaleOrderByRelationAggregateInput
    product_review?: product_reviewOrderByRelationAggregateInput
    product_tag?: product_tagOrderByRelationAggregateInput
    cart?: cartOrderByRelationAggregateInput
    order_product?: order_productOrderByRelationAggregateInput
  }

  export type productWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: productWhereInput | productWhereInput[]
    OR?: productWhereInput[]
    NOT?: productWhereInput | productWhereInput[]
    brandId?: IntFilter<"product"> | number
    adminId?: IntFilter<"product"> | number
    name?: StringFilter<"product"> | string
    shortName?: StringNullableFilter<"product"> | string | null
    detail?: StringNullableFilter<"product"> | string | null
    isDiscount?: BoolFilter<"product"> | boolean
    discountPercent?: IntFilter<"product"> | number
    minPrice?: FloatFilter<"product"> | number
    maxPrice?: FloatFilter<"product"> | number
    slug?: StringFilter<"product"> | string
    cardImgPath?: StringFilter<"product"> | string
    cardImgSrc?: StringFilter<"product"> | string
    optionFirst?: StringNullableFilter<"product"> | string | null
    optionSecond?: StringNullableFilter<"product"> | string | null
    isWholesale?: BoolFilter<"product"> | boolean
    rating?: IntFilter<"product"> | number
    sold?: IntFilter<"product"> | number
    isActive?: BoolFilter<"product"> | boolean
    createdAt?: DateTimeFilter<"product"> | Date | string
    updatedAt?: DateTimeFilter<"product"> | Date | string
    brand?: XOR<BrandRelationFilter, brandWhereInput>
    admin?: XOR<AdminRelationFilter, adminWhereInput>
    product_image?: Product_imageListRelationFilter
    product_spec?: Product_specListRelationFilter
    product_detail?: Product_detailListRelationFilter
    product_option_first?: Product_option_firstListRelationFilter
    product_option_second?: Product_option_secondListRelationFilter
    product_price?: Product_priceListRelationFilter
    product_wholesale?: Product_wholesaleListRelationFilter
    product_review?: Product_reviewListRelationFilter
    product_tag?: Product_tagListRelationFilter
    cart?: CartListRelationFilter
    order_product?: Order_productListRelationFilter
  }, "id">

  export type productOrderByWithAggregationInput = {
    id?: SortOrder
    brandId?: SortOrder
    adminId?: SortOrder
    name?: SortOrder
    shortName?: SortOrderInput | SortOrder
    detail?: SortOrderInput | SortOrder
    isDiscount?: SortOrder
    discountPercent?: SortOrder
    minPrice?: SortOrder
    maxPrice?: SortOrder
    slug?: SortOrder
    cardImgPath?: SortOrder
    cardImgSrc?: SortOrder
    optionFirst?: SortOrderInput | SortOrder
    optionSecond?: SortOrderInput | SortOrder
    isWholesale?: SortOrder
    rating?: SortOrder
    sold?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: productCountOrderByAggregateInput
    _avg?: productAvgOrderByAggregateInput
    _max?: productMaxOrderByAggregateInput
    _min?: productMinOrderByAggregateInput
    _sum?: productSumOrderByAggregateInput
  }

  export type productScalarWhereWithAggregatesInput = {
    AND?: productScalarWhereWithAggregatesInput | productScalarWhereWithAggregatesInput[]
    OR?: productScalarWhereWithAggregatesInput[]
    NOT?: productScalarWhereWithAggregatesInput | productScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"product"> | number
    brandId?: IntWithAggregatesFilter<"product"> | number
    adminId?: IntWithAggregatesFilter<"product"> | number
    name?: StringWithAggregatesFilter<"product"> | string
    shortName?: StringNullableWithAggregatesFilter<"product"> | string | null
    detail?: StringNullableWithAggregatesFilter<"product"> | string | null
    isDiscount?: BoolWithAggregatesFilter<"product"> | boolean
    discountPercent?: IntWithAggregatesFilter<"product"> | number
    minPrice?: FloatWithAggregatesFilter<"product"> | number
    maxPrice?: FloatWithAggregatesFilter<"product"> | number
    slug?: StringWithAggregatesFilter<"product"> | string
    cardImgPath?: StringWithAggregatesFilter<"product"> | string
    cardImgSrc?: StringWithAggregatesFilter<"product"> | string
    optionFirst?: StringNullableWithAggregatesFilter<"product"> | string | null
    optionSecond?: StringNullableWithAggregatesFilter<"product"> | string | null
    isWholesale?: BoolWithAggregatesFilter<"product"> | boolean
    rating?: IntWithAggregatesFilter<"product"> | number
    sold?: IntWithAggregatesFilter<"product"> | number
    isActive?: BoolWithAggregatesFilter<"product"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"product"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"product"> | Date | string
  }

  export type product_tagWhereInput = {
    AND?: product_tagWhereInput | product_tagWhereInput[]
    OR?: product_tagWhereInput[]
    NOT?: product_tagWhereInput | product_tagWhereInput[]
    id?: IntFilter<"product_tag"> | number
    productId?: IntFilter<"product_tag"> | number
    tagId?: IntFilter<"product_tag"> | number
    isActive?: BoolFilter<"product_tag"> | boolean
    createdAt?: DateTimeFilter<"product_tag"> | Date | string
    updatedAt?: DateTimeFilter<"product_tag"> | Date | string
    product?: XOR<ProductRelationFilter, productWhereInput>
    tag?: XOR<TagRelationFilter, tagWhereInput>
  }

  export type product_tagOrderByWithRelationInput = {
    id?: SortOrder
    productId?: SortOrder
    tagId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    product?: productOrderByWithRelationInput
    tag?: tagOrderByWithRelationInput
  }

  export type product_tagWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: product_tagWhereInput | product_tagWhereInput[]
    OR?: product_tagWhereInput[]
    NOT?: product_tagWhereInput | product_tagWhereInput[]
    productId?: IntFilter<"product_tag"> | number
    tagId?: IntFilter<"product_tag"> | number
    isActive?: BoolFilter<"product_tag"> | boolean
    createdAt?: DateTimeFilter<"product_tag"> | Date | string
    updatedAt?: DateTimeFilter<"product_tag"> | Date | string
    product?: XOR<ProductRelationFilter, productWhereInput>
    tag?: XOR<TagRelationFilter, tagWhereInput>
  }, "id">

  export type product_tagOrderByWithAggregationInput = {
    id?: SortOrder
    productId?: SortOrder
    tagId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: product_tagCountOrderByAggregateInput
    _avg?: product_tagAvgOrderByAggregateInput
    _max?: product_tagMaxOrderByAggregateInput
    _min?: product_tagMinOrderByAggregateInput
    _sum?: product_tagSumOrderByAggregateInput
  }

  export type product_tagScalarWhereWithAggregatesInput = {
    AND?: product_tagScalarWhereWithAggregatesInput | product_tagScalarWhereWithAggregatesInput[]
    OR?: product_tagScalarWhereWithAggregatesInput[]
    NOT?: product_tagScalarWhereWithAggregatesInput | product_tagScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"product_tag"> | number
    productId?: IntWithAggregatesFilter<"product_tag"> | number
    tagId?: IntWithAggregatesFilter<"product_tag"> | number
    isActive?: BoolWithAggregatesFilter<"product_tag"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"product_tag"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"product_tag"> | Date | string
  }

  export type product_wholesaleWhereInput = {
    AND?: product_wholesaleWhereInput | product_wholesaleWhereInput[]
    OR?: product_wholesaleWhereInput[]
    NOT?: product_wholesaleWhereInput | product_wholesaleWhereInput[]
    id?: IntFilter<"product_wholesale"> | number
    productId?: IntFilter<"product_wholesale"> | number
    min?: IntFilter<"product_wholesale"> | number
    price?: FloatFilter<"product_wholesale"> | number
    isActive?: BoolFilter<"product_wholesale"> | boolean
    createdAt?: DateTimeFilter<"product_wholesale"> | Date | string
    updatedAt?: DateTimeFilter<"product_wholesale"> | Date | string
    product?: XOR<ProductRelationFilter, productWhereInput>
  }

  export type product_wholesaleOrderByWithRelationInput = {
    id?: SortOrder
    productId?: SortOrder
    min?: SortOrder
    price?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    product?: productOrderByWithRelationInput
  }

  export type product_wholesaleWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: product_wholesaleWhereInput | product_wholesaleWhereInput[]
    OR?: product_wholesaleWhereInput[]
    NOT?: product_wholesaleWhereInput | product_wholesaleWhereInput[]
    productId?: IntFilter<"product_wholesale"> | number
    min?: IntFilter<"product_wholesale"> | number
    price?: FloatFilter<"product_wholesale"> | number
    isActive?: BoolFilter<"product_wholesale"> | boolean
    createdAt?: DateTimeFilter<"product_wholesale"> | Date | string
    updatedAt?: DateTimeFilter<"product_wholesale"> | Date | string
    product?: XOR<ProductRelationFilter, productWhereInput>
  }, "id">

  export type product_wholesaleOrderByWithAggregationInput = {
    id?: SortOrder
    productId?: SortOrder
    min?: SortOrder
    price?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: product_wholesaleCountOrderByAggregateInput
    _avg?: product_wholesaleAvgOrderByAggregateInput
    _max?: product_wholesaleMaxOrderByAggregateInput
    _min?: product_wholesaleMinOrderByAggregateInput
    _sum?: product_wholesaleSumOrderByAggregateInput
  }

  export type product_wholesaleScalarWhereWithAggregatesInput = {
    AND?: product_wholesaleScalarWhereWithAggregatesInput | product_wholesaleScalarWhereWithAggregatesInput[]
    OR?: product_wholesaleScalarWhereWithAggregatesInput[]
    NOT?: product_wholesaleScalarWhereWithAggregatesInput | product_wholesaleScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"product_wholesale"> | number
    productId?: IntWithAggregatesFilter<"product_wholesale"> | number
    min?: IntWithAggregatesFilter<"product_wholesale"> | number
    price?: FloatWithAggregatesFilter<"product_wholesale"> | number
    isActive?: BoolWithAggregatesFilter<"product_wholesale"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"product_wholesale"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"product_wholesale"> | Date | string
  }

  export type product_option_firstWhereInput = {
    AND?: product_option_firstWhereInput | product_option_firstWhereInput[]
    OR?: product_option_firstWhereInput[]
    NOT?: product_option_firstWhereInput | product_option_firstWhereInput[]
    id?: IntFilter<"product_option_first"> | number
    productId?: IntFilter<"product_option_first"> | number
    name?: StringFilter<"product_option_first"> | string
    isActive?: BoolFilter<"product_option_first"> | boolean
    createdAt?: DateTimeFilter<"product_option_first"> | Date | string
    updatedAt?: DateTimeFilter<"product_option_first"> | Date | string
    product?: XOR<ProductRelationFilter, productWhereInput>
    product_price?: Product_priceListRelationFilter
  }

  export type product_option_firstOrderByWithRelationInput = {
    id?: SortOrder
    productId?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    product?: productOrderByWithRelationInput
    product_price?: product_priceOrderByRelationAggregateInput
  }

  export type product_option_firstWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: product_option_firstWhereInput | product_option_firstWhereInput[]
    OR?: product_option_firstWhereInput[]
    NOT?: product_option_firstWhereInput | product_option_firstWhereInput[]
    productId?: IntFilter<"product_option_first"> | number
    name?: StringFilter<"product_option_first"> | string
    isActive?: BoolFilter<"product_option_first"> | boolean
    createdAt?: DateTimeFilter<"product_option_first"> | Date | string
    updatedAt?: DateTimeFilter<"product_option_first"> | Date | string
    product?: XOR<ProductRelationFilter, productWhereInput>
    product_price?: Product_priceListRelationFilter
  }, "id">

  export type product_option_firstOrderByWithAggregationInput = {
    id?: SortOrder
    productId?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: product_option_firstCountOrderByAggregateInput
    _avg?: product_option_firstAvgOrderByAggregateInput
    _max?: product_option_firstMaxOrderByAggregateInput
    _min?: product_option_firstMinOrderByAggregateInput
    _sum?: product_option_firstSumOrderByAggregateInput
  }

  export type product_option_firstScalarWhereWithAggregatesInput = {
    AND?: product_option_firstScalarWhereWithAggregatesInput | product_option_firstScalarWhereWithAggregatesInput[]
    OR?: product_option_firstScalarWhereWithAggregatesInput[]
    NOT?: product_option_firstScalarWhereWithAggregatesInput | product_option_firstScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"product_option_first"> | number
    productId?: IntWithAggregatesFilter<"product_option_first"> | number
    name?: StringWithAggregatesFilter<"product_option_first"> | string
    isActive?: BoolWithAggregatesFilter<"product_option_first"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"product_option_first"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"product_option_first"> | Date | string
  }

  export type product_option_secondWhereInput = {
    AND?: product_option_secondWhereInput | product_option_secondWhereInput[]
    OR?: product_option_secondWhereInput[]
    NOT?: product_option_secondWhereInput | product_option_secondWhereInput[]
    id?: IntFilter<"product_option_second"> | number
    productId?: IntFilter<"product_option_second"> | number
    name?: StringFilter<"product_option_second"> | string
    isActive?: BoolFilter<"product_option_second"> | boolean
    createdAt?: DateTimeFilter<"product_option_second"> | Date | string
    updatedAt?: DateTimeFilter<"product_option_second"> | Date | string
    product?: XOR<ProductRelationFilter, productWhereInput>
    product_price?: Product_priceListRelationFilter
  }

  export type product_option_secondOrderByWithRelationInput = {
    id?: SortOrder
    productId?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    product?: productOrderByWithRelationInput
    product_price?: product_priceOrderByRelationAggregateInput
  }

  export type product_option_secondWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: product_option_secondWhereInput | product_option_secondWhereInput[]
    OR?: product_option_secondWhereInput[]
    NOT?: product_option_secondWhereInput | product_option_secondWhereInput[]
    productId?: IntFilter<"product_option_second"> | number
    name?: StringFilter<"product_option_second"> | string
    isActive?: BoolFilter<"product_option_second"> | boolean
    createdAt?: DateTimeFilter<"product_option_second"> | Date | string
    updatedAt?: DateTimeFilter<"product_option_second"> | Date | string
    product?: XOR<ProductRelationFilter, productWhereInput>
    product_price?: Product_priceListRelationFilter
  }, "id">

  export type product_option_secondOrderByWithAggregationInput = {
    id?: SortOrder
    productId?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: product_option_secondCountOrderByAggregateInput
    _avg?: product_option_secondAvgOrderByAggregateInput
    _max?: product_option_secondMaxOrderByAggregateInput
    _min?: product_option_secondMinOrderByAggregateInput
    _sum?: product_option_secondSumOrderByAggregateInput
  }

  export type product_option_secondScalarWhereWithAggregatesInput = {
    AND?: product_option_secondScalarWhereWithAggregatesInput | product_option_secondScalarWhereWithAggregatesInput[]
    OR?: product_option_secondScalarWhereWithAggregatesInput[]
    NOT?: product_option_secondScalarWhereWithAggregatesInput | product_option_secondScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"product_option_second"> | number
    productId?: IntWithAggregatesFilter<"product_option_second"> | number
    name?: StringWithAggregatesFilter<"product_option_second"> | string
    isActive?: BoolWithAggregatesFilter<"product_option_second"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"product_option_second"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"product_option_second"> | Date | string
  }

  export type product_priceWhereInput = {
    AND?: product_priceWhereInput | product_priceWhereInput[]
    OR?: product_priceWhereInput[]
    NOT?: product_priceWhereInput | product_priceWhereInput[]
    id?: IntFilter<"product_price"> | number
    productId?: IntFilter<"product_price"> | number
    product_option_firstId?: IntNullableFilter<"product_price"> | number | null
    product_option_secondId?: IntNullableFilter<"product_price"> | number | null
    price?: FloatFilter<"product_price"> | number
    sku?: StringNullableFilter<"product_price"> | string | null
    isWholesale?: BoolFilter<"product_price"> | boolean
    product?: XOR<ProductRelationFilter, productWhereInput>
    product_option_first?: XOR<Product_option_firstNullableRelationFilter, product_option_firstWhereInput> | null
    product_option_second?: XOR<Product_option_secondNullableRelationFilter, product_option_secondWhereInput> | null
    cart?: CartListRelationFilter
    order_product?: Order_productListRelationFilter
  }

  export type product_priceOrderByWithRelationInput = {
    id?: SortOrder
    productId?: SortOrder
    product_option_firstId?: SortOrderInput | SortOrder
    product_option_secondId?: SortOrderInput | SortOrder
    price?: SortOrder
    sku?: SortOrderInput | SortOrder
    isWholesale?: SortOrder
    product?: productOrderByWithRelationInput
    product_option_first?: product_option_firstOrderByWithRelationInput
    product_option_second?: product_option_secondOrderByWithRelationInput
    cart?: cartOrderByRelationAggregateInput
    order_product?: order_productOrderByRelationAggregateInput
  }

  export type product_priceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    sku?: string
    AND?: product_priceWhereInput | product_priceWhereInput[]
    OR?: product_priceWhereInput[]
    NOT?: product_priceWhereInput | product_priceWhereInput[]
    productId?: IntFilter<"product_price"> | number
    product_option_firstId?: IntNullableFilter<"product_price"> | number | null
    product_option_secondId?: IntNullableFilter<"product_price"> | number | null
    price?: FloatFilter<"product_price"> | number
    isWholesale?: BoolFilter<"product_price"> | boolean
    product?: XOR<ProductRelationFilter, productWhereInput>
    product_option_first?: XOR<Product_option_firstNullableRelationFilter, product_option_firstWhereInput> | null
    product_option_second?: XOR<Product_option_secondNullableRelationFilter, product_option_secondWhereInput> | null
    cart?: CartListRelationFilter
    order_product?: Order_productListRelationFilter
  }, "id" | "sku">

  export type product_priceOrderByWithAggregationInput = {
    id?: SortOrder
    productId?: SortOrder
    product_option_firstId?: SortOrderInput | SortOrder
    product_option_secondId?: SortOrderInput | SortOrder
    price?: SortOrder
    sku?: SortOrderInput | SortOrder
    isWholesale?: SortOrder
    _count?: product_priceCountOrderByAggregateInput
    _avg?: product_priceAvgOrderByAggregateInput
    _max?: product_priceMaxOrderByAggregateInput
    _min?: product_priceMinOrderByAggregateInput
    _sum?: product_priceSumOrderByAggregateInput
  }

  export type product_priceScalarWhereWithAggregatesInput = {
    AND?: product_priceScalarWhereWithAggregatesInput | product_priceScalarWhereWithAggregatesInput[]
    OR?: product_priceScalarWhereWithAggregatesInput[]
    NOT?: product_priceScalarWhereWithAggregatesInput | product_priceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"product_price"> | number
    productId?: IntWithAggregatesFilter<"product_price"> | number
    product_option_firstId?: IntNullableWithAggregatesFilter<"product_price"> | number | null
    product_option_secondId?: IntNullableWithAggregatesFilter<"product_price"> | number | null
    price?: FloatWithAggregatesFilter<"product_price"> | number
    sku?: StringNullableWithAggregatesFilter<"product_price"> | string | null
    isWholesale?: BoolWithAggregatesFilter<"product_price"> | boolean
  }

  export type product_detailWhereInput = {
    AND?: product_detailWhereInput | product_detailWhereInput[]
    OR?: product_detailWhereInput[]
    NOT?: product_detailWhereInput | product_detailWhereInput[]
    id?: IntFilter<"product_detail"> | number
    productId?: IntFilter<"product_detail"> | number
    name?: StringFilter<"product_detail"> | string
    details?: StringNullableFilter<"product_detail"> | string | null
    imagePath?: StringNullableFilter<"product_detail"> | string | null
    imageSrc?: StringNullableFilter<"product_detail"> | string | null
    videoPath?: StringNullableFilter<"product_detail"> | string | null
    videoSrc?: StringNullableFilter<"product_detail"> | string | null
    videoType?: StringNullableFilter<"product_detail"> | string | null
    link?: StringNullableFilter<"product_detail"> | string | null
    isActive?: BoolFilter<"product_detail"> | boolean
    createdAt?: DateTimeFilter<"product_detail"> | Date | string
    updatedAt?: DateTimeFilter<"product_detail"> | Date | string
    product?: XOR<ProductRelationFilter, productWhereInput>
  }

  export type product_detailOrderByWithRelationInput = {
    id?: SortOrder
    productId?: SortOrder
    name?: SortOrder
    details?: SortOrderInput | SortOrder
    imagePath?: SortOrderInput | SortOrder
    imageSrc?: SortOrderInput | SortOrder
    videoPath?: SortOrderInput | SortOrder
    videoSrc?: SortOrderInput | SortOrder
    videoType?: SortOrderInput | SortOrder
    link?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    product?: productOrderByWithRelationInput
  }

  export type product_detailWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: product_detailWhereInput | product_detailWhereInput[]
    OR?: product_detailWhereInput[]
    NOT?: product_detailWhereInput | product_detailWhereInput[]
    productId?: IntFilter<"product_detail"> | number
    name?: StringFilter<"product_detail"> | string
    details?: StringNullableFilter<"product_detail"> | string | null
    imagePath?: StringNullableFilter<"product_detail"> | string | null
    imageSrc?: StringNullableFilter<"product_detail"> | string | null
    videoPath?: StringNullableFilter<"product_detail"> | string | null
    videoSrc?: StringNullableFilter<"product_detail"> | string | null
    videoType?: StringNullableFilter<"product_detail"> | string | null
    link?: StringNullableFilter<"product_detail"> | string | null
    isActive?: BoolFilter<"product_detail"> | boolean
    createdAt?: DateTimeFilter<"product_detail"> | Date | string
    updatedAt?: DateTimeFilter<"product_detail"> | Date | string
    product?: XOR<ProductRelationFilter, productWhereInput>
  }, "id">

  export type product_detailOrderByWithAggregationInput = {
    id?: SortOrder
    productId?: SortOrder
    name?: SortOrder
    details?: SortOrderInput | SortOrder
    imagePath?: SortOrderInput | SortOrder
    imageSrc?: SortOrderInput | SortOrder
    videoPath?: SortOrderInput | SortOrder
    videoSrc?: SortOrderInput | SortOrder
    videoType?: SortOrderInput | SortOrder
    link?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: product_detailCountOrderByAggregateInput
    _avg?: product_detailAvgOrderByAggregateInput
    _max?: product_detailMaxOrderByAggregateInput
    _min?: product_detailMinOrderByAggregateInput
    _sum?: product_detailSumOrderByAggregateInput
  }

  export type product_detailScalarWhereWithAggregatesInput = {
    AND?: product_detailScalarWhereWithAggregatesInput | product_detailScalarWhereWithAggregatesInput[]
    OR?: product_detailScalarWhereWithAggregatesInput[]
    NOT?: product_detailScalarWhereWithAggregatesInput | product_detailScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"product_detail"> | number
    productId?: IntWithAggregatesFilter<"product_detail"> | number
    name?: StringWithAggregatesFilter<"product_detail"> | string
    details?: StringNullableWithAggregatesFilter<"product_detail"> | string | null
    imagePath?: StringNullableWithAggregatesFilter<"product_detail"> | string | null
    imageSrc?: StringNullableWithAggregatesFilter<"product_detail"> | string | null
    videoPath?: StringNullableWithAggregatesFilter<"product_detail"> | string | null
    videoSrc?: StringNullableWithAggregatesFilter<"product_detail"> | string | null
    videoType?: StringNullableWithAggregatesFilter<"product_detail"> | string | null
    link?: StringNullableWithAggregatesFilter<"product_detail"> | string | null
    isActive?: BoolWithAggregatesFilter<"product_detail"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"product_detail"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"product_detail"> | Date | string
  }

  export type product_imageWhereInput = {
    AND?: product_imageWhereInput | product_imageWhereInput[]
    OR?: product_imageWhereInput[]
    NOT?: product_imageWhereInput | product_imageWhereInput[]
    id?: IntFilter<"product_image"> | number
    name?: StringFilter<"product_image"> | string
    path?: StringFilter<"product_image"> | string
    src?: StringFilter<"product_image"> | string
    sequence?: IntFilter<"product_image"> | number
    productId?: IntFilter<"product_image"> | number
    isActive?: BoolFilter<"product_image"> | boolean
    createdAt?: DateTimeFilter<"product_image"> | Date | string
    updatedAt?: DateTimeFilter<"product_image"> | Date | string
    product?: XOR<ProductRelationFilter, productWhereInput>
  }

  export type product_imageOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    path?: SortOrder
    src?: SortOrder
    sequence?: SortOrder
    productId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    product?: productOrderByWithRelationInput
  }

  export type product_imageWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: product_imageWhereInput | product_imageWhereInput[]
    OR?: product_imageWhereInput[]
    NOT?: product_imageWhereInput | product_imageWhereInput[]
    name?: StringFilter<"product_image"> | string
    path?: StringFilter<"product_image"> | string
    src?: StringFilter<"product_image"> | string
    sequence?: IntFilter<"product_image"> | number
    productId?: IntFilter<"product_image"> | number
    isActive?: BoolFilter<"product_image"> | boolean
    createdAt?: DateTimeFilter<"product_image"> | Date | string
    updatedAt?: DateTimeFilter<"product_image"> | Date | string
    product?: XOR<ProductRelationFilter, productWhereInput>
  }, "id">

  export type product_imageOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    path?: SortOrder
    src?: SortOrder
    sequence?: SortOrder
    productId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: product_imageCountOrderByAggregateInput
    _avg?: product_imageAvgOrderByAggregateInput
    _max?: product_imageMaxOrderByAggregateInput
    _min?: product_imageMinOrderByAggregateInput
    _sum?: product_imageSumOrderByAggregateInput
  }

  export type product_imageScalarWhereWithAggregatesInput = {
    AND?: product_imageScalarWhereWithAggregatesInput | product_imageScalarWhereWithAggregatesInput[]
    OR?: product_imageScalarWhereWithAggregatesInput[]
    NOT?: product_imageScalarWhereWithAggregatesInput | product_imageScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"product_image"> | number
    name?: StringWithAggregatesFilter<"product_image"> | string
    path?: StringWithAggregatesFilter<"product_image"> | string
    src?: StringWithAggregatesFilter<"product_image"> | string
    sequence?: IntWithAggregatesFilter<"product_image"> | number
    productId?: IntWithAggregatesFilter<"product_image"> | number
    isActive?: BoolWithAggregatesFilter<"product_image"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"product_image"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"product_image"> | Date | string
  }

  export type product_specWhereInput = {
    AND?: product_specWhereInput | product_specWhereInput[]
    OR?: product_specWhereInput[]
    NOT?: product_specWhereInput | product_specWhereInput[]
    id?: IntFilter<"product_spec"> | number
    name?: StringFilter<"product_spec"> | string
    data?: JsonFilter<"product_spec">
    productId?: IntFilter<"product_spec"> | number
    product?: XOR<ProductRelationFilter, productWhereInput>
  }

  export type product_specOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    data?: SortOrder
    productId?: SortOrder
    product?: productOrderByWithRelationInput
  }

  export type product_specWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: product_specWhereInput | product_specWhereInput[]
    OR?: product_specWhereInput[]
    NOT?: product_specWhereInput | product_specWhereInput[]
    name?: StringFilter<"product_spec"> | string
    data?: JsonFilter<"product_spec">
    productId?: IntFilter<"product_spec"> | number
    product?: XOR<ProductRelationFilter, productWhereInput>
  }, "id">

  export type product_specOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    data?: SortOrder
    productId?: SortOrder
    _count?: product_specCountOrderByAggregateInput
    _avg?: product_specAvgOrderByAggregateInput
    _max?: product_specMaxOrderByAggregateInput
    _min?: product_specMinOrderByAggregateInput
    _sum?: product_specSumOrderByAggregateInput
  }

  export type product_specScalarWhereWithAggregatesInput = {
    AND?: product_specScalarWhereWithAggregatesInput | product_specScalarWhereWithAggregatesInput[]
    OR?: product_specScalarWhereWithAggregatesInput[]
    NOT?: product_specScalarWhereWithAggregatesInput | product_specScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"product_spec"> | number
    name?: StringWithAggregatesFilter<"product_spec"> | string
    data?: JsonWithAggregatesFilter<"product_spec">
    productId?: IntWithAggregatesFilter<"product_spec"> | number
  }

  export type cartWhereInput = {
    AND?: cartWhereInput | cartWhereInput[]
    OR?: cartWhereInput[]
    NOT?: cartWhereInput | cartWhereInput[]
    id?: IntFilter<"cart"> | number
    userId?: IntFilter<"cart"> | number
    productId?: IntFilter<"cart"> | number
    product_priceId?: IntFilter<"cart"> | number
    qty?: IntFilter<"cart"> | number
    price?: FloatFilter<"cart"> | number
    isActive?: BoolFilter<"cart"> | boolean
    createdAt?: DateTimeFilter<"cart"> | Date | string
    updatedAt?: DateTimeFilter<"cart"> | Date | string
    user?: XOR<UserRelationFilter, userWhereInput>
    product?: XOR<ProductRelationFilter, productWhereInput>
    product_price?: XOR<Product_priceRelationFilter, product_priceWhereInput>
  }

  export type cartOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
    product_priceId?: SortOrder
    qty?: SortOrder
    price?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: userOrderByWithRelationInput
    product?: productOrderByWithRelationInput
    product_price?: product_priceOrderByWithRelationInput
  }

  export type cartWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: cartWhereInput | cartWhereInput[]
    OR?: cartWhereInput[]
    NOT?: cartWhereInput | cartWhereInput[]
    userId?: IntFilter<"cart"> | number
    productId?: IntFilter<"cart"> | number
    product_priceId?: IntFilter<"cart"> | number
    qty?: IntFilter<"cart"> | number
    price?: FloatFilter<"cart"> | number
    isActive?: BoolFilter<"cart"> | boolean
    createdAt?: DateTimeFilter<"cart"> | Date | string
    updatedAt?: DateTimeFilter<"cart"> | Date | string
    user?: XOR<UserRelationFilter, userWhereInput>
    product?: XOR<ProductRelationFilter, productWhereInput>
    product_price?: XOR<Product_priceRelationFilter, product_priceWhereInput>
  }, "id">

  export type cartOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
    product_priceId?: SortOrder
    qty?: SortOrder
    price?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: cartCountOrderByAggregateInput
    _avg?: cartAvgOrderByAggregateInput
    _max?: cartMaxOrderByAggregateInput
    _min?: cartMinOrderByAggregateInput
    _sum?: cartSumOrderByAggregateInput
  }

  export type cartScalarWhereWithAggregatesInput = {
    AND?: cartScalarWhereWithAggregatesInput | cartScalarWhereWithAggregatesInput[]
    OR?: cartScalarWhereWithAggregatesInput[]
    NOT?: cartScalarWhereWithAggregatesInput | cartScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"cart"> | number
    userId?: IntWithAggregatesFilter<"cart"> | number
    productId?: IntWithAggregatesFilter<"cart"> | number
    product_priceId?: IntWithAggregatesFilter<"cart"> | number
    qty?: IntWithAggregatesFilter<"cart"> | number
    price?: FloatWithAggregatesFilter<"cart"> | number
    isActive?: BoolWithAggregatesFilter<"cart"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"cart"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"cart"> | Date | string
  }

  export type orderWhereInput = {
    AND?: orderWhereInput | orderWhereInput[]
    OR?: orderWhereInput[]
    NOT?: orderWhereInput | orderWhereInput[]
    id?: IntFilter<"order"> | number
    userId?: IntFilter<"order"> | number
    statusNow?: StringFilter<"order"> | string
    status?: JsonFilter<"order">
    paymentType?: StringFilter<"order"> | string
    paymentStatus?: StringFilter<"order"> | string
    createUsing?: FloatFilter<"order"> | number
    pointUsing?: FloatFilter<"order"> | number
    orderPrice?: FloatFilter<"order"> | number
    deliveryPrice?: FloatFilter<"order"> | number
    netPrice?: FloatFilter<"order"> | number
    orderDiscount?: FloatFilter<"order"> | number
    deliveryDiscount?: FloatFilter<"order"> | number
    orderDiscountCode?: StringFilter<"order"> | string
    deliveryDiscountCode?: StringFilter<"order"> | string
    addressId?: IntFilter<"order"> | number
    addressData?: JsonFilter<"order">
    userData?: JsonFilter<"order">
    isReject?: BoolFilter<"order"> | boolean
    isActive?: BoolFilter<"order"> | boolean
    createdAt?: DateTimeFilter<"order"> | Date | string
    updatedAt?: DateTimeFilter<"order"> | Date | string
    user?: XOR<UserRelationFilter, userWhereInput>
    address?: XOR<AddressRelationFilter, addressWhereInput>
    order_product?: Order_productListRelationFilter
  }

  export type orderOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    statusNow?: SortOrder
    status?: SortOrder
    paymentType?: SortOrder
    paymentStatus?: SortOrder
    createUsing?: SortOrder
    pointUsing?: SortOrder
    orderPrice?: SortOrder
    deliveryPrice?: SortOrder
    netPrice?: SortOrder
    orderDiscount?: SortOrder
    deliveryDiscount?: SortOrder
    orderDiscountCode?: SortOrder
    deliveryDiscountCode?: SortOrder
    addressId?: SortOrder
    addressData?: SortOrder
    userData?: SortOrder
    isReject?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: userOrderByWithRelationInput
    address?: addressOrderByWithRelationInput
    order_product?: order_productOrderByRelationAggregateInput
  }

  export type orderWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: orderWhereInput | orderWhereInput[]
    OR?: orderWhereInput[]
    NOT?: orderWhereInput | orderWhereInput[]
    userId?: IntFilter<"order"> | number
    statusNow?: StringFilter<"order"> | string
    status?: JsonFilter<"order">
    paymentType?: StringFilter<"order"> | string
    paymentStatus?: StringFilter<"order"> | string
    createUsing?: FloatFilter<"order"> | number
    pointUsing?: FloatFilter<"order"> | number
    orderPrice?: FloatFilter<"order"> | number
    deliveryPrice?: FloatFilter<"order"> | number
    netPrice?: FloatFilter<"order"> | number
    orderDiscount?: FloatFilter<"order"> | number
    deliveryDiscount?: FloatFilter<"order"> | number
    orderDiscountCode?: StringFilter<"order"> | string
    deliveryDiscountCode?: StringFilter<"order"> | string
    addressId?: IntFilter<"order"> | number
    addressData?: JsonFilter<"order">
    userData?: JsonFilter<"order">
    isReject?: BoolFilter<"order"> | boolean
    isActive?: BoolFilter<"order"> | boolean
    createdAt?: DateTimeFilter<"order"> | Date | string
    updatedAt?: DateTimeFilter<"order"> | Date | string
    user?: XOR<UserRelationFilter, userWhereInput>
    address?: XOR<AddressRelationFilter, addressWhereInput>
    order_product?: Order_productListRelationFilter
  }, "id">

  export type orderOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    statusNow?: SortOrder
    status?: SortOrder
    paymentType?: SortOrder
    paymentStatus?: SortOrder
    createUsing?: SortOrder
    pointUsing?: SortOrder
    orderPrice?: SortOrder
    deliveryPrice?: SortOrder
    netPrice?: SortOrder
    orderDiscount?: SortOrder
    deliveryDiscount?: SortOrder
    orderDiscountCode?: SortOrder
    deliveryDiscountCode?: SortOrder
    addressId?: SortOrder
    addressData?: SortOrder
    userData?: SortOrder
    isReject?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: orderCountOrderByAggregateInput
    _avg?: orderAvgOrderByAggregateInput
    _max?: orderMaxOrderByAggregateInput
    _min?: orderMinOrderByAggregateInput
    _sum?: orderSumOrderByAggregateInput
  }

  export type orderScalarWhereWithAggregatesInput = {
    AND?: orderScalarWhereWithAggregatesInput | orderScalarWhereWithAggregatesInput[]
    OR?: orderScalarWhereWithAggregatesInput[]
    NOT?: orderScalarWhereWithAggregatesInput | orderScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"order"> | number
    userId?: IntWithAggregatesFilter<"order"> | number
    statusNow?: StringWithAggregatesFilter<"order"> | string
    status?: JsonWithAggregatesFilter<"order">
    paymentType?: StringWithAggregatesFilter<"order"> | string
    paymentStatus?: StringWithAggregatesFilter<"order"> | string
    createUsing?: FloatWithAggregatesFilter<"order"> | number
    pointUsing?: FloatWithAggregatesFilter<"order"> | number
    orderPrice?: FloatWithAggregatesFilter<"order"> | number
    deliveryPrice?: FloatWithAggregatesFilter<"order"> | number
    netPrice?: FloatWithAggregatesFilter<"order"> | number
    orderDiscount?: FloatWithAggregatesFilter<"order"> | number
    deliveryDiscount?: FloatWithAggregatesFilter<"order"> | number
    orderDiscountCode?: StringWithAggregatesFilter<"order"> | string
    deliveryDiscountCode?: StringWithAggregatesFilter<"order"> | string
    addressId?: IntWithAggregatesFilter<"order"> | number
    addressData?: JsonWithAggregatesFilter<"order">
    userData?: JsonWithAggregatesFilter<"order">
    isReject?: BoolWithAggregatesFilter<"order"> | boolean
    isActive?: BoolWithAggregatesFilter<"order"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"order"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"order"> | Date | string
  }

  export type order_productWhereInput = {
    AND?: order_productWhereInput | order_productWhereInput[]
    OR?: order_productWhereInput[]
    NOT?: order_productWhereInput | order_productWhereInput[]
    id?: IntFilter<"order_product"> | number
    userId?: IntFilter<"order_product"> | number
    productId?: IntFilter<"order_product"> | number
    orderId?: IntFilter<"order_product"> | number
    product_priceId?: IntFilter<"order_product"> | number
    qty?: IntFilter<"order_product"> | number
    price?: FloatFilter<"order_product"> | number
    productData?: JsonFilter<"order_product">
    isActive?: BoolFilter<"order_product"> | boolean
    createdAt?: DateTimeFilter<"order_product"> | Date | string
    updatedAt?: DateTimeFilter<"order_product"> | Date | string
    user?: XOR<UserRelationFilter, userWhereInput>
    product?: XOR<ProductRelationFilter, productWhereInput>
    order?: XOR<OrderRelationFilter, orderWhereInput>
    product_price?: XOR<Product_priceRelationFilter, product_priceWhereInput>
  }

  export type order_productOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
    orderId?: SortOrder
    product_priceId?: SortOrder
    qty?: SortOrder
    price?: SortOrder
    productData?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: userOrderByWithRelationInput
    product?: productOrderByWithRelationInput
    order?: orderOrderByWithRelationInput
    product_price?: product_priceOrderByWithRelationInput
  }

  export type order_productWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: order_productWhereInput | order_productWhereInput[]
    OR?: order_productWhereInput[]
    NOT?: order_productWhereInput | order_productWhereInput[]
    userId?: IntFilter<"order_product"> | number
    productId?: IntFilter<"order_product"> | number
    orderId?: IntFilter<"order_product"> | number
    product_priceId?: IntFilter<"order_product"> | number
    qty?: IntFilter<"order_product"> | number
    price?: FloatFilter<"order_product"> | number
    productData?: JsonFilter<"order_product">
    isActive?: BoolFilter<"order_product"> | boolean
    createdAt?: DateTimeFilter<"order_product"> | Date | string
    updatedAt?: DateTimeFilter<"order_product"> | Date | string
    user?: XOR<UserRelationFilter, userWhereInput>
    product?: XOR<ProductRelationFilter, productWhereInput>
    order?: XOR<OrderRelationFilter, orderWhereInput>
    product_price?: XOR<Product_priceRelationFilter, product_priceWhereInput>
  }, "id">

  export type order_productOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
    orderId?: SortOrder
    product_priceId?: SortOrder
    qty?: SortOrder
    price?: SortOrder
    productData?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: order_productCountOrderByAggregateInput
    _avg?: order_productAvgOrderByAggregateInput
    _max?: order_productMaxOrderByAggregateInput
    _min?: order_productMinOrderByAggregateInput
    _sum?: order_productSumOrderByAggregateInput
  }

  export type order_productScalarWhereWithAggregatesInput = {
    AND?: order_productScalarWhereWithAggregatesInput | order_productScalarWhereWithAggregatesInput[]
    OR?: order_productScalarWhereWithAggregatesInput[]
    NOT?: order_productScalarWhereWithAggregatesInput | order_productScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"order_product"> | number
    userId?: IntWithAggregatesFilter<"order_product"> | number
    productId?: IntWithAggregatesFilter<"order_product"> | number
    orderId?: IntWithAggregatesFilter<"order_product"> | number
    product_priceId?: IntWithAggregatesFilter<"order_product"> | number
    qty?: IntWithAggregatesFilter<"order_product"> | number
    price?: FloatWithAggregatesFilter<"order_product"> | number
    productData?: JsonWithAggregatesFilter<"order_product">
    isActive?: BoolWithAggregatesFilter<"order_product"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"order_product"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"order_product"> | Date | string
  }

  export type settingWhereInput = {
    AND?: settingWhereInput | settingWhereInput[]
    OR?: settingWhereInput[]
    NOT?: settingWhereInput | settingWhereInput[]
    id?: IntFilter<"setting"> | number
    facebook?: StringNullableFilter<"setting"> | string | null
    line?: StringNullableFilter<"setting"> | string | null
    instagram?: StringNullableFilter<"setting"> | string | null
    tiktok?: StringNullableFilter<"setting"> | string | null
    email?: StringNullableFilter<"setting"> | string | null
    phone?: StringNullableFilter<"setting"> | string | null
    isActive?: BoolFilter<"setting"> | boolean
    createdAt?: DateTimeFilter<"setting"> | Date | string
    updatedAt?: DateTimeFilter<"setting"> | Date | string
  }

  export type settingOrderByWithRelationInput = {
    id?: SortOrder
    facebook?: SortOrderInput | SortOrder
    line?: SortOrderInput | SortOrder
    instagram?: SortOrderInput | SortOrder
    tiktok?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type settingWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: settingWhereInput | settingWhereInput[]
    OR?: settingWhereInput[]
    NOT?: settingWhereInput | settingWhereInput[]
    facebook?: StringNullableFilter<"setting"> | string | null
    line?: StringNullableFilter<"setting"> | string | null
    instagram?: StringNullableFilter<"setting"> | string | null
    tiktok?: StringNullableFilter<"setting"> | string | null
    email?: StringNullableFilter<"setting"> | string | null
    phone?: StringNullableFilter<"setting"> | string | null
    isActive?: BoolFilter<"setting"> | boolean
    createdAt?: DateTimeFilter<"setting"> | Date | string
    updatedAt?: DateTimeFilter<"setting"> | Date | string
  }, "id">

  export type settingOrderByWithAggregationInput = {
    id?: SortOrder
    facebook?: SortOrderInput | SortOrder
    line?: SortOrderInput | SortOrder
    instagram?: SortOrderInput | SortOrder
    tiktok?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: settingCountOrderByAggregateInput
    _avg?: settingAvgOrderByAggregateInput
    _max?: settingMaxOrderByAggregateInput
    _min?: settingMinOrderByAggregateInput
    _sum?: settingSumOrderByAggregateInput
  }

  export type settingScalarWhereWithAggregatesInput = {
    AND?: settingScalarWhereWithAggregatesInput | settingScalarWhereWithAggregatesInput[]
    OR?: settingScalarWhereWithAggregatesInput[]
    NOT?: settingScalarWhereWithAggregatesInput | settingScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"setting"> | number
    facebook?: StringNullableWithAggregatesFilter<"setting"> | string | null
    line?: StringNullableWithAggregatesFilter<"setting"> | string | null
    instagram?: StringNullableWithAggregatesFilter<"setting"> | string | null
    tiktok?: StringNullableWithAggregatesFilter<"setting"> | string | null
    email?: StringNullableWithAggregatesFilter<"setting"> | string | null
    phone?: StringNullableWithAggregatesFilter<"setting"> | string | null
    isActive?: BoolWithAggregatesFilter<"setting"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"setting"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"setting"> | Date | string
  }

  export type setting_serviceWhereInput = {
    AND?: setting_serviceWhereInput | setting_serviceWhereInput[]
    OR?: setting_serviceWhereInput[]
    NOT?: setting_serviceWhereInput | setting_serviceWhereInput[]
    id?: IntFilter<"setting_service"> | number
    lineNotiToken?: StringNullableFilter<"setting_service"> | string | null
    gmpayToken?: StringNullableFilter<"setting_service"> | string | null
    seo?: JsonNullableFilter<"setting_service">
    isActive?: BoolFilter<"setting_service"> | boolean
    createdAt?: DateTimeFilter<"setting_service"> | Date | string
    updatedAt?: DateTimeFilter<"setting_service"> | Date | string
  }

  export type setting_serviceOrderByWithRelationInput = {
    id?: SortOrder
    lineNotiToken?: SortOrderInput | SortOrder
    gmpayToken?: SortOrderInput | SortOrder
    seo?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type setting_serviceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: setting_serviceWhereInput | setting_serviceWhereInput[]
    OR?: setting_serviceWhereInput[]
    NOT?: setting_serviceWhereInput | setting_serviceWhereInput[]
    lineNotiToken?: StringNullableFilter<"setting_service"> | string | null
    gmpayToken?: StringNullableFilter<"setting_service"> | string | null
    seo?: JsonNullableFilter<"setting_service">
    isActive?: BoolFilter<"setting_service"> | boolean
    createdAt?: DateTimeFilter<"setting_service"> | Date | string
    updatedAt?: DateTimeFilter<"setting_service"> | Date | string
  }, "id">

  export type setting_serviceOrderByWithAggregationInput = {
    id?: SortOrder
    lineNotiToken?: SortOrderInput | SortOrder
    gmpayToken?: SortOrderInput | SortOrder
    seo?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: setting_serviceCountOrderByAggregateInput
    _avg?: setting_serviceAvgOrderByAggregateInput
    _max?: setting_serviceMaxOrderByAggregateInput
    _min?: setting_serviceMinOrderByAggregateInput
    _sum?: setting_serviceSumOrderByAggregateInput
  }

  export type setting_serviceScalarWhereWithAggregatesInput = {
    AND?: setting_serviceScalarWhereWithAggregatesInput | setting_serviceScalarWhereWithAggregatesInput[]
    OR?: setting_serviceScalarWhereWithAggregatesInput[]
    NOT?: setting_serviceScalarWhereWithAggregatesInput | setting_serviceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"setting_service"> | number
    lineNotiToken?: StringNullableWithAggregatesFilter<"setting_service"> | string | null
    gmpayToken?: StringNullableWithAggregatesFilter<"setting_service"> | string | null
    seo?: JsonNullableWithAggregatesFilter<"setting_service">
    isActive?: BoolWithAggregatesFilter<"setting_service"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"setting_service"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"setting_service"> | Date | string
  }

  export type adminCreateInput = {
    userName: string
    fname?: string | null
    lname?: string | null
    fullname?: string | null
    role?: string
    permission?: NullableJsonNullValueInput | InputJsonValue
    email: string
    avatarPath?: string | null
    avatarSrc?: string | null
    phone: string
    refreshToken?: string | null
    password: string
    passwordRt?: string | null
    ipv4?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user_credit_transaction?: user_credit_transactionCreateNestedManyWithoutAdminInput
    user_point_transaction?: user_point_transactionCreateNestedManyWithoutAdminInput
    product_review?: product_reviewCreateNestedManyWithoutAdminInput
    product?: productCreateNestedManyWithoutAdminInput
  }

  export type adminUncheckedCreateInput = {
    id?: number
    userName: string
    fname?: string | null
    lname?: string | null
    fullname?: string | null
    role?: string
    permission?: NullableJsonNullValueInput | InputJsonValue
    email: string
    avatarPath?: string | null
    avatarSrc?: string | null
    phone: string
    refreshToken?: string | null
    password: string
    passwordRt?: string | null
    ipv4?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user_credit_transaction?: user_credit_transactionUncheckedCreateNestedManyWithoutAdminInput
    user_point_transaction?: user_point_transactionUncheckedCreateNestedManyWithoutAdminInput
    product_review?: product_reviewUncheckedCreateNestedManyWithoutAdminInput
    product?: productUncheckedCreateNestedManyWithoutAdminInput
  }

  export type adminUpdateInput = {
    userName?: StringFieldUpdateOperationsInput | string
    fname?: NullableStringFieldUpdateOperationsInput | string | null
    lname?: NullableStringFieldUpdateOperationsInput | string | null
    fullname?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    permission?: NullableJsonNullValueInput | InputJsonValue
    email?: StringFieldUpdateOperationsInput | string
    avatarPath?: NullableStringFieldUpdateOperationsInput | string | null
    avatarSrc?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    passwordRt?: NullableStringFieldUpdateOperationsInput | string | null
    ipv4?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user_credit_transaction?: user_credit_transactionUpdateManyWithoutAdminNestedInput
    user_point_transaction?: user_point_transactionUpdateManyWithoutAdminNestedInput
    product_review?: product_reviewUpdateManyWithoutAdminNestedInput
    product?: productUpdateManyWithoutAdminNestedInput
  }

  export type adminUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userName?: StringFieldUpdateOperationsInput | string
    fname?: NullableStringFieldUpdateOperationsInput | string | null
    lname?: NullableStringFieldUpdateOperationsInput | string | null
    fullname?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    permission?: NullableJsonNullValueInput | InputJsonValue
    email?: StringFieldUpdateOperationsInput | string
    avatarPath?: NullableStringFieldUpdateOperationsInput | string | null
    avatarSrc?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    passwordRt?: NullableStringFieldUpdateOperationsInput | string | null
    ipv4?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user_credit_transaction?: user_credit_transactionUncheckedUpdateManyWithoutAdminNestedInput
    user_point_transaction?: user_point_transactionUncheckedUpdateManyWithoutAdminNestedInput
    product_review?: product_reviewUncheckedUpdateManyWithoutAdminNestedInput
    product?: productUncheckedUpdateManyWithoutAdminNestedInput
  }

  export type adminCreateManyInput = {
    id?: number
    userName: string
    fname?: string | null
    lname?: string | null
    fullname?: string | null
    role?: string
    permission?: NullableJsonNullValueInput | InputJsonValue
    email: string
    avatarPath?: string | null
    avatarSrc?: string | null
    phone: string
    refreshToken?: string | null
    password: string
    passwordRt?: string | null
    ipv4?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type adminUpdateManyMutationInput = {
    userName?: StringFieldUpdateOperationsInput | string
    fname?: NullableStringFieldUpdateOperationsInput | string | null
    lname?: NullableStringFieldUpdateOperationsInput | string | null
    fullname?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    permission?: NullableJsonNullValueInput | InputJsonValue
    email?: StringFieldUpdateOperationsInput | string
    avatarPath?: NullableStringFieldUpdateOperationsInput | string | null
    avatarSrc?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    passwordRt?: NullableStringFieldUpdateOperationsInput | string | null
    ipv4?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type adminUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userName?: StringFieldUpdateOperationsInput | string
    fname?: NullableStringFieldUpdateOperationsInput | string | null
    lname?: NullableStringFieldUpdateOperationsInput | string | null
    fullname?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    permission?: NullableJsonNullValueInput | InputJsonValue
    email?: StringFieldUpdateOperationsInput | string
    avatarPath?: NullableStringFieldUpdateOperationsInput | string | null
    avatarSrc?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    passwordRt?: NullableStringFieldUpdateOperationsInput | string | null
    ipv4?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type userCreateInput = {
    avatarPath?: string | null
    avatarSrc?: string | null
    fname?: string | null
    lname?: string | null
    fullname?: string | null
    email: string
    phone: string
    credit?: number
    point?: number
    lineId?: string | null
    baned?: boolean
    ipv4?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    address?: addressCreateNestedManyWithoutUserInput
    user_credit_transaction?: user_credit_transactionCreateNestedManyWithoutUserInput
    payment_transaction?: payment_transactionCreateNestedManyWithoutUserInput
    user_point_transaction?: user_point_transactionCreateNestedManyWithoutUserInput
    product_review?: product_reviewCreateNestedManyWithoutUserInput
    cart?: cartCreateNestedManyWithoutUserInput
    order?: orderCreateNestedManyWithoutUserInput
    order_product?: order_productCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateInput = {
    id?: number
    avatarPath?: string | null
    avatarSrc?: string | null
    fname?: string | null
    lname?: string | null
    fullname?: string | null
    email: string
    phone: string
    credit?: number
    point?: number
    lineId?: string | null
    baned?: boolean
    ipv4?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    address?: addressUncheckedCreateNestedManyWithoutUserInput
    user_credit_transaction?: user_credit_transactionUncheckedCreateNestedManyWithoutUserInput
    payment_transaction?: payment_transactionUncheckedCreateNestedManyWithoutUserInput
    user_point_transaction?: user_point_transactionUncheckedCreateNestedManyWithoutUserInput
    product_review?: product_reviewUncheckedCreateNestedManyWithoutUserInput
    cart?: cartUncheckedCreateNestedManyWithoutUserInput
    order?: orderUncheckedCreateNestedManyWithoutUserInput
    order_product?: order_productUncheckedCreateNestedManyWithoutUserInput
  }

  export type userUpdateInput = {
    avatarPath?: NullableStringFieldUpdateOperationsInput | string | null
    avatarSrc?: NullableStringFieldUpdateOperationsInput | string | null
    fname?: NullableStringFieldUpdateOperationsInput | string | null
    lname?: NullableStringFieldUpdateOperationsInput | string | null
    fullname?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    credit?: FloatFieldUpdateOperationsInput | number
    point?: FloatFieldUpdateOperationsInput | number
    lineId?: NullableStringFieldUpdateOperationsInput | string | null
    baned?: BoolFieldUpdateOperationsInput | boolean
    ipv4?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: addressUpdateManyWithoutUserNestedInput
    user_credit_transaction?: user_credit_transactionUpdateManyWithoutUserNestedInput
    payment_transaction?: payment_transactionUpdateManyWithoutUserNestedInput
    user_point_transaction?: user_point_transactionUpdateManyWithoutUserNestedInput
    product_review?: product_reviewUpdateManyWithoutUserNestedInput
    cart?: cartUpdateManyWithoutUserNestedInput
    order?: orderUpdateManyWithoutUserNestedInput
    order_product?: order_productUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    avatarPath?: NullableStringFieldUpdateOperationsInput | string | null
    avatarSrc?: NullableStringFieldUpdateOperationsInput | string | null
    fname?: NullableStringFieldUpdateOperationsInput | string | null
    lname?: NullableStringFieldUpdateOperationsInput | string | null
    fullname?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    credit?: FloatFieldUpdateOperationsInput | number
    point?: FloatFieldUpdateOperationsInput | number
    lineId?: NullableStringFieldUpdateOperationsInput | string | null
    baned?: BoolFieldUpdateOperationsInput | boolean
    ipv4?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: addressUncheckedUpdateManyWithoutUserNestedInput
    user_credit_transaction?: user_credit_transactionUncheckedUpdateManyWithoutUserNestedInput
    payment_transaction?: payment_transactionUncheckedUpdateManyWithoutUserNestedInput
    user_point_transaction?: user_point_transactionUncheckedUpdateManyWithoutUserNestedInput
    product_review?: product_reviewUncheckedUpdateManyWithoutUserNestedInput
    cart?: cartUncheckedUpdateManyWithoutUserNestedInput
    order?: orderUncheckedUpdateManyWithoutUserNestedInput
    order_product?: order_productUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userCreateManyInput = {
    id?: number
    avatarPath?: string | null
    avatarSrc?: string | null
    fname?: string | null
    lname?: string | null
    fullname?: string | null
    email: string
    phone: string
    credit?: number
    point?: number
    lineId?: string | null
    baned?: boolean
    ipv4?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type userUpdateManyMutationInput = {
    avatarPath?: NullableStringFieldUpdateOperationsInput | string | null
    avatarSrc?: NullableStringFieldUpdateOperationsInput | string | null
    fname?: NullableStringFieldUpdateOperationsInput | string | null
    lname?: NullableStringFieldUpdateOperationsInput | string | null
    fullname?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    credit?: FloatFieldUpdateOperationsInput | number
    point?: FloatFieldUpdateOperationsInput | number
    lineId?: NullableStringFieldUpdateOperationsInput | string | null
    baned?: BoolFieldUpdateOperationsInput | boolean
    ipv4?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type userUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    avatarPath?: NullableStringFieldUpdateOperationsInput | string | null
    avatarSrc?: NullableStringFieldUpdateOperationsInput | string | null
    fname?: NullableStringFieldUpdateOperationsInput | string | null
    lname?: NullableStringFieldUpdateOperationsInput | string | null
    fullname?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    credit?: FloatFieldUpdateOperationsInput | number
    point?: FloatFieldUpdateOperationsInput | number
    lineId?: NullableStringFieldUpdateOperationsInput | string | null
    baned?: BoolFieldUpdateOperationsInput | boolean
    ipv4?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_credit_transactionCreateInput = {
    updateBy: string
    updateType: string
    beforeUpdate: number
    afterUpdate: number
    credit: number
    remark?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: userCreateNestedOneWithoutUser_credit_transactionInput
    admin?: adminCreateNestedOneWithoutUser_credit_transactionInput
  }

  export type user_credit_transactionUncheckedCreateInput = {
    id?: number
    userId: number
    adminId?: number | null
    updateBy: string
    updateType: string
    beforeUpdate: number
    afterUpdate: number
    credit: number
    remark?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type user_credit_transactionUpdateInput = {
    updateBy?: StringFieldUpdateOperationsInput | string
    updateType?: StringFieldUpdateOperationsInput | string
    beforeUpdate?: FloatFieldUpdateOperationsInput | number
    afterUpdate?: FloatFieldUpdateOperationsInput | number
    credit?: FloatFieldUpdateOperationsInput | number
    remark?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: userUpdateOneRequiredWithoutUser_credit_transactionNestedInput
    admin?: adminUpdateOneWithoutUser_credit_transactionNestedInput
  }

  export type user_credit_transactionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    adminId?: NullableIntFieldUpdateOperationsInput | number | null
    updateBy?: StringFieldUpdateOperationsInput | string
    updateType?: StringFieldUpdateOperationsInput | string
    beforeUpdate?: FloatFieldUpdateOperationsInput | number
    afterUpdate?: FloatFieldUpdateOperationsInput | number
    credit?: FloatFieldUpdateOperationsInput | number
    remark?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_credit_transactionCreateManyInput = {
    id?: number
    userId: number
    adminId?: number | null
    updateBy: string
    updateType: string
    beforeUpdate: number
    afterUpdate: number
    credit: number
    remark?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type user_credit_transactionUpdateManyMutationInput = {
    updateBy?: StringFieldUpdateOperationsInput | string
    updateType?: StringFieldUpdateOperationsInput | string
    beforeUpdate?: FloatFieldUpdateOperationsInput | number
    afterUpdate?: FloatFieldUpdateOperationsInput | number
    credit?: FloatFieldUpdateOperationsInput | number
    remark?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_credit_transactionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    adminId?: NullableIntFieldUpdateOperationsInput | number | null
    updateBy?: StringFieldUpdateOperationsInput | string
    updateType?: StringFieldUpdateOperationsInput | string
    beforeUpdate?: FloatFieldUpdateOperationsInput | number
    afterUpdate?: FloatFieldUpdateOperationsInput | number
    credit?: FloatFieldUpdateOperationsInput | number
    remark?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_point_transactionCreateInput = {
    updateBy: string
    updateType: string
    beforeUpdate: number
    afterUpdate: number
    point: number
    remark?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: userCreateNestedOneWithoutUser_point_transactionInput
    admin?: adminCreateNestedOneWithoutUser_point_transactionInput
  }

  export type user_point_transactionUncheckedCreateInput = {
    id?: number
    userId: number
    adminId?: number | null
    updateBy: string
    updateType: string
    beforeUpdate: number
    afterUpdate: number
    point: number
    remark?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type user_point_transactionUpdateInput = {
    updateBy?: StringFieldUpdateOperationsInput | string
    updateType?: StringFieldUpdateOperationsInput | string
    beforeUpdate?: FloatFieldUpdateOperationsInput | number
    afterUpdate?: FloatFieldUpdateOperationsInput | number
    point?: FloatFieldUpdateOperationsInput | number
    remark?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: userUpdateOneRequiredWithoutUser_point_transactionNestedInput
    admin?: adminUpdateOneWithoutUser_point_transactionNestedInput
  }

  export type user_point_transactionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    adminId?: NullableIntFieldUpdateOperationsInput | number | null
    updateBy?: StringFieldUpdateOperationsInput | string
    updateType?: StringFieldUpdateOperationsInput | string
    beforeUpdate?: FloatFieldUpdateOperationsInput | number
    afterUpdate?: FloatFieldUpdateOperationsInput | number
    point?: FloatFieldUpdateOperationsInput | number
    remark?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_point_transactionCreateManyInput = {
    id?: number
    userId: number
    adminId?: number | null
    updateBy: string
    updateType: string
    beforeUpdate: number
    afterUpdate: number
    point: number
    remark?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type user_point_transactionUpdateManyMutationInput = {
    updateBy?: StringFieldUpdateOperationsInput | string
    updateType?: StringFieldUpdateOperationsInput | string
    beforeUpdate?: FloatFieldUpdateOperationsInput | number
    afterUpdate?: FloatFieldUpdateOperationsInput | number
    point?: FloatFieldUpdateOperationsInput | number
    remark?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_point_transactionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    adminId?: NullableIntFieldUpdateOperationsInput | number | null
    updateBy?: StringFieldUpdateOperationsInput | string
    updateType?: StringFieldUpdateOperationsInput | string
    beforeUpdate?: FloatFieldUpdateOperationsInput | number
    afterUpdate?: FloatFieldUpdateOperationsInput | number
    point?: FloatFieldUpdateOperationsInput | number
    remark?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type payment_transactionCreateInput = {
    price: number
    refCode: string
    status?: string
    base64?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: userCreateNestedOneWithoutPayment_transactionInput
  }

  export type payment_transactionUncheckedCreateInput = {
    id?: number
    userId: number
    price: number
    refCode: string
    status?: string
    base64?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type payment_transactionUpdateInput = {
    price?: FloatFieldUpdateOperationsInput | number
    refCode?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    base64?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: userUpdateOneRequiredWithoutPayment_transactionNestedInput
  }

  export type payment_transactionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    refCode?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    base64?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type payment_transactionCreateManyInput = {
    id?: number
    userId: number
    price: number
    refCode: string
    status?: string
    base64?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type payment_transactionUpdateManyMutationInput = {
    price?: FloatFieldUpdateOperationsInput | number
    refCode?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    base64?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type payment_transactionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    refCode?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    base64?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type addressCreateInput = {
    default?: boolean
    addressName: string
    details?: string | null
    remarks?: string | null
    receiverFname: string
    receiverLname: string
    receiverFullname: string
    receiverPhone: string
    houseNo: string
    villageNo?: string | null
    road?: string | null
    province: string
    district: string
    subDistrict: string
    postCode: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: userCreateNestedOneWithoutAddressInput
    order?: orderCreateNestedManyWithoutAddressInput
  }

  export type addressUncheckedCreateInput = {
    id?: number
    userId: number
    default?: boolean
    addressName: string
    details?: string | null
    remarks?: string | null
    receiverFname: string
    receiverLname: string
    receiverFullname: string
    receiverPhone: string
    houseNo: string
    villageNo?: string | null
    road?: string | null
    province: string
    district: string
    subDistrict: string
    postCode: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    order?: orderUncheckedCreateNestedManyWithoutAddressInput
  }

  export type addressUpdateInput = {
    default?: BoolFieldUpdateOperationsInput | boolean
    addressName?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    receiverFname?: StringFieldUpdateOperationsInput | string
    receiverLname?: StringFieldUpdateOperationsInput | string
    receiverFullname?: StringFieldUpdateOperationsInput | string
    receiverPhone?: StringFieldUpdateOperationsInput | string
    houseNo?: StringFieldUpdateOperationsInput | string
    villageNo?: NullableStringFieldUpdateOperationsInput | string | null
    road?: NullableStringFieldUpdateOperationsInput | string | null
    province?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    subDistrict?: StringFieldUpdateOperationsInput | string
    postCode?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: userUpdateOneRequiredWithoutAddressNestedInput
    order?: orderUpdateManyWithoutAddressNestedInput
  }

  export type addressUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    default?: BoolFieldUpdateOperationsInput | boolean
    addressName?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    receiverFname?: StringFieldUpdateOperationsInput | string
    receiverLname?: StringFieldUpdateOperationsInput | string
    receiverFullname?: StringFieldUpdateOperationsInput | string
    receiverPhone?: StringFieldUpdateOperationsInput | string
    houseNo?: StringFieldUpdateOperationsInput | string
    villageNo?: NullableStringFieldUpdateOperationsInput | string | null
    road?: NullableStringFieldUpdateOperationsInput | string | null
    province?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    subDistrict?: StringFieldUpdateOperationsInput | string
    postCode?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: orderUncheckedUpdateManyWithoutAddressNestedInput
  }

  export type addressCreateManyInput = {
    id?: number
    userId: number
    default?: boolean
    addressName: string
    details?: string | null
    remarks?: string | null
    receiverFname: string
    receiverLname: string
    receiverFullname: string
    receiverPhone: string
    houseNo: string
    villageNo?: string | null
    road?: string | null
    province: string
    district: string
    subDistrict: string
    postCode: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type addressUpdateManyMutationInput = {
    default?: BoolFieldUpdateOperationsInput | boolean
    addressName?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    receiverFname?: StringFieldUpdateOperationsInput | string
    receiverLname?: StringFieldUpdateOperationsInput | string
    receiverFullname?: StringFieldUpdateOperationsInput | string
    receiverPhone?: StringFieldUpdateOperationsInput | string
    houseNo?: StringFieldUpdateOperationsInput | string
    villageNo?: NullableStringFieldUpdateOperationsInput | string | null
    road?: NullableStringFieldUpdateOperationsInput | string | null
    province?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    subDistrict?: StringFieldUpdateOperationsInput | string
    postCode?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type addressUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    default?: BoolFieldUpdateOperationsInput | boolean
    addressName?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    receiverFname?: StringFieldUpdateOperationsInput | string
    receiverLname?: StringFieldUpdateOperationsInput | string
    receiverFullname?: StringFieldUpdateOperationsInput | string
    receiverPhone?: StringFieldUpdateOperationsInput | string
    houseNo?: StringFieldUpdateOperationsInput | string
    villageNo?: NullableStringFieldUpdateOperationsInput | string | null
    road?: NullableStringFieldUpdateOperationsInput | string | null
    province?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    subDistrict?: StringFieldUpdateOperationsInput | string
    postCode?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type brandCreateInput = {
    name: string
    detail?: string | null
    imagePath?: string | null
    imageSrc?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    product?: productCreateNestedManyWithoutBrandInput
  }

  export type brandUncheckedCreateInput = {
    id?: number
    name: string
    detail?: string | null
    imagePath?: string | null
    imageSrc?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    product?: productUncheckedCreateNestedManyWithoutBrandInput
  }

  export type brandUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    imageSrc?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: productUpdateManyWithoutBrandNestedInput
  }

  export type brandUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    imageSrc?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: productUncheckedUpdateManyWithoutBrandNestedInput
  }

  export type brandCreateManyInput = {
    id?: number
    name: string
    detail?: string | null
    imagePath?: string | null
    imageSrc?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type brandUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    imageSrc?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type brandUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    imageSrc?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tagCreateInput = {
    name: string
    detail?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    product_tag?: product_tagCreateNestedManyWithoutTagInput
  }

  export type tagUncheckedCreateInput = {
    id?: number
    name: string
    detail?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    product_tag?: product_tagUncheckedCreateNestedManyWithoutTagInput
  }

  export type tagUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product_tag?: product_tagUpdateManyWithoutTagNestedInput
  }

  export type tagUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product_tag?: product_tagUncheckedUpdateManyWithoutTagNestedInput
  }

  export type tagCreateManyInput = {
    id?: number
    name: string
    detail?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type tagUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tagUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type categoryCreateInput = {
    name: string
    detail?: string | null
    imagePath?: string | null
    imageSrc?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sub_category?: sub_categoryCreateNestedManyWithoutCategoryInput
  }

  export type categoryUncheckedCreateInput = {
    id?: number
    name: string
    detail?: string | null
    imagePath?: string | null
    imageSrc?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sub_category?: sub_categoryUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type categoryUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    imageSrc?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sub_category?: sub_categoryUpdateManyWithoutCategoryNestedInput
  }

  export type categoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    imageSrc?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sub_category?: sub_categoryUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type categoryCreateManyInput = {
    id?: number
    name: string
    detail?: string | null
    imagePath?: string | null
    imageSrc?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type categoryUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    imageSrc?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type categoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    imageSrc?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type sub_categoryCreateInput = {
    name: string
    detail?: string | null
    imagePath?: string | null
    imageSrc?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    category: categoryCreateNestedOneWithoutSub_categoryInput
  }

  export type sub_categoryUncheckedCreateInput = {
    id?: number
    categoryId: number
    name: string
    detail?: string | null
    imagePath?: string | null
    imageSrc?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type sub_categoryUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    imageSrc?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: categoryUpdateOneRequiredWithoutSub_categoryNestedInput
  }

  export type sub_categoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    categoryId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    imageSrc?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type sub_categoryCreateManyInput = {
    id?: number
    categoryId: number
    name: string
    detail?: string | null
    imagePath?: string | null
    imageSrc?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type sub_categoryUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    imageSrc?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type sub_categoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    categoryId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    imageSrc?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type product_reviewCreateInput = {
    detail?: string | null
    rating?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: userCreateNestedOneWithoutProduct_reviewInput
    product: productCreateNestedOneWithoutProduct_reviewInput
    admin: adminCreateNestedOneWithoutProduct_reviewInput
  }

  export type product_reviewUncheckedCreateInput = {
    id?: number
    userId: number
    productId: number
    adminId: number
    detail?: string | null
    rating?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type product_reviewUpdateInput = {
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: userUpdateOneRequiredWithoutProduct_reviewNestedInput
    product?: productUpdateOneRequiredWithoutProduct_reviewNestedInput
    admin?: adminUpdateOneRequiredWithoutProduct_reviewNestedInput
  }

  export type product_reviewUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    adminId?: IntFieldUpdateOperationsInput | number
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type product_reviewCreateManyInput = {
    id?: number
    userId: number
    productId: number
    adminId: number
    detail?: string | null
    rating?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type product_reviewUpdateManyMutationInput = {
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type product_reviewUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    adminId?: IntFieldUpdateOperationsInput | number
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type review_imageCreateInput = {
    imagePath?: string | null
    imageSrc?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type review_imageUncheckedCreateInput = {
    id?: number
    imagePath?: string | null
    imageSrc?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type review_imageUpdateInput = {
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    imageSrc?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type review_imageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    imageSrc?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type review_imageCreateManyInput = {
    id?: number
    imagePath?: string | null
    imageSrc?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type review_imageUpdateManyMutationInput = {
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    imageSrc?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type review_imageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    imageSrc?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type productCreateInput = {
    name: string
    shortName?: string | null
    detail?: string | null
    isDiscount?: boolean
    discountPercent: number
    minPrice: number
    maxPrice: number
    slug: string
    cardImgPath: string
    cardImgSrc: string
    optionFirst?: string | null
    optionSecond?: string | null
    isWholesale?: boolean
    rating?: number
    sold?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    brand: brandCreateNestedOneWithoutProductInput
    admin: adminCreateNestedOneWithoutProductInput
    product_image?: product_imageCreateNestedManyWithoutProductInput
    product_spec?: product_specCreateNestedManyWithoutProductInput
    product_detail?: product_detailCreateNestedManyWithoutProductInput
    product_option_first?: product_option_firstCreateNestedManyWithoutProductInput
    product_option_second?: product_option_secondCreateNestedManyWithoutProductInput
    product_price?: product_priceCreateNestedManyWithoutProductInput
    product_wholesale?: product_wholesaleCreateNestedManyWithoutProductInput
    product_review?: product_reviewCreateNestedManyWithoutProductInput
    product_tag?: product_tagCreateNestedManyWithoutProductInput
    cart?: cartCreateNestedManyWithoutProductInput
    order_product?: order_productCreateNestedManyWithoutProductInput
  }

  export type productUncheckedCreateInput = {
    id?: number
    brandId: number
    adminId: number
    name: string
    shortName?: string | null
    detail?: string | null
    isDiscount?: boolean
    discountPercent: number
    minPrice: number
    maxPrice: number
    slug: string
    cardImgPath: string
    cardImgSrc: string
    optionFirst?: string | null
    optionSecond?: string | null
    isWholesale?: boolean
    rating?: number
    sold?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    product_image?: product_imageUncheckedCreateNestedManyWithoutProductInput
    product_spec?: product_specUncheckedCreateNestedManyWithoutProductInput
    product_detail?: product_detailUncheckedCreateNestedManyWithoutProductInput
    product_option_first?: product_option_firstUncheckedCreateNestedManyWithoutProductInput
    product_option_second?: product_option_secondUncheckedCreateNestedManyWithoutProductInput
    product_price?: product_priceUncheckedCreateNestedManyWithoutProductInput
    product_wholesale?: product_wholesaleUncheckedCreateNestedManyWithoutProductInput
    product_review?: product_reviewUncheckedCreateNestedManyWithoutProductInput
    product_tag?: product_tagUncheckedCreateNestedManyWithoutProductInput
    cart?: cartUncheckedCreateNestedManyWithoutProductInput
    order_product?: order_productUncheckedCreateNestedManyWithoutProductInput
  }

  export type productUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    shortName?: NullableStringFieldUpdateOperationsInput | string | null
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    isDiscount?: BoolFieldUpdateOperationsInput | boolean
    discountPercent?: IntFieldUpdateOperationsInput | number
    minPrice?: FloatFieldUpdateOperationsInput | number
    maxPrice?: FloatFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    cardImgPath?: StringFieldUpdateOperationsInput | string
    cardImgSrc?: StringFieldUpdateOperationsInput | string
    optionFirst?: NullableStringFieldUpdateOperationsInput | string | null
    optionSecond?: NullableStringFieldUpdateOperationsInput | string | null
    isWholesale?: BoolFieldUpdateOperationsInput | boolean
    rating?: IntFieldUpdateOperationsInput | number
    sold?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    brand?: brandUpdateOneRequiredWithoutProductNestedInput
    admin?: adminUpdateOneRequiredWithoutProductNestedInput
    product_image?: product_imageUpdateManyWithoutProductNestedInput
    product_spec?: product_specUpdateManyWithoutProductNestedInput
    product_detail?: product_detailUpdateManyWithoutProductNestedInput
    product_option_first?: product_option_firstUpdateManyWithoutProductNestedInput
    product_option_second?: product_option_secondUpdateManyWithoutProductNestedInput
    product_price?: product_priceUpdateManyWithoutProductNestedInput
    product_wholesale?: product_wholesaleUpdateManyWithoutProductNestedInput
    product_review?: product_reviewUpdateManyWithoutProductNestedInput
    product_tag?: product_tagUpdateManyWithoutProductNestedInput
    cart?: cartUpdateManyWithoutProductNestedInput
    order_product?: order_productUpdateManyWithoutProductNestedInput
  }

  export type productUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    brandId?: IntFieldUpdateOperationsInput | number
    adminId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    shortName?: NullableStringFieldUpdateOperationsInput | string | null
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    isDiscount?: BoolFieldUpdateOperationsInput | boolean
    discountPercent?: IntFieldUpdateOperationsInput | number
    minPrice?: FloatFieldUpdateOperationsInput | number
    maxPrice?: FloatFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    cardImgPath?: StringFieldUpdateOperationsInput | string
    cardImgSrc?: StringFieldUpdateOperationsInput | string
    optionFirst?: NullableStringFieldUpdateOperationsInput | string | null
    optionSecond?: NullableStringFieldUpdateOperationsInput | string | null
    isWholesale?: BoolFieldUpdateOperationsInput | boolean
    rating?: IntFieldUpdateOperationsInput | number
    sold?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product_image?: product_imageUncheckedUpdateManyWithoutProductNestedInput
    product_spec?: product_specUncheckedUpdateManyWithoutProductNestedInput
    product_detail?: product_detailUncheckedUpdateManyWithoutProductNestedInput
    product_option_first?: product_option_firstUncheckedUpdateManyWithoutProductNestedInput
    product_option_second?: product_option_secondUncheckedUpdateManyWithoutProductNestedInput
    product_price?: product_priceUncheckedUpdateManyWithoutProductNestedInput
    product_wholesale?: product_wholesaleUncheckedUpdateManyWithoutProductNestedInput
    product_review?: product_reviewUncheckedUpdateManyWithoutProductNestedInput
    product_tag?: product_tagUncheckedUpdateManyWithoutProductNestedInput
    cart?: cartUncheckedUpdateManyWithoutProductNestedInput
    order_product?: order_productUncheckedUpdateManyWithoutProductNestedInput
  }

  export type productCreateManyInput = {
    id?: number
    brandId: number
    adminId: number
    name: string
    shortName?: string | null
    detail?: string | null
    isDiscount?: boolean
    discountPercent: number
    minPrice: number
    maxPrice: number
    slug: string
    cardImgPath: string
    cardImgSrc: string
    optionFirst?: string | null
    optionSecond?: string | null
    isWholesale?: boolean
    rating?: number
    sold?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type productUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    shortName?: NullableStringFieldUpdateOperationsInput | string | null
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    isDiscount?: BoolFieldUpdateOperationsInput | boolean
    discountPercent?: IntFieldUpdateOperationsInput | number
    minPrice?: FloatFieldUpdateOperationsInput | number
    maxPrice?: FloatFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    cardImgPath?: StringFieldUpdateOperationsInput | string
    cardImgSrc?: StringFieldUpdateOperationsInput | string
    optionFirst?: NullableStringFieldUpdateOperationsInput | string | null
    optionSecond?: NullableStringFieldUpdateOperationsInput | string | null
    isWholesale?: BoolFieldUpdateOperationsInput | boolean
    rating?: IntFieldUpdateOperationsInput | number
    sold?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type productUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    brandId?: IntFieldUpdateOperationsInput | number
    adminId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    shortName?: NullableStringFieldUpdateOperationsInput | string | null
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    isDiscount?: BoolFieldUpdateOperationsInput | boolean
    discountPercent?: IntFieldUpdateOperationsInput | number
    minPrice?: FloatFieldUpdateOperationsInput | number
    maxPrice?: FloatFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    cardImgPath?: StringFieldUpdateOperationsInput | string
    cardImgSrc?: StringFieldUpdateOperationsInput | string
    optionFirst?: NullableStringFieldUpdateOperationsInput | string | null
    optionSecond?: NullableStringFieldUpdateOperationsInput | string | null
    isWholesale?: BoolFieldUpdateOperationsInput | boolean
    rating?: IntFieldUpdateOperationsInput | number
    sold?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type product_tagCreateInput = {
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    product: productCreateNestedOneWithoutProduct_tagInput
    tag: tagCreateNestedOneWithoutProduct_tagInput
  }

  export type product_tagUncheckedCreateInput = {
    id?: number
    productId: number
    tagId: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type product_tagUpdateInput = {
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: productUpdateOneRequiredWithoutProduct_tagNestedInput
    tag?: tagUpdateOneRequiredWithoutProduct_tagNestedInput
  }

  export type product_tagUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    tagId?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type product_tagCreateManyInput = {
    id?: number
    productId: number
    tagId: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type product_tagUpdateManyMutationInput = {
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type product_tagUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    tagId?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type product_wholesaleCreateInput = {
    min: number
    price: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    product: productCreateNestedOneWithoutProduct_wholesaleInput
  }

  export type product_wholesaleUncheckedCreateInput = {
    id?: number
    productId: number
    min: number
    price: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type product_wholesaleUpdateInput = {
    min?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: productUpdateOneRequiredWithoutProduct_wholesaleNestedInput
  }

  export type product_wholesaleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    min?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type product_wholesaleCreateManyInput = {
    id?: number
    productId: number
    min: number
    price: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type product_wholesaleUpdateManyMutationInput = {
    min?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type product_wholesaleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    min?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type product_option_firstCreateInput = {
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    product: productCreateNestedOneWithoutProduct_option_firstInput
    product_price?: product_priceCreateNestedManyWithoutProduct_option_firstInput
  }

  export type product_option_firstUncheckedCreateInput = {
    id?: number
    productId: number
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    product_price?: product_priceUncheckedCreateNestedManyWithoutProduct_option_firstInput
  }

  export type product_option_firstUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: productUpdateOneRequiredWithoutProduct_option_firstNestedInput
    product_price?: product_priceUpdateManyWithoutProduct_option_firstNestedInput
  }

  export type product_option_firstUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product_price?: product_priceUncheckedUpdateManyWithoutProduct_option_firstNestedInput
  }

  export type product_option_firstCreateManyInput = {
    id?: number
    productId: number
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type product_option_firstUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type product_option_firstUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type product_option_secondCreateInput = {
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    product: productCreateNestedOneWithoutProduct_option_secondInput
    product_price?: product_priceCreateNestedManyWithoutProduct_option_secondInput
  }

  export type product_option_secondUncheckedCreateInput = {
    id?: number
    productId: number
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    product_price?: product_priceUncheckedCreateNestedManyWithoutProduct_option_secondInput
  }

  export type product_option_secondUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: productUpdateOneRequiredWithoutProduct_option_secondNestedInput
    product_price?: product_priceUpdateManyWithoutProduct_option_secondNestedInput
  }

  export type product_option_secondUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product_price?: product_priceUncheckedUpdateManyWithoutProduct_option_secondNestedInput
  }

  export type product_option_secondCreateManyInput = {
    id?: number
    productId: number
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type product_option_secondUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type product_option_secondUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type product_priceCreateInput = {
    price: number
    sku?: string | null
    isWholesale?: boolean
    product: productCreateNestedOneWithoutProduct_priceInput
    product_option_first?: product_option_firstCreateNestedOneWithoutProduct_priceInput
    product_option_second?: product_option_secondCreateNestedOneWithoutProduct_priceInput
    cart?: cartCreateNestedManyWithoutProduct_priceInput
    order_product?: order_productCreateNestedManyWithoutProduct_priceInput
  }

  export type product_priceUncheckedCreateInput = {
    id?: number
    productId: number
    product_option_firstId?: number | null
    product_option_secondId?: number | null
    price: number
    sku?: string | null
    isWholesale?: boolean
    cart?: cartUncheckedCreateNestedManyWithoutProduct_priceInput
    order_product?: order_productUncheckedCreateNestedManyWithoutProduct_priceInput
  }

  export type product_priceUpdateInput = {
    price?: FloatFieldUpdateOperationsInput | number
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    isWholesale?: BoolFieldUpdateOperationsInput | boolean
    product?: productUpdateOneRequiredWithoutProduct_priceNestedInput
    product_option_first?: product_option_firstUpdateOneWithoutProduct_priceNestedInput
    product_option_second?: product_option_secondUpdateOneWithoutProduct_priceNestedInput
    cart?: cartUpdateManyWithoutProduct_priceNestedInput
    order_product?: order_productUpdateManyWithoutProduct_priceNestedInput
  }

  export type product_priceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    product_option_firstId?: NullableIntFieldUpdateOperationsInput | number | null
    product_option_secondId?: NullableIntFieldUpdateOperationsInput | number | null
    price?: FloatFieldUpdateOperationsInput | number
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    isWholesale?: BoolFieldUpdateOperationsInput | boolean
    cart?: cartUncheckedUpdateManyWithoutProduct_priceNestedInput
    order_product?: order_productUncheckedUpdateManyWithoutProduct_priceNestedInput
  }

  export type product_priceCreateManyInput = {
    id?: number
    productId: number
    product_option_firstId?: number | null
    product_option_secondId?: number | null
    price: number
    sku?: string | null
    isWholesale?: boolean
  }

  export type product_priceUpdateManyMutationInput = {
    price?: FloatFieldUpdateOperationsInput | number
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    isWholesale?: BoolFieldUpdateOperationsInput | boolean
  }

  export type product_priceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    product_option_firstId?: NullableIntFieldUpdateOperationsInput | number | null
    product_option_secondId?: NullableIntFieldUpdateOperationsInput | number | null
    price?: FloatFieldUpdateOperationsInput | number
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    isWholesale?: BoolFieldUpdateOperationsInput | boolean
  }

  export type product_detailCreateInput = {
    name: string
    details?: string | null
    imagePath?: string | null
    imageSrc?: string | null
    videoPath?: string | null
    videoSrc?: string | null
    videoType?: string | null
    link?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    product: productCreateNestedOneWithoutProduct_detailInput
  }

  export type product_detailUncheckedCreateInput = {
    id?: number
    productId: number
    name: string
    details?: string | null
    imagePath?: string | null
    imageSrc?: string | null
    videoPath?: string | null
    videoSrc?: string | null
    videoType?: string | null
    link?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type product_detailUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    imageSrc?: NullableStringFieldUpdateOperationsInput | string | null
    videoPath?: NullableStringFieldUpdateOperationsInput | string | null
    videoSrc?: NullableStringFieldUpdateOperationsInput | string | null
    videoType?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: productUpdateOneRequiredWithoutProduct_detailNestedInput
  }

  export type product_detailUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    imageSrc?: NullableStringFieldUpdateOperationsInput | string | null
    videoPath?: NullableStringFieldUpdateOperationsInput | string | null
    videoSrc?: NullableStringFieldUpdateOperationsInput | string | null
    videoType?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type product_detailCreateManyInput = {
    id?: number
    productId: number
    name: string
    details?: string | null
    imagePath?: string | null
    imageSrc?: string | null
    videoPath?: string | null
    videoSrc?: string | null
    videoType?: string | null
    link?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type product_detailUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    imageSrc?: NullableStringFieldUpdateOperationsInput | string | null
    videoPath?: NullableStringFieldUpdateOperationsInput | string | null
    videoSrc?: NullableStringFieldUpdateOperationsInput | string | null
    videoType?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type product_detailUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    imageSrc?: NullableStringFieldUpdateOperationsInput | string | null
    videoPath?: NullableStringFieldUpdateOperationsInput | string | null
    videoSrc?: NullableStringFieldUpdateOperationsInput | string | null
    videoType?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type product_imageCreateInput = {
    name: string
    path: string
    src: string
    sequence: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    product: productCreateNestedOneWithoutProduct_imageInput
  }

  export type product_imageUncheckedCreateInput = {
    id?: number
    name: string
    path: string
    src: string
    sequence: number
    productId: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type product_imageUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    src?: StringFieldUpdateOperationsInput | string
    sequence?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: productUpdateOneRequiredWithoutProduct_imageNestedInput
  }

  export type product_imageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    src?: StringFieldUpdateOperationsInput | string
    sequence?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type product_imageCreateManyInput = {
    id?: number
    name: string
    path: string
    src: string
    sequence: number
    productId: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type product_imageUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    src?: StringFieldUpdateOperationsInput | string
    sequence?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type product_imageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    src?: StringFieldUpdateOperationsInput | string
    sequence?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type product_specCreateInput = {
    name: string
    data: JsonNullValueInput | InputJsonValue
    product: productCreateNestedOneWithoutProduct_specInput
  }

  export type product_specUncheckedCreateInput = {
    id?: number
    name: string
    data: JsonNullValueInput | InputJsonValue
    productId: number
  }

  export type product_specUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    product?: productUpdateOneRequiredWithoutProduct_specNestedInput
  }

  export type product_specUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    productId?: IntFieldUpdateOperationsInput | number
  }

  export type product_specCreateManyInput = {
    id?: number
    name: string
    data: JsonNullValueInput | InputJsonValue
    productId: number
  }

  export type product_specUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
  }

  export type product_specUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    productId?: IntFieldUpdateOperationsInput | number
  }

  export type cartCreateInput = {
    qty: number
    price: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: userCreateNestedOneWithoutCartInput
    product: productCreateNestedOneWithoutCartInput
    product_price: product_priceCreateNestedOneWithoutCartInput
  }

  export type cartUncheckedCreateInput = {
    id?: number
    userId: number
    productId: number
    product_priceId: number
    qty: number
    price: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type cartUpdateInput = {
    qty?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: userUpdateOneRequiredWithoutCartNestedInput
    product?: productUpdateOneRequiredWithoutCartNestedInput
    product_price?: product_priceUpdateOneRequiredWithoutCartNestedInput
  }

  export type cartUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    product_priceId?: IntFieldUpdateOperationsInput | number
    qty?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type cartCreateManyInput = {
    id?: number
    userId: number
    productId: number
    product_priceId: number
    qty: number
    price: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type cartUpdateManyMutationInput = {
    qty?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type cartUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    product_priceId?: IntFieldUpdateOperationsInput | number
    qty?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type orderCreateInput = {
    statusNow?: string
    status: JsonNullValueInput | InputJsonValue
    paymentType: string
    paymentStatus?: string
    createUsing?: number
    pointUsing?: number
    orderPrice: number
    deliveryPrice: number
    netPrice: number
    orderDiscount: number
    deliveryDiscount: number
    orderDiscountCode: string
    deliveryDiscountCode: string
    addressData: JsonNullValueInput | InputJsonValue
    userData: JsonNullValueInput | InputJsonValue
    isReject?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: userCreateNestedOneWithoutOrderInput
    address: addressCreateNestedOneWithoutOrderInput
    order_product?: order_productCreateNestedManyWithoutOrderInput
  }

  export type orderUncheckedCreateInput = {
    id?: number
    userId: number
    statusNow?: string
    status: JsonNullValueInput | InputJsonValue
    paymentType: string
    paymentStatus?: string
    createUsing?: number
    pointUsing?: number
    orderPrice: number
    deliveryPrice: number
    netPrice: number
    orderDiscount: number
    deliveryDiscount: number
    orderDiscountCode: string
    deliveryDiscountCode: string
    addressId: number
    addressData: JsonNullValueInput | InputJsonValue
    userData: JsonNullValueInput | InputJsonValue
    isReject?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    order_product?: order_productUncheckedCreateNestedManyWithoutOrderInput
  }

  export type orderUpdateInput = {
    statusNow?: StringFieldUpdateOperationsInput | string
    status?: JsonNullValueInput | InputJsonValue
    paymentType?: StringFieldUpdateOperationsInput | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    createUsing?: FloatFieldUpdateOperationsInput | number
    pointUsing?: FloatFieldUpdateOperationsInput | number
    orderPrice?: FloatFieldUpdateOperationsInput | number
    deliveryPrice?: FloatFieldUpdateOperationsInput | number
    netPrice?: FloatFieldUpdateOperationsInput | number
    orderDiscount?: FloatFieldUpdateOperationsInput | number
    deliveryDiscount?: FloatFieldUpdateOperationsInput | number
    orderDiscountCode?: StringFieldUpdateOperationsInput | string
    deliveryDiscountCode?: StringFieldUpdateOperationsInput | string
    addressData?: JsonNullValueInput | InputJsonValue
    userData?: JsonNullValueInput | InputJsonValue
    isReject?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: userUpdateOneRequiredWithoutOrderNestedInput
    address?: addressUpdateOneRequiredWithoutOrderNestedInput
    order_product?: order_productUpdateManyWithoutOrderNestedInput
  }

  export type orderUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    statusNow?: StringFieldUpdateOperationsInput | string
    status?: JsonNullValueInput | InputJsonValue
    paymentType?: StringFieldUpdateOperationsInput | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    createUsing?: FloatFieldUpdateOperationsInput | number
    pointUsing?: FloatFieldUpdateOperationsInput | number
    orderPrice?: FloatFieldUpdateOperationsInput | number
    deliveryPrice?: FloatFieldUpdateOperationsInput | number
    netPrice?: FloatFieldUpdateOperationsInput | number
    orderDiscount?: FloatFieldUpdateOperationsInput | number
    deliveryDiscount?: FloatFieldUpdateOperationsInput | number
    orderDiscountCode?: StringFieldUpdateOperationsInput | string
    deliveryDiscountCode?: StringFieldUpdateOperationsInput | string
    addressId?: IntFieldUpdateOperationsInput | number
    addressData?: JsonNullValueInput | InputJsonValue
    userData?: JsonNullValueInput | InputJsonValue
    isReject?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order_product?: order_productUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type orderCreateManyInput = {
    id?: number
    userId: number
    statusNow?: string
    status: JsonNullValueInput | InputJsonValue
    paymentType: string
    paymentStatus?: string
    createUsing?: number
    pointUsing?: number
    orderPrice: number
    deliveryPrice: number
    netPrice: number
    orderDiscount: number
    deliveryDiscount: number
    orderDiscountCode: string
    deliveryDiscountCode: string
    addressId: number
    addressData: JsonNullValueInput | InputJsonValue
    userData: JsonNullValueInput | InputJsonValue
    isReject?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type orderUpdateManyMutationInput = {
    statusNow?: StringFieldUpdateOperationsInput | string
    status?: JsonNullValueInput | InputJsonValue
    paymentType?: StringFieldUpdateOperationsInput | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    createUsing?: FloatFieldUpdateOperationsInput | number
    pointUsing?: FloatFieldUpdateOperationsInput | number
    orderPrice?: FloatFieldUpdateOperationsInput | number
    deliveryPrice?: FloatFieldUpdateOperationsInput | number
    netPrice?: FloatFieldUpdateOperationsInput | number
    orderDiscount?: FloatFieldUpdateOperationsInput | number
    deliveryDiscount?: FloatFieldUpdateOperationsInput | number
    orderDiscountCode?: StringFieldUpdateOperationsInput | string
    deliveryDiscountCode?: StringFieldUpdateOperationsInput | string
    addressData?: JsonNullValueInput | InputJsonValue
    userData?: JsonNullValueInput | InputJsonValue
    isReject?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type orderUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    statusNow?: StringFieldUpdateOperationsInput | string
    status?: JsonNullValueInput | InputJsonValue
    paymentType?: StringFieldUpdateOperationsInput | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    createUsing?: FloatFieldUpdateOperationsInput | number
    pointUsing?: FloatFieldUpdateOperationsInput | number
    orderPrice?: FloatFieldUpdateOperationsInput | number
    deliveryPrice?: FloatFieldUpdateOperationsInput | number
    netPrice?: FloatFieldUpdateOperationsInput | number
    orderDiscount?: FloatFieldUpdateOperationsInput | number
    deliveryDiscount?: FloatFieldUpdateOperationsInput | number
    orderDiscountCode?: StringFieldUpdateOperationsInput | string
    deliveryDiscountCode?: StringFieldUpdateOperationsInput | string
    addressId?: IntFieldUpdateOperationsInput | number
    addressData?: JsonNullValueInput | InputJsonValue
    userData?: JsonNullValueInput | InputJsonValue
    isReject?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type order_productCreateInput = {
    qty: number
    price: number
    productData: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: userCreateNestedOneWithoutOrder_productInput
    product: productCreateNestedOneWithoutOrder_productInput
    order: orderCreateNestedOneWithoutOrder_productInput
    product_price: product_priceCreateNestedOneWithoutOrder_productInput
  }

  export type order_productUncheckedCreateInput = {
    id?: number
    userId: number
    productId: number
    orderId: number
    product_priceId: number
    qty: number
    price: number
    productData: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type order_productUpdateInput = {
    qty?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    productData?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: userUpdateOneRequiredWithoutOrder_productNestedInput
    product?: productUpdateOneRequiredWithoutOrder_productNestedInput
    order?: orderUpdateOneRequiredWithoutOrder_productNestedInput
    product_price?: product_priceUpdateOneRequiredWithoutOrder_productNestedInput
  }

  export type order_productUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    product_priceId?: IntFieldUpdateOperationsInput | number
    qty?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    productData?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type order_productCreateManyInput = {
    id?: number
    userId: number
    productId: number
    orderId: number
    product_priceId: number
    qty: number
    price: number
    productData: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type order_productUpdateManyMutationInput = {
    qty?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    productData?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type order_productUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    product_priceId?: IntFieldUpdateOperationsInput | number
    qty?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    productData?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type settingCreateInput = {
    facebook?: string | null
    line?: string | null
    instagram?: string | null
    tiktok?: string | null
    email?: string | null
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type settingUncheckedCreateInput = {
    id?: number
    facebook?: string | null
    line?: string | null
    instagram?: string | null
    tiktok?: string | null
    email?: string | null
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type settingUpdateInput = {
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    line?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    tiktok?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type settingUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    line?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    tiktok?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type settingCreateManyInput = {
    id?: number
    facebook?: string | null
    line?: string | null
    instagram?: string | null
    tiktok?: string | null
    email?: string | null
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type settingUpdateManyMutationInput = {
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    line?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    tiktok?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type settingUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    line?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    tiktok?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type setting_serviceCreateInput = {
    lineNotiToken?: string | null
    gmpayToken?: string | null
    seo?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type setting_serviceUncheckedCreateInput = {
    id?: number
    lineNotiToken?: string | null
    gmpayToken?: string | null
    seo?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type setting_serviceUpdateInput = {
    lineNotiToken?: NullableStringFieldUpdateOperationsInput | string | null
    gmpayToken?: NullableStringFieldUpdateOperationsInput | string | null
    seo?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type setting_serviceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    lineNotiToken?: NullableStringFieldUpdateOperationsInput | string | null
    gmpayToken?: NullableStringFieldUpdateOperationsInput | string | null
    seo?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type setting_serviceCreateManyInput = {
    id?: number
    lineNotiToken?: string | null
    gmpayToken?: string | null
    seo?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type setting_serviceUpdateManyMutationInput = {
    lineNotiToken?: NullableStringFieldUpdateOperationsInput | string | null
    gmpayToken?: NullableStringFieldUpdateOperationsInput | string | null
    seo?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type setting_serviceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    lineNotiToken?: NullableStringFieldUpdateOperationsInput | string | null
    gmpayToken?: NullableStringFieldUpdateOperationsInput | string | null
    seo?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type User_credit_transactionListRelationFilter = {
    every?: user_credit_transactionWhereInput
    some?: user_credit_transactionWhereInput
    none?: user_credit_transactionWhereInput
  }

  export type User_point_transactionListRelationFilter = {
    every?: user_point_transactionWhereInput
    some?: user_point_transactionWhereInput
    none?: user_point_transactionWhereInput
  }

  export type Product_reviewListRelationFilter = {
    every?: product_reviewWhereInput
    some?: product_reviewWhereInput
    none?: product_reviewWhereInput
  }

  export type ProductListRelationFilter = {
    every?: productWhereInput
    some?: productWhereInput
    none?: productWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type user_credit_transactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type user_point_transactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type product_reviewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type productOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type adminCountOrderByAggregateInput = {
    id?: SortOrder
    userName?: SortOrder
    fname?: SortOrder
    lname?: SortOrder
    fullname?: SortOrder
    role?: SortOrder
    permission?: SortOrder
    email?: SortOrder
    avatarPath?: SortOrder
    avatarSrc?: SortOrder
    phone?: SortOrder
    refreshToken?: SortOrder
    password?: SortOrder
    passwordRt?: SortOrder
    ipv4?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type adminAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type adminMaxOrderByAggregateInput = {
    id?: SortOrder
    userName?: SortOrder
    fname?: SortOrder
    lname?: SortOrder
    fullname?: SortOrder
    role?: SortOrder
    email?: SortOrder
    avatarPath?: SortOrder
    avatarSrc?: SortOrder
    phone?: SortOrder
    refreshToken?: SortOrder
    password?: SortOrder
    passwordRt?: SortOrder
    ipv4?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type adminMinOrderByAggregateInput = {
    id?: SortOrder
    userName?: SortOrder
    fname?: SortOrder
    lname?: SortOrder
    fullname?: SortOrder
    role?: SortOrder
    email?: SortOrder
    avatarPath?: SortOrder
    avatarSrc?: SortOrder
    phone?: SortOrder
    refreshToken?: SortOrder
    password?: SortOrder
    passwordRt?: SortOrder
    ipv4?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type adminSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type AddressListRelationFilter = {
    every?: addressWhereInput
    some?: addressWhereInput
    none?: addressWhereInput
  }

  export type Payment_transactionListRelationFilter = {
    every?: payment_transactionWhereInput
    some?: payment_transactionWhereInput
    none?: payment_transactionWhereInput
  }

  export type CartListRelationFilter = {
    every?: cartWhereInput
    some?: cartWhereInput
    none?: cartWhereInput
  }

  export type OrderListRelationFilter = {
    every?: orderWhereInput
    some?: orderWhereInput
    none?: orderWhereInput
  }

  export type Order_productListRelationFilter = {
    every?: order_productWhereInput
    some?: order_productWhereInput
    none?: order_productWhereInput
  }

  export type addressOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type payment_transactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type cartOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type orderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type order_productOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type userCountOrderByAggregateInput = {
    id?: SortOrder
    avatarPath?: SortOrder
    avatarSrc?: SortOrder
    fname?: SortOrder
    lname?: SortOrder
    fullname?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    credit?: SortOrder
    point?: SortOrder
    lineId?: SortOrder
    baned?: SortOrder
    ipv4?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type userAvgOrderByAggregateInput = {
    id?: SortOrder
    credit?: SortOrder
    point?: SortOrder
  }

  export type userMaxOrderByAggregateInput = {
    id?: SortOrder
    avatarPath?: SortOrder
    avatarSrc?: SortOrder
    fname?: SortOrder
    lname?: SortOrder
    fullname?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    credit?: SortOrder
    point?: SortOrder
    lineId?: SortOrder
    baned?: SortOrder
    ipv4?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type userMinOrderByAggregateInput = {
    id?: SortOrder
    avatarPath?: SortOrder
    avatarSrc?: SortOrder
    fname?: SortOrder
    lname?: SortOrder
    fullname?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    credit?: SortOrder
    point?: SortOrder
    lineId?: SortOrder
    baned?: SortOrder
    ipv4?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type userSumOrderByAggregateInput = {
    id?: SortOrder
    credit?: SortOrder
    point?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type UserRelationFilter = {
    is?: userWhereInput
    isNot?: userWhereInput
  }

  export type AdminNullableRelationFilter = {
    is?: adminWhereInput | null
    isNot?: adminWhereInput | null
  }

  export type user_credit_transactionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    adminId?: SortOrder
    updateBy?: SortOrder
    updateType?: SortOrder
    beforeUpdate?: SortOrder
    afterUpdate?: SortOrder
    credit?: SortOrder
    remark?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type user_credit_transactionAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    adminId?: SortOrder
    beforeUpdate?: SortOrder
    afterUpdate?: SortOrder
    credit?: SortOrder
  }

  export type user_credit_transactionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    adminId?: SortOrder
    updateBy?: SortOrder
    updateType?: SortOrder
    beforeUpdate?: SortOrder
    afterUpdate?: SortOrder
    credit?: SortOrder
    remark?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type user_credit_transactionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    adminId?: SortOrder
    updateBy?: SortOrder
    updateType?: SortOrder
    beforeUpdate?: SortOrder
    afterUpdate?: SortOrder
    credit?: SortOrder
    remark?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type user_credit_transactionSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    adminId?: SortOrder
    beforeUpdate?: SortOrder
    afterUpdate?: SortOrder
    credit?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type user_point_transactionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    adminId?: SortOrder
    updateBy?: SortOrder
    updateType?: SortOrder
    beforeUpdate?: SortOrder
    afterUpdate?: SortOrder
    point?: SortOrder
    remark?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type user_point_transactionAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    adminId?: SortOrder
    beforeUpdate?: SortOrder
    afterUpdate?: SortOrder
    point?: SortOrder
  }

  export type user_point_transactionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    adminId?: SortOrder
    updateBy?: SortOrder
    updateType?: SortOrder
    beforeUpdate?: SortOrder
    afterUpdate?: SortOrder
    point?: SortOrder
    remark?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type user_point_transactionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    adminId?: SortOrder
    updateBy?: SortOrder
    updateType?: SortOrder
    beforeUpdate?: SortOrder
    afterUpdate?: SortOrder
    point?: SortOrder
    remark?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type user_point_transactionSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    adminId?: SortOrder
    beforeUpdate?: SortOrder
    afterUpdate?: SortOrder
    point?: SortOrder
  }

  export type payment_transactionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    price?: SortOrder
    refCode?: SortOrder
    status?: SortOrder
    base64?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type payment_transactionAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    price?: SortOrder
  }

  export type payment_transactionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    price?: SortOrder
    refCode?: SortOrder
    status?: SortOrder
    base64?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type payment_transactionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    price?: SortOrder
    refCode?: SortOrder
    status?: SortOrder
    base64?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type payment_transactionSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    price?: SortOrder
  }

  export type addressCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    default?: SortOrder
    addressName?: SortOrder
    details?: SortOrder
    remarks?: SortOrder
    receiverFname?: SortOrder
    receiverLname?: SortOrder
    receiverFullname?: SortOrder
    receiverPhone?: SortOrder
    houseNo?: SortOrder
    villageNo?: SortOrder
    road?: SortOrder
    province?: SortOrder
    district?: SortOrder
    subDistrict?: SortOrder
    postCode?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type addressAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type addressMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    default?: SortOrder
    addressName?: SortOrder
    details?: SortOrder
    remarks?: SortOrder
    receiverFname?: SortOrder
    receiverLname?: SortOrder
    receiverFullname?: SortOrder
    receiverPhone?: SortOrder
    houseNo?: SortOrder
    villageNo?: SortOrder
    road?: SortOrder
    province?: SortOrder
    district?: SortOrder
    subDistrict?: SortOrder
    postCode?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type addressMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    default?: SortOrder
    addressName?: SortOrder
    details?: SortOrder
    remarks?: SortOrder
    receiverFname?: SortOrder
    receiverLname?: SortOrder
    receiverFullname?: SortOrder
    receiverPhone?: SortOrder
    houseNo?: SortOrder
    villageNo?: SortOrder
    road?: SortOrder
    province?: SortOrder
    district?: SortOrder
    subDistrict?: SortOrder
    postCode?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type addressSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type brandCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    detail?: SortOrder
    imagePath?: SortOrder
    imageSrc?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type brandAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type brandMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    detail?: SortOrder
    imagePath?: SortOrder
    imageSrc?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type brandMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    detail?: SortOrder
    imagePath?: SortOrder
    imageSrc?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type brandSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type Product_tagListRelationFilter = {
    every?: product_tagWhereInput
    some?: product_tagWhereInput
    none?: product_tagWhereInput
  }

  export type product_tagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type tagCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    detail?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type tagAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type tagMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    detail?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type tagMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    detail?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type tagSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type Sub_categoryListRelationFilter = {
    every?: sub_categoryWhereInput
    some?: sub_categoryWhereInput
    none?: sub_categoryWhereInput
  }

  export type sub_categoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type categoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    detail?: SortOrder
    imagePath?: SortOrder
    imageSrc?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type categoryAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type categoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    detail?: SortOrder
    imagePath?: SortOrder
    imageSrc?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type categoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    detail?: SortOrder
    imagePath?: SortOrder
    imageSrc?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type categorySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CategoryRelationFilter = {
    is?: categoryWhereInput
    isNot?: categoryWhereInput
  }

  export type sub_categoryCountOrderByAggregateInput = {
    id?: SortOrder
    categoryId?: SortOrder
    name?: SortOrder
    detail?: SortOrder
    imagePath?: SortOrder
    imageSrc?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type sub_categoryAvgOrderByAggregateInput = {
    id?: SortOrder
    categoryId?: SortOrder
  }

  export type sub_categoryMaxOrderByAggregateInput = {
    id?: SortOrder
    categoryId?: SortOrder
    name?: SortOrder
    detail?: SortOrder
    imagePath?: SortOrder
    imageSrc?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type sub_categoryMinOrderByAggregateInput = {
    id?: SortOrder
    categoryId?: SortOrder
    name?: SortOrder
    detail?: SortOrder
    imagePath?: SortOrder
    imageSrc?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type sub_categorySumOrderByAggregateInput = {
    id?: SortOrder
    categoryId?: SortOrder
  }

  export type ProductRelationFilter = {
    is?: productWhereInput
    isNot?: productWhereInput
  }

  export type AdminRelationFilter = {
    is?: adminWhereInput
    isNot?: adminWhereInput
  }

  export type product_reviewCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
    adminId?: SortOrder
    detail?: SortOrder
    rating?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type product_reviewAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
    adminId?: SortOrder
    rating?: SortOrder
  }

  export type product_reviewMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
    adminId?: SortOrder
    detail?: SortOrder
    rating?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type product_reviewMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
    adminId?: SortOrder
    detail?: SortOrder
    rating?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type product_reviewSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
    adminId?: SortOrder
    rating?: SortOrder
  }

  export type review_imageCountOrderByAggregateInput = {
    id?: SortOrder
    imagePath?: SortOrder
    imageSrc?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type review_imageAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type review_imageMaxOrderByAggregateInput = {
    id?: SortOrder
    imagePath?: SortOrder
    imageSrc?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type review_imageMinOrderByAggregateInput = {
    id?: SortOrder
    imagePath?: SortOrder
    imageSrc?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type review_imageSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BrandRelationFilter = {
    is?: brandWhereInput
    isNot?: brandWhereInput
  }

  export type Product_imageListRelationFilter = {
    every?: product_imageWhereInput
    some?: product_imageWhereInput
    none?: product_imageWhereInput
  }

  export type Product_specListRelationFilter = {
    every?: product_specWhereInput
    some?: product_specWhereInput
    none?: product_specWhereInput
  }

  export type Product_detailListRelationFilter = {
    every?: product_detailWhereInput
    some?: product_detailWhereInput
    none?: product_detailWhereInput
  }

  export type Product_option_firstListRelationFilter = {
    every?: product_option_firstWhereInput
    some?: product_option_firstWhereInput
    none?: product_option_firstWhereInput
  }

  export type Product_option_secondListRelationFilter = {
    every?: product_option_secondWhereInput
    some?: product_option_secondWhereInput
    none?: product_option_secondWhereInput
  }

  export type Product_priceListRelationFilter = {
    every?: product_priceWhereInput
    some?: product_priceWhereInput
    none?: product_priceWhereInput
  }

  export type Product_wholesaleListRelationFilter = {
    every?: product_wholesaleWhereInput
    some?: product_wholesaleWhereInput
    none?: product_wholesaleWhereInput
  }

  export type product_imageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type product_specOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type product_detailOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type product_option_firstOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type product_option_secondOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type product_priceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type product_wholesaleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type productCountOrderByAggregateInput = {
    id?: SortOrder
    brandId?: SortOrder
    adminId?: SortOrder
    name?: SortOrder
    shortName?: SortOrder
    detail?: SortOrder
    isDiscount?: SortOrder
    discountPercent?: SortOrder
    minPrice?: SortOrder
    maxPrice?: SortOrder
    slug?: SortOrder
    cardImgPath?: SortOrder
    cardImgSrc?: SortOrder
    optionFirst?: SortOrder
    optionSecond?: SortOrder
    isWholesale?: SortOrder
    rating?: SortOrder
    sold?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type productAvgOrderByAggregateInput = {
    id?: SortOrder
    brandId?: SortOrder
    adminId?: SortOrder
    discountPercent?: SortOrder
    minPrice?: SortOrder
    maxPrice?: SortOrder
    rating?: SortOrder
    sold?: SortOrder
  }

  export type productMaxOrderByAggregateInput = {
    id?: SortOrder
    brandId?: SortOrder
    adminId?: SortOrder
    name?: SortOrder
    shortName?: SortOrder
    detail?: SortOrder
    isDiscount?: SortOrder
    discountPercent?: SortOrder
    minPrice?: SortOrder
    maxPrice?: SortOrder
    slug?: SortOrder
    cardImgPath?: SortOrder
    cardImgSrc?: SortOrder
    optionFirst?: SortOrder
    optionSecond?: SortOrder
    isWholesale?: SortOrder
    rating?: SortOrder
    sold?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type productMinOrderByAggregateInput = {
    id?: SortOrder
    brandId?: SortOrder
    adminId?: SortOrder
    name?: SortOrder
    shortName?: SortOrder
    detail?: SortOrder
    isDiscount?: SortOrder
    discountPercent?: SortOrder
    minPrice?: SortOrder
    maxPrice?: SortOrder
    slug?: SortOrder
    cardImgPath?: SortOrder
    cardImgSrc?: SortOrder
    optionFirst?: SortOrder
    optionSecond?: SortOrder
    isWholesale?: SortOrder
    rating?: SortOrder
    sold?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type productSumOrderByAggregateInput = {
    id?: SortOrder
    brandId?: SortOrder
    adminId?: SortOrder
    discountPercent?: SortOrder
    minPrice?: SortOrder
    maxPrice?: SortOrder
    rating?: SortOrder
    sold?: SortOrder
  }

  export type TagRelationFilter = {
    is?: tagWhereInput
    isNot?: tagWhereInput
  }

  export type product_tagCountOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    tagId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type product_tagAvgOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    tagId?: SortOrder
  }

  export type product_tagMaxOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    tagId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type product_tagMinOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    tagId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type product_tagSumOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    tagId?: SortOrder
  }

  export type product_wholesaleCountOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    min?: SortOrder
    price?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type product_wholesaleAvgOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    min?: SortOrder
    price?: SortOrder
  }

  export type product_wholesaleMaxOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    min?: SortOrder
    price?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type product_wholesaleMinOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    min?: SortOrder
    price?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type product_wholesaleSumOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    min?: SortOrder
    price?: SortOrder
  }

  export type product_option_firstCountOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type product_option_firstAvgOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
  }

  export type product_option_firstMaxOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type product_option_firstMinOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type product_option_firstSumOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
  }

  export type product_option_secondCountOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type product_option_secondAvgOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
  }

  export type product_option_secondMaxOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type product_option_secondMinOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type product_option_secondSumOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
  }

  export type Product_option_firstNullableRelationFilter = {
    is?: product_option_firstWhereInput | null
    isNot?: product_option_firstWhereInput | null
  }

  export type Product_option_secondNullableRelationFilter = {
    is?: product_option_secondWhereInput | null
    isNot?: product_option_secondWhereInput | null
  }

  export type product_priceCountOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    product_option_firstId?: SortOrder
    product_option_secondId?: SortOrder
    price?: SortOrder
    sku?: SortOrder
    isWholesale?: SortOrder
  }

  export type product_priceAvgOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    product_option_firstId?: SortOrder
    product_option_secondId?: SortOrder
    price?: SortOrder
  }

  export type product_priceMaxOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    product_option_firstId?: SortOrder
    product_option_secondId?: SortOrder
    price?: SortOrder
    sku?: SortOrder
    isWholesale?: SortOrder
  }

  export type product_priceMinOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    product_option_firstId?: SortOrder
    product_option_secondId?: SortOrder
    price?: SortOrder
    sku?: SortOrder
    isWholesale?: SortOrder
  }

  export type product_priceSumOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    product_option_firstId?: SortOrder
    product_option_secondId?: SortOrder
    price?: SortOrder
  }

  export type product_detailCountOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    name?: SortOrder
    details?: SortOrder
    imagePath?: SortOrder
    imageSrc?: SortOrder
    videoPath?: SortOrder
    videoSrc?: SortOrder
    videoType?: SortOrder
    link?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type product_detailAvgOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
  }

  export type product_detailMaxOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    name?: SortOrder
    details?: SortOrder
    imagePath?: SortOrder
    imageSrc?: SortOrder
    videoPath?: SortOrder
    videoSrc?: SortOrder
    videoType?: SortOrder
    link?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type product_detailMinOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    name?: SortOrder
    details?: SortOrder
    imagePath?: SortOrder
    imageSrc?: SortOrder
    videoPath?: SortOrder
    videoSrc?: SortOrder
    videoType?: SortOrder
    link?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type product_detailSumOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
  }

  export type product_imageCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    path?: SortOrder
    src?: SortOrder
    sequence?: SortOrder
    productId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type product_imageAvgOrderByAggregateInput = {
    id?: SortOrder
    sequence?: SortOrder
    productId?: SortOrder
  }

  export type product_imageMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    path?: SortOrder
    src?: SortOrder
    sequence?: SortOrder
    productId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type product_imageMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    path?: SortOrder
    src?: SortOrder
    sequence?: SortOrder
    productId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type product_imageSumOrderByAggregateInput = {
    id?: SortOrder
    sequence?: SortOrder
    productId?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type product_specCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    data?: SortOrder
    productId?: SortOrder
  }

  export type product_specAvgOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
  }

  export type product_specMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    productId?: SortOrder
  }

  export type product_specMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    productId?: SortOrder
  }

  export type product_specSumOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type Product_priceRelationFilter = {
    is?: product_priceWhereInput
    isNot?: product_priceWhereInput
  }

  export type cartCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
    product_priceId?: SortOrder
    qty?: SortOrder
    price?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type cartAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
    product_priceId?: SortOrder
    qty?: SortOrder
    price?: SortOrder
  }

  export type cartMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
    product_priceId?: SortOrder
    qty?: SortOrder
    price?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type cartMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
    product_priceId?: SortOrder
    qty?: SortOrder
    price?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type cartSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
    product_priceId?: SortOrder
    qty?: SortOrder
    price?: SortOrder
  }

  export type AddressRelationFilter = {
    is?: addressWhereInput
    isNot?: addressWhereInput
  }

  export type orderCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    statusNow?: SortOrder
    status?: SortOrder
    paymentType?: SortOrder
    paymentStatus?: SortOrder
    createUsing?: SortOrder
    pointUsing?: SortOrder
    orderPrice?: SortOrder
    deliveryPrice?: SortOrder
    netPrice?: SortOrder
    orderDiscount?: SortOrder
    deliveryDiscount?: SortOrder
    orderDiscountCode?: SortOrder
    deliveryDiscountCode?: SortOrder
    addressId?: SortOrder
    addressData?: SortOrder
    userData?: SortOrder
    isReject?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type orderAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    createUsing?: SortOrder
    pointUsing?: SortOrder
    orderPrice?: SortOrder
    deliveryPrice?: SortOrder
    netPrice?: SortOrder
    orderDiscount?: SortOrder
    deliveryDiscount?: SortOrder
    addressId?: SortOrder
  }

  export type orderMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    statusNow?: SortOrder
    paymentType?: SortOrder
    paymentStatus?: SortOrder
    createUsing?: SortOrder
    pointUsing?: SortOrder
    orderPrice?: SortOrder
    deliveryPrice?: SortOrder
    netPrice?: SortOrder
    orderDiscount?: SortOrder
    deliveryDiscount?: SortOrder
    orderDiscountCode?: SortOrder
    deliveryDiscountCode?: SortOrder
    addressId?: SortOrder
    isReject?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type orderMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    statusNow?: SortOrder
    paymentType?: SortOrder
    paymentStatus?: SortOrder
    createUsing?: SortOrder
    pointUsing?: SortOrder
    orderPrice?: SortOrder
    deliveryPrice?: SortOrder
    netPrice?: SortOrder
    orderDiscount?: SortOrder
    deliveryDiscount?: SortOrder
    orderDiscountCode?: SortOrder
    deliveryDiscountCode?: SortOrder
    addressId?: SortOrder
    isReject?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type orderSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    createUsing?: SortOrder
    pointUsing?: SortOrder
    orderPrice?: SortOrder
    deliveryPrice?: SortOrder
    netPrice?: SortOrder
    orderDiscount?: SortOrder
    deliveryDiscount?: SortOrder
    addressId?: SortOrder
  }

  export type OrderRelationFilter = {
    is?: orderWhereInput
    isNot?: orderWhereInput
  }

  export type order_productCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
    orderId?: SortOrder
    product_priceId?: SortOrder
    qty?: SortOrder
    price?: SortOrder
    productData?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type order_productAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
    orderId?: SortOrder
    product_priceId?: SortOrder
    qty?: SortOrder
    price?: SortOrder
  }

  export type order_productMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
    orderId?: SortOrder
    product_priceId?: SortOrder
    qty?: SortOrder
    price?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type order_productMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
    orderId?: SortOrder
    product_priceId?: SortOrder
    qty?: SortOrder
    price?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type order_productSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
    orderId?: SortOrder
    product_priceId?: SortOrder
    qty?: SortOrder
    price?: SortOrder
  }

  export type settingCountOrderByAggregateInput = {
    id?: SortOrder
    facebook?: SortOrder
    line?: SortOrder
    instagram?: SortOrder
    tiktok?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type settingAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type settingMaxOrderByAggregateInput = {
    id?: SortOrder
    facebook?: SortOrder
    line?: SortOrder
    instagram?: SortOrder
    tiktok?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type settingMinOrderByAggregateInput = {
    id?: SortOrder
    facebook?: SortOrder
    line?: SortOrder
    instagram?: SortOrder
    tiktok?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type settingSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type setting_serviceCountOrderByAggregateInput = {
    id?: SortOrder
    lineNotiToken?: SortOrder
    gmpayToken?: SortOrder
    seo?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type setting_serviceAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type setting_serviceMaxOrderByAggregateInput = {
    id?: SortOrder
    lineNotiToken?: SortOrder
    gmpayToken?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type setting_serviceMinOrderByAggregateInput = {
    id?: SortOrder
    lineNotiToken?: SortOrder
    gmpayToken?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type setting_serviceSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type user_credit_transactionCreateNestedManyWithoutAdminInput = {
    create?: XOR<user_credit_transactionCreateWithoutAdminInput, user_credit_transactionUncheckedCreateWithoutAdminInput> | user_credit_transactionCreateWithoutAdminInput[] | user_credit_transactionUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: user_credit_transactionCreateOrConnectWithoutAdminInput | user_credit_transactionCreateOrConnectWithoutAdminInput[]
    createMany?: user_credit_transactionCreateManyAdminInputEnvelope
    connect?: user_credit_transactionWhereUniqueInput | user_credit_transactionWhereUniqueInput[]
  }

  export type user_point_transactionCreateNestedManyWithoutAdminInput = {
    create?: XOR<user_point_transactionCreateWithoutAdminInput, user_point_transactionUncheckedCreateWithoutAdminInput> | user_point_transactionCreateWithoutAdminInput[] | user_point_transactionUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: user_point_transactionCreateOrConnectWithoutAdminInput | user_point_transactionCreateOrConnectWithoutAdminInput[]
    createMany?: user_point_transactionCreateManyAdminInputEnvelope
    connect?: user_point_transactionWhereUniqueInput | user_point_transactionWhereUniqueInput[]
  }

  export type product_reviewCreateNestedManyWithoutAdminInput = {
    create?: XOR<product_reviewCreateWithoutAdminInput, product_reviewUncheckedCreateWithoutAdminInput> | product_reviewCreateWithoutAdminInput[] | product_reviewUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: product_reviewCreateOrConnectWithoutAdminInput | product_reviewCreateOrConnectWithoutAdminInput[]
    createMany?: product_reviewCreateManyAdminInputEnvelope
    connect?: product_reviewWhereUniqueInput | product_reviewWhereUniqueInput[]
  }

  export type productCreateNestedManyWithoutAdminInput = {
    create?: XOR<productCreateWithoutAdminInput, productUncheckedCreateWithoutAdminInput> | productCreateWithoutAdminInput[] | productUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: productCreateOrConnectWithoutAdminInput | productCreateOrConnectWithoutAdminInput[]
    createMany?: productCreateManyAdminInputEnvelope
    connect?: productWhereUniqueInput | productWhereUniqueInput[]
  }

  export type user_credit_transactionUncheckedCreateNestedManyWithoutAdminInput = {
    create?: XOR<user_credit_transactionCreateWithoutAdminInput, user_credit_transactionUncheckedCreateWithoutAdminInput> | user_credit_transactionCreateWithoutAdminInput[] | user_credit_transactionUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: user_credit_transactionCreateOrConnectWithoutAdminInput | user_credit_transactionCreateOrConnectWithoutAdminInput[]
    createMany?: user_credit_transactionCreateManyAdminInputEnvelope
    connect?: user_credit_transactionWhereUniqueInput | user_credit_transactionWhereUniqueInput[]
  }

  export type user_point_transactionUncheckedCreateNestedManyWithoutAdminInput = {
    create?: XOR<user_point_transactionCreateWithoutAdminInput, user_point_transactionUncheckedCreateWithoutAdminInput> | user_point_transactionCreateWithoutAdminInput[] | user_point_transactionUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: user_point_transactionCreateOrConnectWithoutAdminInput | user_point_transactionCreateOrConnectWithoutAdminInput[]
    createMany?: user_point_transactionCreateManyAdminInputEnvelope
    connect?: user_point_transactionWhereUniqueInput | user_point_transactionWhereUniqueInput[]
  }

  export type product_reviewUncheckedCreateNestedManyWithoutAdminInput = {
    create?: XOR<product_reviewCreateWithoutAdminInput, product_reviewUncheckedCreateWithoutAdminInput> | product_reviewCreateWithoutAdminInput[] | product_reviewUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: product_reviewCreateOrConnectWithoutAdminInput | product_reviewCreateOrConnectWithoutAdminInput[]
    createMany?: product_reviewCreateManyAdminInputEnvelope
    connect?: product_reviewWhereUniqueInput | product_reviewWhereUniqueInput[]
  }

  export type productUncheckedCreateNestedManyWithoutAdminInput = {
    create?: XOR<productCreateWithoutAdminInput, productUncheckedCreateWithoutAdminInput> | productCreateWithoutAdminInput[] | productUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: productCreateOrConnectWithoutAdminInput | productCreateOrConnectWithoutAdminInput[]
    createMany?: productCreateManyAdminInputEnvelope
    connect?: productWhereUniqueInput | productWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type user_credit_transactionUpdateManyWithoutAdminNestedInput = {
    create?: XOR<user_credit_transactionCreateWithoutAdminInput, user_credit_transactionUncheckedCreateWithoutAdminInput> | user_credit_transactionCreateWithoutAdminInput[] | user_credit_transactionUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: user_credit_transactionCreateOrConnectWithoutAdminInput | user_credit_transactionCreateOrConnectWithoutAdminInput[]
    upsert?: user_credit_transactionUpsertWithWhereUniqueWithoutAdminInput | user_credit_transactionUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: user_credit_transactionCreateManyAdminInputEnvelope
    set?: user_credit_transactionWhereUniqueInput | user_credit_transactionWhereUniqueInput[]
    disconnect?: user_credit_transactionWhereUniqueInput | user_credit_transactionWhereUniqueInput[]
    delete?: user_credit_transactionWhereUniqueInput | user_credit_transactionWhereUniqueInput[]
    connect?: user_credit_transactionWhereUniqueInput | user_credit_transactionWhereUniqueInput[]
    update?: user_credit_transactionUpdateWithWhereUniqueWithoutAdminInput | user_credit_transactionUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: user_credit_transactionUpdateManyWithWhereWithoutAdminInput | user_credit_transactionUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: user_credit_transactionScalarWhereInput | user_credit_transactionScalarWhereInput[]
  }

  export type user_point_transactionUpdateManyWithoutAdminNestedInput = {
    create?: XOR<user_point_transactionCreateWithoutAdminInput, user_point_transactionUncheckedCreateWithoutAdminInput> | user_point_transactionCreateWithoutAdminInput[] | user_point_transactionUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: user_point_transactionCreateOrConnectWithoutAdminInput | user_point_transactionCreateOrConnectWithoutAdminInput[]
    upsert?: user_point_transactionUpsertWithWhereUniqueWithoutAdminInput | user_point_transactionUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: user_point_transactionCreateManyAdminInputEnvelope
    set?: user_point_transactionWhereUniqueInput | user_point_transactionWhereUniqueInput[]
    disconnect?: user_point_transactionWhereUniqueInput | user_point_transactionWhereUniqueInput[]
    delete?: user_point_transactionWhereUniqueInput | user_point_transactionWhereUniqueInput[]
    connect?: user_point_transactionWhereUniqueInput | user_point_transactionWhereUniqueInput[]
    update?: user_point_transactionUpdateWithWhereUniqueWithoutAdminInput | user_point_transactionUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: user_point_transactionUpdateManyWithWhereWithoutAdminInput | user_point_transactionUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: user_point_transactionScalarWhereInput | user_point_transactionScalarWhereInput[]
  }

  export type product_reviewUpdateManyWithoutAdminNestedInput = {
    create?: XOR<product_reviewCreateWithoutAdminInput, product_reviewUncheckedCreateWithoutAdminInput> | product_reviewCreateWithoutAdminInput[] | product_reviewUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: product_reviewCreateOrConnectWithoutAdminInput | product_reviewCreateOrConnectWithoutAdminInput[]
    upsert?: product_reviewUpsertWithWhereUniqueWithoutAdminInput | product_reviewUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: product_reviewCreateManyAdminInputEnvelope
    set?: product_reviewWhereUniqueInput | product_reviewWhereUniqueInput[]
    disconnect?: product_reviewWhereUniqueInput | product_reviewWhereUniqueInput[]
    delete?: product_reviewWhereUniqueInput | product_reviewWhereUniqueInput[]
    connect?: product_reviewWhereUniqueInput | product_reviewWhereUniqueInput[]
    update?: product_reviewUpdateWithWhereUniqueWithoutAdminInput | product_reviewUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: product_reviewUpdateManyWithWhereWithoutAdminInput | product_reviewUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: product_reviewScalarWhereInput | product_reviewScalarWhereInput[]
  }

  export type productUpdateManyWithoutAdminNestedInput = {
    create?: XOR<productCreateWithoutAdminInput, productUncheckedCreateWithoutAdminInput> | productCreateWithoutAdminInput[] | productUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: productCreateOrConnectWithoutAdminInput | productCreateOrConnectWithoutAdminInput[]
    upsert?: productUpsertWithWhereUniqueWithoutAdminInput | productUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: productCreateManyAdminInputEnvelope
    set?: productWhereUniqueInput | productWhereUniqueInput[]
    disconnect?: productWhereUniqueInput | productWhereUniqueInput[]
    delete?: productWhereUniqueInput | productWhereUniqueInput[]
    connect?: productWhereUniqueInput | productWhereUniqueInput[]
    update?: productUpdateWithWhereUniqueWithoutAdminInput | productUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: productUpdateManyWithWhereWithoutAdminInput | productUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: productScalarWhereInput | productScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type user_credit_transactionUncheckedUpdateManyWithoutAdminNestedInput = {
    create?: XOR<user_credit_transactionCreateWithoutAdminInput, user_credit_transactionUncheckedCreateWithoutAdminInput> | user_credit_transactionCreateWithoutAdminInput[] | user_credit_transactionUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: user_credit_transactionCreateOrConnectWithoutAdminInput | user_credit_transactionCreateOrConnectWithoutAdminInput[]
    upsert?: user_credit_transactionUpsertWithWhereUniqueWithoutAdminInput | user_credit_transactionUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: user_credit_transactionCreateManyAdminInputEnvelope
    set?: user_credit_transactionWhereUniqueInput | user_credit_transactionWhereUniqueInput[]
    disconnect?: user_credit_transactionWhereUniqueInput | user_credit_transactionWhereUniqueInput[]
    delete?: user_credit_transactionWhereUniqueInput | user_credit_transactionWhereUniqueInput[]
    connect?: user_credit_transactionWhereUniqueInput | user_credit_transactionWhereUniqueInput[]
    update?: user_credit_transactionUpdateWithWhereUniqueWithoutAdminInput | user_credit_transactionUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: user_credit_transactionUpdateManyWithWhereWithoutAdminInput | user_credit_transactionUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: user_credit_transactionScalarWhereInput | user_credit_transactionScalarWhereInput[]
  }

  export type user_point_transactionUncheckedUpdateManyWithoutAdminNestedInput = {
    create?: XOR<user_point_transactionCreateWithoutAdminInput, user_point_transactionUncheckedCreateWithoutAdminInput> | user_point_transactionCreateWithoutAdminInput[] | user_point_transactionUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: user_point_transactionCreateOrConnectWithoutAdminInput | user_point_transactionCreateOrConnectWithoutAdminInput[]
    upsert?: user_point_transactionUpsertWithWhereUniqueWithoutAdminInput | user_point_transactionUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: user_point_transactionCreateManyAdminInputEnvelope
    set?: user_point_transactionWhereUniqueInput | user_point_transactionWhereUniqueInput[]
    disconnect?: user_point_transactionWhereUniqueInput | user_point_transactionWhereUniqueInput[]
    delete?: user_point_transactionWhereUniqueInput | user_point_transactionWhereUniqueInput[]
    connect?: user_point_transactionWhereUniqueInput | user_point_transactionWhereUniqueInput[]
    update?: user_point_transactionUpdateWithWhereUniqueWithoutAdminInput | user_point_transactionUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: user_point_transactionUpdateManyWithWhereWithoutAdminInput | user_point_transactionUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: user_point_transactionScalarWhereInput | user_point_transactionScalarWhereInput[]
  }

  export type product_reviewUncheckedUpdateManyWithoutAdminNestedInput = {
    create?: XOR<product_reviewCreateWithoutAdminInput, product_reviewUncheckedCreateWithoutAdminInput> | product_reviewCreateWithoutAdminInput[] | product_reviewUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: product_reviewCreateOrConnectWithoutAdminInput | product_reviewCreateOrConnectWithoutAdminInput[]
    upsert?: product_reviewUpsertWithWhereUniqueWithoutAdminInput | product_reviewUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: product_reviewCreateManyAdminInputEnvelope
    set?: product_reviewWhereUniqueInput | product_reviewWhereUniqueInput[]
    disconnect?: product_reviewWhereUniqueInput | product_reviewWhereUniqueInput[]
    delete?: product_reviewWhereUniqueInput | product_reviewWhereUniqueInput[]
    connect?: product_reviewWhereUniqueInput | product_reviewWhereUniqueInput[]
    update?: product_reviewUpdateWithWhereUniqueWithoutAdminInput | product_reviewUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: product_reviewUpdateManyWithWhereWithoutAdminInput | product_reviewUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: product_reviewScalarWhereInput | product_reviewScalarWhereInput[]
  }

  export type productUncheckedUpdateManyWithoutAdminNestedInput = {
    create?: XOR<productCreateWithoutAdminInput, productUncheckedCreateWithoutAdminInput> | productCreateWithoutAdminInput[] | productUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: productCreateOrConnectWithoutAdminInput | productCreateOrConnectWithoutAdminInput[]
    upsert?: productUpsertWithWhereUniqueWithoutAdminInput | productUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: productCreateManyAdminInputEnvelope
    set?: productWhereUniqueInput | productWhereUniqueInput[]
    disconnect?: productWhereUniqueInput | productWhereUniqueInput[]
    delete?: productWhereUniqueInput | productWhereUniqueInput[]
    connect?: productWhereUniqueInput | productWhereUniqueInput[]
    update?: productUpdateWithWhereUniqueWithoutAdminInput | productUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: productUpdateManyWithWhereWithoutAdminInput | productUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: productScalarWhereInput | productScalarWhereInput[]
  }

  export type addressCreateNestedManyWithoutUserInput = {
    create?: XOR<addressCreateWithoutUserInput, addressUncheckedCreateWithoutUserInput> | addressCreateWithoutUserInput[] | addressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: addressCreateOrConnectWithoutUserInput | addressCreateOrConnectWithoutUserInput[]
    createMany?: addressCreateManyUserInputEnvelope
    connect?: addressWhereUniqueInput | addressWhereUniqueInput[]
  }

  export type user_credit_transactionCreateNestedManyWithoutUserInput = {
    create?: XOR<user_credit_transactionCreateWithoutUserInput, user_credit_transactionUncheckedCreateWithoutUserInput> | user_credit_transactionCreateWithoutUserInput[] | user_credit_transactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: user_credit_transactionCreateOrConnectWithoutUserInput | user_credit_transactionCreateOrConnectWithoutUserInput[]
    createMany?: user_credit_transactionCreateManyUserInputEnvelope
    connect?: user_credit_transactionWhereUniqueInput | user_credit_transactionWhereUniqueInput[]
  }

  export type payment_transactionCreateNestedManyWithoutUserInput = {
    create?: XOR<payment_transactionCreateWithoutUserInput, payment_transactionUncheckedCreateWithoutUserInput> | payment_transactionCreateWithoutUserInput[] | payment_transactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: payment_transactionCreateOrConnectWithoutUserInput | payment_transactionCreateOrConnectWithoutUserInput[]
    createMany?: payment_transactionCreateManyUserInputEnvelope
    connect?: payment_transactionWhereUniqueInput | payment_transactionWhereUniqueInput[]
  }

  export type user_point_transactionCreateNestedManyWithoutUserInput = {
    create?: XOR<user_point_transactionCreateWithoutUserInput, user_point_transactionUncheckedCreateWithoutUserInput> | user_point_transactionCreateWithoutUserInput[] | user_point_transactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: user_point_transactionCreateOrConnectWithoutUserInput | user_point_transactionCreateOrConnectWithoutUserInput[]
    createMany?: user_point_transactionCreateManyUserInputEnvelope
    connect?: user_point_transactionWhereUniqueInput | user_point_transactionWhereUniqueInput[]
  }

  export type product_reviewCreateNestedManyWithoutUserInput = {
    create?: XOR<product_reviewCreateWithoutUserInput, product_reviewUncheckedCreateWithoutUserInput> | product_reviewCreateWithoutUserInput[] | product_reviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: product_reviewCreateOrConnectWithoutUserInput | product_reviewCreateOrConnectWithoutUserInput[]
    createMany?: product_reviewCreateManyUserInputEnvelope
    connect?: product_reviewWhereUniqueInput | product_reviewWhereUniqueInput[]
  }

  export type cartCreateNestedManyWithoutUserInput = {
    create?: XOR<cartCreateWithoutUserInput, cartUncheckedCreateWithoutUserInput> | cartCreateWithoutUserInput[] | cartUncheckedCreateWithoutUserInput[]
    connectOrCreate?: cartCreateOrConnectWithoutUserInput | cartCreateOrConnectWithoutUserInput[]
    createMany?: cartCreateManyUserInputEnvelope
    connect?: cartWhereUniqueInput | cartWhereUniqueInput[]
  }

  export type orderCreateNestedManyWithoutUserInput = {
    create?: XOR<orderCreateWithoutUserInput, orderUncheckedCreateWithoutUserInput> | orderCreateWithoutUserInput[] | orderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: orderCreateOrConnectWithoutUserInput | orderCreateOrConnectWithoutUserInput[]
    createMany?: orderCreateManyUserInputEnvelope
    connect?: orderWhereUniqueInput | orderWhereUniqueInput[]
  }

  export type order_productCreateNestedManyWithoutUserInput = {
    create?: XOR<order_productCreateWithoutUserInput, order_productUncheckedCreateWithoutUserInput> | order_productCreateWithoutUserInput[] | order_productUncheckedCreateWithoutUserInput[]
    connectOrCreate?: order_productCreateOrConnectWithoutUserInput | order_productCreateOrConnectWithoutUserInput[]
    createMany?: order_productCreateManyUserInputEnvelope
    connect?: order_productWhereUniqueInput | order_productWhereUniqueInput[]
  }

  export type addressUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<addressCreateWithoutUserInput, addressUncheckedCreateWithoutUserInput> | addressCreateWithoutUserInput[] | addressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: addressCreateOrConnectWithoutUserInput | addressCreateOrConnectWithoutUserInput[]
    createMany?: addressCreateManyUserInputEnvelope
    connect?: addressWhereUniqueInput | addressWhereUniqueInput[]
  }

  export type user_credit_transactionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<user_credit_transactionCreateWithoutUserInput, user_credit_transactionUncheckedCreateWithoutUserInput> | user_credit_transactionCreateWithoutUserInput[] | user_credit_transactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: user_credit_transactionCreateOrConnectWithoutUserInput | user_credit_transactionCreateOrConnectWithoutUserInput[]
    createMany?: user_credit_transactionCreateManyUserInputEnvelope
    connect?: user_credit_transactionWhereUniqueInput | user_credit_transactionWhereUniqueInput[]
  }

  export type payment_transactionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<payment_transactionCreateWithoutUserInput, payment_transactionUncheckedCreateWithoutUserInput> | payment_transactionCreateWithoutUserInput[] | payment_transactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: payment_transactionCreateOrConnectWithoutUserInput | payment_transactionCreateOrConnectWithoutUserInput[]
    createMany?: payment_transactionCreateManyUserInputEnvelope
    connect?: payment_transactionWhereUniqueInput | payment_transactionWhereUniqueInput[]
  }

  export type user_point_transactionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<user_point_transactionCreateWithoutUserInput, user_point_transactionUncheckedCreateWithoutUserInput> | user_point_transactionCreateWithoutUserInput[] | user_point_transactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: user_point_transactionCreateOrConnectWithoutUserInput | user_point_transactionCreateOrConnectWithoutUserInput[]
    createMany?: user_point_transactionCreateManyUserInputEnvelope
    connect?: user_point_transactionWhereUniqueInput | user_point_transactionWhereUniqueInput[]
  }

  export type product_reviewUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<product_reviewCreateWithoutUserInput, product_reviewUncheckedCreateWithoutUserInput> | product_reviewCreateWithoutUserInput[] | product_reviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: product_reviewCreateOrConnectWithoutUserInput | product_reviewCreateOrConnectWithoutUserInput[]
    createMany?: product_reviewCreateManyUserInputEnvelope
    connect?: product_reviewWhereUniqueInput | product_reviewWhereUniqueInput[]
  }

  export type cartUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<cartCreateWithoutUserInput, cartUncheckedCreateWithoutUserInput> | cartCreateWithoutUserInput[] | cartUncheckedCreateWithoutUserInput[]
    connectOrCreate?: cartCreateOrConnectWithoutUserInput | cartCreateOrConnectWithoutUserInput[]
    createMany?: cartCreateManyUserInputEnvelope
    connect?: cartWhereUniqueInput | cartWhereUniqueInput[]
  }

  export type orderUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<orderCreateWithoutUserInput, orderUncheckedCreateWithoutUserInput> | orderCreateWithoutUserInput[] | orderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: orderCreateOrConnectWithoutUserInput | orderCreateOrConnectWithoutUserInput[]
    createMany?: orderCreateManyUserInputEnvelope
    connect?: orderWhereUniqueInput | orderWhereUniqueInput[]
  }

  export type order_productUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<order_productCreateWithoutUserInput, order_productUncheckedCreateWithoutUserInput> | order_productCreateWithoutUserInput[] | order_productUncheckedCreateWithoutUserInput[]
    connectOrCreate?: order_productCreateOrConnectWithoutUserInput | order_productCreateOrConnectWithoutUserInput[]
    createMany?: order_productCreateManyUserInputEnvelope
    connect?: order_productWhereUniqueInput | order_productWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type addressUpdateManyWithoutUserNestedInput = {
    create?: XOR<addressCreateWithoutUserInput, addressUncheckedCreateWithoutUserInput> | addressCreateWithoutUserInput[] | addressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: addressCreateOrConnectWithoutUserInput | addressCreateOrConnectWithoutUserInput[]
    upsert?: addressUpsertWithWhereUniqueWithoutUserInput | addressUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: addressCreateManyUserInputEnvelope
    set?: addressWhereUniqueInput | addressWhereUniqueInput[]
    disconnect?: addressWhereUniqueInput | addressWhereUniqueInput[]
    delete?: addressWhereUniqueInput | addressWhereUniqueInput[]
    connect?: addressWhereUniqueInput | addressWhereUniqueInput[]
    update?: addressUpdateWithWhereUniqueWithoutUserInput | addressUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: addressUpdateManyWithWhereWithoutUserInput | addressUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: addressScalarWhereInput | addressScalarWhereInput[]
  }

  export type user_credit_transactionUpdateManyWithoutUserNestedInput = {
    create?: XOR<user_credit_transactionCreateWithoutUserInput, user_credit_transactionUncheckedCreateWithoutUserInput> | user_credit_transactionCreateWithoutUserInput[] | user_credit_transactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: user_credit_transactionCreateOrConnectWithoutUserInput | user_credit_transactionCreateOrConnectWithoutUserInput[]
    upsert?: user_credit_transactionUpsertWithWhereUniqueWithoutUserInput | user_credit_transactionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: user_credit_transactionCreateManyUserInputEnvelope
    set?: user_credit_transactionWhereUniqueInput | user_credit_transactionWhereUniqueInput[]
    disconnect?: user_credit_transactionWhereUniqueInput | user_credit_transactionWhereUniqueInput[]
    delete?: user_credit_transactionWhereUniqueInput | user_credit_transactionWhereUniqueInput[]
    connect?: user_credit_transactionWhereUniqueInput | user_credit_transactionWhereUniqueInput[]
    update?: user_credit_transactionUpdateWithWhereUniqueWithoutUserInput | user_credit_transactionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: user_credit_transactionUpdateManyWithWhereWithoutUserInput | user_credit_transactionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: user_credit_transactionScalarWhereInput | user_credit_transactionScalarWhereInput[]
  }

  export type payment_transactionUpdateManyWithoutUserNestedInput = {
    create?: XOR<payment_transactionCreateWithoutUserInput, payment_transactionUncheckedCreateWithoutUserInput> | payment_transactionCreateWithoutUserInput[] | payment_transactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: payment_transactionCreateOrConnectWithoutUserInput | payment_transactionCreateOrConnectWithoutUserInput[]
    upsert?: payment_transactionUpsertWithWhereUniqueWithoutUserInput | payment_transactionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: payment_transactionCreateManyUserInputEnvelope
    set?: payment_transactionWhereUniqueInput | payment_transactionWhereUniqueInput[]
    disconnect?: payment_transactionWhereUniqueInput | payment_transactionWhereUniqueInput[]
    delete?: payment_transactionWhereUniqueInput | payment_transactionWhereUniqueInput[]
    connect?: payment_transactionWhereUniqueInput | payment_transactionWhereUniqueInput[]
    update?: payment_transactionUpdateWithWhereUniqueWithoutUserInput | payment_transactionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: payment_transactionUpdateManyWithWhereWithoutUserInput | payment_transactionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: payment_transactionScalarWhereInput | payment_transactionScalarWhereInput[]
  }

  export type user_point_transactionUpdateManyWithoutUserNestedInput = {
    create?: XOR<user_point_transactionCreateWithoutUserInput, user_point_transactionUncheckedCreateWithoutUserInput> | user_point_transactionCreateWithoutUserInput[] | user_point_transactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: user_point_transactionCreateOrConnectWithoutUserInput | user_point_transactionCreateOrConnectWithoutUserInput[]
    upsert?: user_point_transactionUpsertWithWhereUniqueWithoutUserInput | user_point_transactionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: user_point_transactionCreateManyUserInputEnvelope
    set?: user_point_transactionWhereUniqueInput | user_point_transactionWhereUniqueInput[]
    disconnect?: user_point_transactionWhereUniqueInput | user_point_transactionWhereUniqueInput[]
    delete?: user_point_transactionWhereUniqueInput | user_point_transactionWhereUniqueInput[]
    connect?: user_point_transactionWhereUniqueInput | user_point_transactionWhereUniqueInput[]
    update?: user_point_transactionUpdateWithWhereUniqueWithoutUserInput | user_point_transactionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: user_point_transactionUpdateManyWithWhereWithoutUserInput | user_point_transactionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: user_point_transactionScalarWhereInput | user_point_transactionScalarWhereInput[]
  }

  export type product_reviewUpdateManyWithoutUserNestedInput = {
    create?: XOR<product_reviewCreateWithoutUserInput, product_reviewUncheckedCreateWithoutUserInput> | product_reviewCreateWithoutUserInput[] | product_reviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: product_reviewCreateOrConnectWithoutUserInput | product_reviewCreateOrConnectWithoutUserInput[]
    upsert?: product_reviewUpsertWithWhereUniqueWithoutUserInput | product_reviewUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: product_reviewCreateManyUserInputEnvelope
    set?: product_reviewWhereUniqueInput | product_reviewWhereUniqueInput[]
    disconnect?: product_reviewWhereUniqueInput | product_reviewWhereUniqueInput[]
    delete?: product_reviewWhereUniqueInput | product_reviewWhereUniqueInput[]
    connect?: product_reviewWhereUniqueInput | product_reviewWhereUniqueInput[]
    update?: product_reviewUpdateWithWhereUniqueWithoutUserInput | product_reviewUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: product_reviewUpdateManyWithWhereWithoutUserInput | product_reviewUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: product_reviewScalarWhereInput | product_reviewScalarWhereInput[]
  }

  export type cartUpdateManyWithoutUserNestedInput = {
    create?: XOR<cartCreateWithoutUserInput, cartUncheckedCreateWithoutUserInput> | cartCreateWithoutUserInput[] | cartUncheckedCreateWithoutUserInput[]
    connectOrCreate?: cartCreateOrConnectWithoutUserInput | cartCreateOrConnectWithoutUserInput[]
    upsert?: cartUpsertWithWhereUniqueWithoutUserInput | cartUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: cartCreateManyUserInputEnvelope
    set?: cartWhereUniqueInput | cartWhereUniqueInput[]
    disconnect?: cartWhereUniqueInput | cartWhereUniqueInput[]
    delete?: cartWhereUniqueInput | cartWhereUniqueInput[]
    connect?: cartWhereUniqueInput | cartWhereUniqueInput[]
    update?: cartUpdateWithWhereUniqueWithoutUserInput | cartUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: cartUpdateManyWithWhereWithoutUserInput | cartUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: cartScalarWhereInput | cartScalarWhereInput[]
  }

  export type orderUpdateManyWithoutUserNestedInput = {
    create?: XOR<orderCreateWithoutUserInput, orderUncheckedCreateWithoutUserInput> | orderCreateWithoutUserInput[] | orderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: orderCreateOrConnectWithoutUserInput | orderCreateOrConnectWithoutUserInput[]
    upsert?: orderUpsertWithWhereUniqueWithoutUserInput | orderUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: orderCreateManyUserInputEnvelope
    set?: orderWhereUniqueInput | orderWhereUniqueInput[]
    disconnect?: orderWhereUniqueInput | orderWhereUniqueInput[]
    delete?: orderWhereUniqueInput | orderWhereUniqueInput[]
    connect?: orderWhereUniqueInput | orderWhereUniqueInput[]
    update?: orderUpdateWithWhereUniqueWithoutUserInput | orderUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: orderUpdateManyWithWhereWithoutUserInput | orderUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: orderScalarWhereInput | orderScalarWhereInput[]
  }

  export type order_productUpdateManyWithoutUserNestedInput = {
    create?: XOR<order_productCreateWithoutUserInput, order_productUncheckedCreateWithoutUserInput> | order_productCreateWithoutUserInput[] | order_productUncheckedCreateWithoutUserInput[]
    connectOrCreate?: order_productCreateOrConnectWithoutUserInput | order_productCreateOrConnectWithoutUserInput[]
    upsert?: order_productUpsertWithWhereUniqueWithoutUserInput | order_productUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: order_productCreateManyUserInputEnvelope
    set?: order_productWhereUniqueInput | order_productWhereUniqueInput[]
    disconnect?: order_productWhereUniqueInput | order_productWhereUniqueInput[]
    delete?: order_productWhereUniqueInput | order_productWhereUniqueInput[]
    connect?: order_productWhereUniqueInput | order_productWhereUniqueInput[]
    update?: order_productUpdateWithWhereUniqueWithoutUserInput | order_productUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: order_productUpdateManyWithWhereWithoutUserInput | order_productUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: order_productScalarWhereInput | order_productScalarWhereInput[]
  }

  export type addressUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<addressCreateWithoutUserInput, addressUncheckedCreateWithoutUserInput> | addressCreateWithoutUserInput[] | addressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: addressCreateOrConnectWithoutUserInput | addressCreateOrConnectWithoutUserInput[]
    upsert?: addressUpsertWithWhereUniqueWithoutUserInput | addressUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: addressCreateManyUserInputEnvelope
    set?: addressWhereUniqueInput | addressWhereUniqueInput[]
    disconnect?: addressWhereUniqueInput | addressWhereUniqueInput[]
    delete?: addressWhereUniqueInput | addressWhereUniqueInput[]
    connect?: addressWhereUniqueInput | addressWhereUniqueInput[]
    update?: addressUpdateWithWhereUniqueWithoutUserInput | addressUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: addressUpdateManyWithWhereWithoutUserInput | addressUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: addressScalarWhereInput | addressScalarWhereInput[]
  }

  export type user_credit_transactionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<user_credit_transactionCreateWithoutUserInput, user_credit_transactionUncheckedCreateWithoutUserInput> | user_credit_transactionCreateWithoutUserInput[] | user_credit_transactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: user_credit_transactionCreateOrConnectWithoutUserInput | user_credit_transactionCreateOrConnectWithoutUserInput[]
    upsert?: user_credit_transactionUpsertWithWhereUniqueWithoutUserInput | user_credit_transactionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: user_credit_transactionCreateManyUserInputEnvelope
    set?: user_credit_transactionWhereUniqueInput | user_credit_transactionWhereUniqueInput[]
    disconnect?: user_credit_transactionWhereUniqueInput | user_credit_transactionWhereUniqueInput[]
    delete?: user_credit_transactionWhereUniqueInput | user_credit_transactionWhereUniqueInput[]
    connect?: user_credit_transactionWhereUniqueInput | user_credit_transactionWhereUniqueInput[]
    update?: user_credit_transactionUpdateWithWhereUniqueWithoutUserInput | user_credit_transactionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: user_credit_transactionUpdateManyWithWhereWithoutUserInput | user_credit_transactionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: user_credit_transactionScalarWhereInput | user_credit_transactionScalarWhereInput[]
  }

  export type payment_transactionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<payment_transactionCreateWithoutUserInput, payment_transactionUncheckedCreateWithoutUserInput> | payment_transactionCreateWithoutUserInput[] | payment_transactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: payment_transactionCreateOrConnectWithoutUserInput | payment_transactionCreateOrConnectWithoutUserInput[]
    upsert?: payment_transactionUpsertWithWhereUniqueWithoutUserInput | payment_transactionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: payment_transactionCreateManyUserInputEnvelope
    set?: payment_transactionWhereUniqueInput | payment_transactionWhereUniqueInput[]
    disconnect?: payment_transactionWhereUniqueInput | payment_transactionWhereUniqueInput[]
    delete?: payment_transactionWhereUniqueInput | payment_transactionWhereUniqueInput[]
    connect?: payment_transactionWhereUniqueInput | payment_transactionWhereUniqueInput[]
    update?: payment_transactionUpdateWithWhereUniqueWithoutUserInput | payment_transactionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: payment_transactionUpdateManyWithWhereWithoutUserInput | payment_transactionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: payment_transactionScalarWhereInput | payment_transactionScalarWhereInput[]
  }

  export type user_point_transactionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<user_point_transactionCreateWithoutUserInput, user_point_transactionUncheckedCreateWithoutUserInput> | user_point_transactionCreateWithoutUserInput[] | user_point_transactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: user_point_transactionCreateOrConnectWithoutUserInput | user_point_transactionCreateOrConnectWithoutUserInput[]
    upsert?: user_point_transactionUpsertWithWhereUniqueWithoutUserInput | user_point_transactionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: user_point_transactionCreateManyUserInputEnvelope
    set?: user_point_transactionWhereUniqueInput | user_point_transactionWhereUniqueInput[]
    disconnect?: user_point_transactionWhereUniqueInput | user_point_transactionWhereUniqueInput[]
    delete?: user_point_transactionWhereUniqueInput | user_point_transactionWhereUniqueInput[]
    connect?: user_point_transactionWhereUniqueInput | user_point_transactionWhereUniqueInput[]
    update?: user_point_transactionUpdateWithWhereUniqueWithoutUserInput | user_point_transactionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: user_point_transactionUpdateManyWithWhereWithoutUserInput | user_point_transactionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: user_point_transactionScalarWhereInput | user_point_transactionScalarWhereInput[]
  }

  export type product_reviewUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<product_reviewCreateWithoutUserInput, product_reviewUncheckedCreateWithoutUserInput> | product_reviewCreateWithoutUserInput[] | product_reviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: product_reviewCreateOrConnectWithoutUserInput | product_reviewCreateOrConnectWithoutUserInput[]
    upsert?: product_reviewUpsertWithWhereUniqueWithoutUserInput | product_reviewUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: product_reviewCreateManyUserInputEnvelope
    set?: product_reviewWhereUniqueInput | product_reviewWhereUniqueInput[]
    disconnect?: product_reviewWhereUniqueInput | product_reviewWhereUniqueInput[]
    delete?: product_reviewWhereUniqueInput | product_reviewWhereUniqueInput[]
    connect?: product_reviewWhereUniqueInput | product_reviewWhereUniqueInput[]
    update?: product_reviewUpdateWithWhereUniqueWithoutUserInput | product_reviewUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: product_reviewUpdateManyWithWhereWithoutUserInput | product_reviewUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: product_reviewScalarWhereInput | product_reviewScalarWhereInput[]
  }

  export type cartUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<cartCreateWithoutUserInput, cartUncheckedCreateWithoutUserInput> | cartCreateWithoutUserInput[] | cartUncheckedCreateWithoutUserInput[]
    connectOrCreate?: cartCreateOrConnectWithoutUserInput | cartCreateOrConnectWithoutUserInput[]
    upsert?: cartUpsertWithWhereUniqueWithoutUserInput | cartUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: cartCreateManyUserInputEnvelope
    set?: cartWhereUniqueInput | cartWhereUniqueInput[]
    disconnect?: cartWhereUniqueInput | cartWhereUniqueInput[]
    delete?: cartWhereUniqueInput | cartWhereUniqueInput[]
    connect?: cartWhereUniqueInput | cartWhereUniqueInput[]
    update?: cartUpdateWithWhereUniqueWithoutUserInput | cartUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: cartUpdateManyWithWhereWithoutUserInput | cartUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: cartScalarWhereInput | cartScalarWhereInput[]
  }

  export type orderUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<orderCreateWithoutUserInput, orderUncheckedCreateWithoutUserInput> | orderCreateWithoutUserInput[] | orderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: orderCreateOrConnectWithoutUserInput | orderCreateOrConnectWithoutUserInput[]
    upsert?: orderUpsertWithWhereUniqueWithoutUserInput | orderUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: orderCreateManyUserInputEnvelope
    set?: orderWhereUniqueInput | orderWhereUniqueInput[]
    disconnect?: orderWhereUniqueInput | orderWhereUniqueInput[]
    delete?: orderWhereUniqueInput | orderWhereUniqueInput[]
    connect?: orderWhereUniqueInput | orderWhereUniqueInput[]
    update?: orderUpdateWithWhereUniqueWithoutUserInput | orderUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: orderUpdateManyWithWhereWithoutUserInput | orderUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: orderScalarWhereInput | orderScalarWhereInput[]
  }

  export type order_productUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<order_productCreateWithoutUserInput, order_productUncheckedCreateWithoutUserInput> | order_productCreateWithoutUserInput[] | order_productUncheckedCreateWithoutUserInput[]
    connectOrCreate?: order_productCreateOrConnectWithoutUserInput | order_productCreateOrConnectWithoutUserInput[]
    upsert?: order_productUpsertWithWhereUniqueWithoutUserInput | order_productUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: order_productCreateManyUserInputEnvelope
    set?: order_productWhereUniqueInput | order_productWhereUniqueInput[]
    disconnect?: order_productWhereUniqueInput | order_productWhereUniqueInput[]
    delete?: order_productWhereUniqueInput | order_productWhereUniqueInput[]
    connect?: order_productWhereUniqueInput | order_productWhereUniqueInput[]
    update?: order_productUpdateWithWhereUniqueWithoutUserInput | order_productUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: order_productUpdateManyWithWhereWithoutUserInput | order_productUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: order_productScalarWhereInput | order_productScalarWhereInput[]
  }

  export type userCreateNestedOneWithoutUser_credit_transactionInput = {
    create?: XOR<userCreateWithoutUser_credit_transactionInput, userUncheckedCreateWithoutUser_credit_transactionInput>
    connectOrCreate?: userCreateOrConnectWithoutUser_credit_transactionInput
    connect?: userWhereUniqueInput
  }

  export type adminCreateNestedOneWithoutUser_credit_transactionInput = {
    create?: XOR<adminCreateWithoutUser_credit_transactionInput, adminUncheckedCreateWithoutUser_credit_transactionInput>
    connectOrCreate?: adminCreateOrConnectWithoutUser_credit_transactionInput
    connect?: adminWhereUniqueInput
  }

  export type userUpdateOneRequiredWithoutUser_credit_transactionNestedInput = {
    create?: XOR<userCreateWithoutUser_credit_transactionInput, userUncheckedCreateWithoutUser_credit_transactionInput>
    connectOrCreate?: userCreateOrConnectWithoutUser_credit_transactionInput
    upsert?: userUpsertWithoutUser_credit_transactionInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutUser_credit_transactionInput, userUpdateWithoutUser_credit_transactionInput>, userUncheckedUpdateWithoutUser_credit_transactionInput>
  }

  export type adminUpdateOneWithoutUser_credit_transactionNestedInput = {
    create?: XOR<adminCreateWithoutUser_credit_transactionInput, adminUncheckedCreateWithoutUser_credit_transactionInput>
    connectOrCreate?: adminCreateOrConnectWithoutUser_credit_transactionInput
    upsert?: adminUpsertWithoutUser_credit_transactionInput
    disconnect?: adminWhereInput | boolean
    delete?: adminWhereInput | boolean
    connect?: adminWhereUniqueInput
    update?: XOR<XOR<adminUpdateToOneWithWhereWithoutUser_credit_transactionInput, adminUpdateWithoutUser_credit_transactionInput>, adminUncheckedUpdateWithoutUser_credit_transactionInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type userCreateNestedOneWithoutUser_point_transactionInput = {
    create?: XOR<userCreateWithoutUser_point_transactionInput, userUncheckedCreateWithoutUser_point_transactionInput>
    connectOrCreate?: userCreateOrConnectWithoutUser_point_transactionInput
    connect?: userWhereUniqueInput
  }

  export type adminCreateNestedOneWithoutUser_point_transactionInput = {
    create?: XOR<adminCreateWithoutUser_point_transactionInput, adminUncheckedCreateWithoutUser_point_transactionInput>
    connectOrCreate?: adminCreateOrConnectWithoutUser_point_transactionInput
    connect?: adminWhereUniqueInput
  }

  export type userUpdateOneRequiredWithoutUser_point_transactionNestedInput = {
    create?: XOR<userCreateWithoutUser_point_transactionInput, userUncheckedCreateWithoutUser_point_transactionInput>
    connectOrCreate?: userCreateOrConnectWithoutUser_point_transactionInput
    upsert?: userUpsertWithoutUser_point_transactionInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutUser_point_transactionInput, userUpdateWithoutUser_point_transactionInput>, userUncheckedUpdateWithoutUser_point_transactionInput>
  }

  export type adminUpdateOneWithoutUser_point_transactionNestedInput = {
    create?: XOR<adminCreateWithoutUser_point_transactionInput, adminUncheckedCreateWithoutUser_point_transactionInput>
    connectOrCreate?: adminCreateOrConnectWithoutUser_point_transactionInput
    upsert?: adminUpsertWithoutUser_point_transactionInput
    disconnect?: adminWhereInput | boolean
    delete?: adminWhereInput | boolean
    connect?: adminWhereUniqueInput
    update?: XOR<XOR<adminUpdateToOneWithWhereWithoutUser_point_transactionInput, adminUpdateWithoutUser_point_transactionInput>, adminUncheckedUpdateWithoutUser_point_transactionInput>
  }

  export type userCreateNestedOneWithoutPayment_transactionInput = {
    create?: XOR<userCreateWithoutPayment_transactionInput, userUncheckedCreateWithoutPayment_transactionInput>
    connectOrCreate?: userCreateOrConnectWithoutPayment_transactionInput
    connect?: userWhereUniqueInput
  }

  export type userUpdateOneRequiredWithoutPayment_transactionNestedInput = {
    create?: XOR<userCreateWithoutPayment_transactionInput, userUncheckedCreateWithoutPayment_transactionInput>
    connectOrCreate?: userCreateOrConnectWithoutPayment_transactionInput
    upsert?: userUpsertWithoutPayment_transactionInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutPayment_transactionInput, userUpdateWithoutPayment_transactionInput>, userUncheckedUpdateWithoutPayment_transactionInput>
  }

  export type userCreateNestedOneWithoutAddressInput = {
    create?: XOR<userCreateWithoutAddressInput, userUncheckedCreateWithoutAddressInput>
    connectOrCreate?: userCreateOrConnectWithoutAddressInput
    connect?: userWhereUniqueInput
  }

  export type orderCreateNestedManyWithoutAddressInput = {
    create?: XOR<orderCreateWithoutAddressInput, orderUncheckedCreateWithoutAddressInput> | orderCreateWithoutAddressInput[] | orderUncheckedCreateWithoutAddressInput[]
    connectOrCreate?: orderCreateOrConnectWithoutAddressInput | orderCreateOrConnectWithoutAddressInput[]
    createMany?: orderCreateManyAddressInputEnvelope
    connect?: orderWhereUniqueInput | orderWhereUniqueInput[]
  }

  export type orderUncheckedCreateNestedManyWithoutAddressInput = {
    create?: XOR<orderCreateWithoutAddressInput, orderUncheckedCreateWithoutAddressInput> | orderCreateWithoutAddressInput[] | orderUncheckedCreateWithoutAddressInput[]
    connectOrCreate?: orderCreateOrConnectWithoutAddressInput | orderCreateOrConnectWithoutAddressInput[]
    createMany?: orderCreateManyAddressInputEnvelope
    connect?: orderWhereUniqueInput | orderWhereUniqueInput[]
  }

  export type userUpdateOneRequiredWithoutAddressNestedInput = {
    create?: XOR<userCreateWithoutAddressInput, userUncheckedCreateWithoutAddressInput>
    connectOrCreate?: userCreateOrConnectWithoutAddressInput
    upsert?: userUpsertWithoutAddressInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutAddressInput, userUpdateWithoutAddressInput>, userUncheckedUpdateWithoutAddressInput>
  }

  export type orderUpdateManyWithoutAddressNestedInput = {
    create?: XOR<orderCreateWithoutAddressInput, orderUncheckedCreateWithoutAddressInput> | orderCreateWithoutAddressInput[] | orderUncheckedCreateWithoutAddressInput[]
    connectOrCreate?: orderCreateOrConnectWithoutAddressInput | orderCreateOrConnectWithoutAddressInput[]
    upsert?: orderUpsertWithWhereUniqueWithoutAddressInput | orderUpsertWithWhereUniqueWithoutAddressInput[]
    createMany?: orderCreateManyAddressInputEnvelope
    set?: orderWhereUniqueInput | orderWhereUniqueInput[]
    disconnect?: orderWhereUniqueInput | orderWhereUniqueInput[]
    delete?: orderWhereUniqueInput | orderWhereUniqueInput[]
    connect?: orderWhereUniqueInput | orderWhereUniqueInput[]
    update?: orderUpdateWithWhereUniqueWithoutAddressInput | orderUpdateWithWhereUniqueWithoutAddressInput[]
    updateMany?: orderUpdateManyWithWhereWithoutAddressInput | orderUpdateManyWithWhereWithoutAddressInput[]
    deleteMany?: orderScalarWhereInput | orderScalarWhereInput[]
  }

  export type orderUncheckedUpdateManyWithoutAddressNestedInput = {
    create?: XOR<orderCreateWithoutAddressInput, orderUncheckedCreateWithoutAddressInput> | orderCreateWithoutAddressInput[] | orderUncheckedCreateWithoutAddressInput[]
    connectOrCreate?: orderCreateOrConnectWithoutAddressInput | orderCreateOrConnectWithoutAddressInput[]
    upsert?: orderUpsertWithWhereUniqueWithoutAddressInput | orderUpsertWithWhereUniqueWithoutAddressInput[]
    createMany?: orderCreateManyAddressInputEnvelope
    set?: orderWhereUniqueInput | orderWhereUniqueInput[]
    disconnect?: orderWhereUniqueInput | orderWhereUniqueInput[]
    delete?: orderWhereUniqueInput | orderWhereUniqueInput[]
    connect?: orderWhereUniqueInput | orderWhereUniqueInput[]
    update?: orderUpdateWithWhereUniqueWithoutAddressInput | orderUpdateWithWhereUniqueWithoutAddressInput[]
    updateMany?: orderUpdateManyWithWhereWithoutAddressInput | orderUpdateManyWithWhereWithoutAddressInput[]
    deleteMany?: orderScalarWhereInput | orderScalarWhereInput[]
  }

  export type productCreateNestedManyWithoutBrandInput = {
    create?: XOR<productCreateWithoutBrandInput, productUncheckedCreateWithoutBrandInput> | productCreateWithoutBrandInput[] | productUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: productCreateOrConnectWithoutBrandInput | productCreateOrConnectWithoutBrandInput[]
    createMany?: productCreateManyBrandInputEnvelope
    connect?: productWhereUniqueInput | productWhereUniqueInput[]
  }

  export type productUncheckedCreateNestedManyWithoutBrandInput = {
    create?: XOR<productCreateWithoutBrandInput, productUncheckedCreateWithoutBrandInput> | productCreateWithoutBrandInput[] | productUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: productCreateOrConnectWithoutBrandInput | productCreateOrConnectWithoutBrandInput[]
    createMany?: productCreateManyBrandInputEnvelope
    connect?: productWhereUniqueInput | productWhereUniqueInput[]
  }

  export type productUpdateManyWithoutBrandNestedInput = {
    create?: XOR<productCreateWithoutBrandInput, productUncheckedCreateWithoutBrandInput> | productCreateWithoutBrandInput[] | productUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: productCreateOrConnectWithoutBrandInput | productCreateOrConnectWithoutBrandInput[]
    upsert?: productUpsertWithWhereUniqueWithoutBrandInput | productUpsertWithWhereUniqueWithoutBrandInput[]
    createMany?: productCreateManyBrandInputEnvelope
    set?: productWhereUniqueInput | productWhereUniqueInput[]
    disconnect?: productWhereUniqueInput | productWhereUniqueInput[]
    delete?: productWhereUniqueInput | productWhereUniqueInput[]
    connect?: productWhereUniqueInput | productWhereUniqueInput[]
    update?: productUpdateWithWhereUniqueWithoutBrandInput | productUpdateWithWhereUniqueWithoutBrandInput[]
    updateMany?: productUpdateManyWithWhereWithoutBrandInput | productUpdateManyWithWhereWithoutBrandInput[]
    deleteMany?: productScalarWhereInput | productScalarWhereInput[]
  }

  export type productUncheckedUpdateManyWithoutBrandNestedInput = {
    create?: XOR<productCreateWithoutBrandInput, productUncheckedCreateWithoutBrandInput> | productCreateWithoutBrandInput[] | productUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: productCreateOrConnectWithoutBrandInput | productCreateOrConnectWithoutBrandInput[]
    upsert?: productUpsertWithWhereUniqueWithoutBrandInput | productUpsertWithWhereUniqueWithoutBrandInput[]
    createMany?: productCreateManyBrandInputEnvelope
    set?: productWhereUniqueInput | productWhereUniqueInput[]
    disconnect?: productWhereUniqueInput | productWhereUniqueInput[]
    delete?: productWhereUniqueInput | productWhereUniqueInput[]
    connect?: productWhereUniqueInput | productWhereUniqueInput[]
    update?: productUpdateWithWhereUniqueWithoutBrandInput | productUpdateWithWhereUniqueWithoutBrandInput[]
    updateMany?: productUpdateManyWithWhereWithoutBrandInput | productUpdateManyWithWhereWithoutBrandInput[]
    deleteMany?: productScalarWhereInput | productScalarWhereInput[]
  }

  export type product_tagCreateNestedManyWithoutTagInput = {
    create?: XOR<product_tagCreateWithoutTagInput, product_tagUncheckedCreateWithoutTagInput> | product_tagCreateWithoutTagInput[] | product_tagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: product_tagCreateOrConnectWithoutTagInput | product_tagCreateOrConnectWithoutTagInput[]
    createMany?: product_tagCreateManyTagInputEnvelope
    connect?: product_tagWhereUniqueInput | product_tagWhereUniqueInput[]
  }

  export type product_tagUncheckedCreateNestedManyWithoutTagInput = {
    create?: XOR<product_tagCreateWithoutTagInput, product_tagUncheckedCreateWithoutTagInput> | product_tagCreateWithoutTagInput[] | product_tagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: product_tagCreateOrConnectWithoutTagInput | product_tagCreateOrConnectWithoutTagInput[]
    createMany?: product_tagCreateManyTagInputEnvelope
    connect?: product_tagWhereUniqueInput | product_tagWhereUniqueInput[]
  }

  export type product_tagUpdateManyWithoutTagNestedInput = {
    create?: XOR<product_tagCreateWithoutTagInput, product_tagUncheckedCreateWithoutTagInput> | product_tagCreateWithoutTagInput[] | product_tagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: product_tagCreateOrConnectWithoutTagInput | product_tagCreateOrConnectWithoutTagInput[]
    upsert?: product_tagUpsertWithWhereUniqueWithoutTagInput | product_tagUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: product_tagCreateManyTagInputEnvelope
    set?: product_tagWhereUniqueInput | product_tagWhereUniqueInput[]
    disconnect?: product_tagWhereUniqueInput | product_tagWhereUniqueInput[]
    delete?: product_tagWhereUniqueInput | product_tagWhereUniqueInput[]
    connect?: product_tagWhereUniqueInput | product_tagWhereUniqueInput[]
    update?: product_tagUpdateWithWhereUniqueWithoutTagInput | product_tagUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: product_tagUpdateManyWithWhereWithoutTagInput | product_tagUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: product_tagScalarWhereInput | product_tagScalarWhereInput[]
  }

  export type product_tagUncheckedUpdateManyWithoutTagNestedInput = {
    create?: XOR<product_tagCreateWithoutTagInput, product_tagUncheckedCreateWithoutTagInput> | product_tagCreateWithoutTagInput[] | product_tagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: product_tagCreateOrConnectWithoutTagInput | product_tagCreateOrConnectWithoutTagInput[]
    upsert?: product_tagUpsertWithWhereUniqueWithoutTagInput | product_tagUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: product_tagCreateManyTagInputEnvelope
    set?: product_tagWhereUniqueInput | product_tagWhereUniqueInput[]
    disconnect?: product_tagWhereUniqueInput | product_tagWhereUniqueInput[]
    delete?: product_tagWhereUniqueInput | product_tagWhereUniqueInput[]
    connect?: product_tagWhereUniqueInput | product_tagWhereUniqueInput[]
    update?: product_tagUpdateWithWhereUniqueWithoutTagInput | product_tagUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: product_tagUpdateManyWithWhereWithoutTagInput | product_tagUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: product_tagScalarWhereInput | product_tagScalarWhereInput[]
  }

  export type sub_categoryCreateNestedManyWithoutCategoryInput = {
    create?: XOR<sub_categoryCreateWithoutCategoryInput, sub_categoryUncheckedCreateWithoutCategoryInput> | sub_categoryCreateWithoutCategoryInput[] | sub_categoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: sub_categoryCreateOrConnectWithoutCategoryInput | sub_categoryCreateOrConnectWithoutCategoryInput[]
    createMany?: sub_categoryCreateManyCategoryInputEnvelope
    connect?: sub_categoryWhereUniqueInput | sub_categoryWhereUniqueInput[]
  }

  export type sub_categoryUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<sub_categoryCreateWithoutCategoryInput, sub_categoryUncheckedCreateWithoutCategoryInput> | sub_categoryCreateWithoutCategoryInput[] | sub_categoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: sub_categoryCreateOrConnectWithoutCategoryInput | sub_categoryCreateOrConnectWithoutCategoryInput[]
    createMany?: sub_categoryCreateManyCategoryInputEnvelope
    connect?: sub_categoryWhereUniqueInput | sub_categoryWhereUniqueInput[]
  }

  export type sub_categoryUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<sub_categoryCreateWithoutCategoryInput, sub_categoryUncheckedCreateWithoutCategoryInput> | sub_categoryCreateWithoutCategoryInput[] | sub_categoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: sub_categoryCreateOrConnectWithoutCategoryInput | sub_categoryCreateOrConnectWithoutCategoryInput[]
    upsert?: sub_categoryUpsertWithWhereUniqueWithoutCategoryInput | sub_categoryUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: sub_categoryCreateManyCategoryInputEnvelope
    set?: sub_categoryWhereUniqueInput | sub_categoryWhereUniqueInput[]
    disconnect?: sub_categoryWhereUniqueInput | sub_categoryWhereUniqueInput[]
    delete?: sub_categoryWhereUniqueInput | sub_categoryWhereUniqueInput[]
    connect?: sub_categoryWhereUniqueInput | sub_categoryWhereUniqueInput[]
    update?: sub_categoryUpdateWithWhereUniqueWithoutCategoryInput | sub_categoryUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: sub_categoryUpdateManyWithWhereWithoutCategoryInput | sub_categoryUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: sub_categoryScalarWhereInput | sub_categoryScalarWhereInput[]
  }

  export type sub_categoryUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<sub_categoryCreateWithoutCategoryInput, sub_categoryUncheckedCreateWithoutCategoryInput> | sub_categoryCreateWithoutCategoryInput[] | sub_categoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: sub_categoryCreateOrConnectWithoutCategoryInput | sub_categoryCreateOrConnectWithoutCategoryInput[]
    upsert?: sub_categoryUpsertWithWhereUniqueWithoutCategoryInput | sub_categoryUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: sub_categoryCreateManyCategoryInputEnvelope
    set?: sub_categoryWhereUniqueInput | sub_categoryWhereUniqueInput[]
    disconnect?: sub_categoryWhereUniqueInput | sub_categoryWhereUniqueInput[]
    delete?: sub_categoryWhereUniqueInput | sub_categoryWhereUniqueInput[]
    connect?: sub_categoryWhereUniqueInput | sub_categoryWhereUniqueInput[]
    update?: sub_categoryUpdateWithWhereUniqueWithoutCategoryInput | sub_categoryUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: sub_categoryUpdateManyWithWhereWithoutCategoryInput | sub_categoryUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: sub_categoryScalarWhereInput | sub_categoryScalarWhereInput[]
  }

  export type categoryCreateNestedOneWithoutSub_categoryInput = {
    create?: XOR<categoryCreateWithoutSub_categoryInput, categoryUncheckedCreateWithoutSub_categoryInput>
    connectOrCreate?: categoryCreateOrConnectWithoutSub_categoryInput
    connect?: categoryWhereUniqueInput
  }

  export type categoryUpdateOneRequiredWithoutSub_categoryNestedInput = {
    create?: XOR<categoryCreateWithoutSub_categoryInput, categoryUncheckedCreateWithoutSub_categoryInput>
    connectOrCreate?: categoryCreateOrConnectWithoutSub_categoryInput
    upsert?: categoryUpsertWithoutSub_categoryInput
    connect?: categoryWhereUniqueInput
    update?: XOR<XOR<categoryUpdateToOneWithWhereWithoutSub_categoryInput, categoryUpdateWithoutSub_categoryInput>, categoryUncheckedUpdateWithoutSub_categoryInput>
  }

  export type userCreateNestedOneWithoutProduct_reviewInput = {
    create?: XOR<userCreateWithoutProduct_reviewInput, userUncheckedCreateWithoutProduct_reviewInput>
    connectOrCreate?: userCreateOrConnectWithoutProduct_reviewInput
    connect?: userWhereUniqueInput
  }

  export type productCreateNestedOneWithoutProduct_reviewInput = {
    create?: XOR<productCreateWithoutProduct_reviewInput, productUncheckedCreateWithoutProduct_reviewInput>
    connectOrCreate?: productCreateOrConnectWithoutProduct_reviewInput
    connect?: productWhereUniqueInput
  }

  export type adminCreateNestedOneWithoutProduct_reviewInput = {
    create?: XOR<adminCreateWithoutProduct_reviewInput, adminUncheckedCreateWithoutProduct_reviewInput>
    connectOrCreate?: adminCreateOrConnectWithoutProduct_reviewInput
    connect?: adminWhereUniqueInput
  }

  export type userUpdateOneRequiredWithoutProduct_reviewNestedInput = {
    create?: XOR<userCreateWithoutProduct_reviewInput, userUncheckedCreateWithoutProduct_reviewInput>
    connectOrCreate?: userCreateOrConnectWithoutProduct_reviewInput
    upsert?: userUpsertWithoutProduct_reviewInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutProduct_reviewInput, userUpdateWithoutProduct_reviewInput>, userUncheckedUpdateWithoutProduct_reviewInput>
  }

  export type productUpdateOneRequiredWithoutProduct_reviewNestedInput = {
    create?: XOR<productCreateWithoutProduct_reviewInput, productUncheckedCreateWithoutProduct_reviewInput>
    connectOrCreate?: productCreateOrConnectWithoutProduct_reviewInput
    upsert?: productUpsertWithoutProduct_reviewInput
    connect?: productWhereUniqueInput
    update?: XOR<XOR<productUpdateToOneWithWhereWithoutProduct_reviewInput, productUpdateWithoutProduct_reviewInput>, productUncheckedUpdateWithoutProduct_reviewInput>
  }

  export type adminUpdateOneRequiredWithoutProduct_reviewNestedInput = {
    create?: XOR<adminCreateWithoutProduct_reviewInput, adminUncheckedCreateWithoutProduct_reviewInput>
    connectOrCreate?: adminCreateOrConnectWithoutProduct_reviewInput
    upsert?: adminUpsertWithoutProduct_reviewInput
    connect?: adminWhereUniqueInput
    update?: XOR<XOR<adminUpdateToOneWithWhereWithoutProduct_reviewInput, adminUpdateWithoutProduct_reviewInput>, adminUncheckedUpdateWithoutProduct_reviewInput>
  }

  export type brandCreateNestedOneWithoutProductInput = {
    create?: XOR<brandCreateWithoutProductInput, brandUncheckedCreateWithoutProductInput>
    connectOrCreate?: brandCreateOrConnectWithoutProductInput
    connect?: brandWhereUniqueInput
  }

  export type adminCreateNestedOneWithoutProductInput = {
    create?: XOR<adminCreateWithoutProductInput, adminUncheckedCreateWithoutProductInput>
    connectOrCreate?: adminCreateOrConnectWithoutProductInput
    connect?: adminWhereUniqueInput
  }

  export type product_imageCreateNestedManyWithoutProductInput = {
    create?: XOR<product_imageCreateWithoutProductInput, product_imageUncheckedCreateWithoutProductInput> | product_imageCreateWithoutProductInput[] | product_imageUncheckedCreateWithoutProductInput[]
    connectOrCreate?: product_imageCreateOrConnectWithoutProductInput | product_imageCreateOrConnectWithoutProductInput[]
    createMany?: product_imageCreateManyProductInputEnvelope
    connect?: product_imageWhereUniqueInput | product_imageWhereUniqueInput[]
  }

  export type product_specCreateNestedManyWithoutProductInput = {
    create?: XOR<product_specCreateWithoutProductInput, product_specUncheckedCreateWithoutProductInput> | product_specCreateWithoutProductInput[] | product_specUncheckedCreateWithoutProductInput[]
    connectOrCreate?: product_specCreateOrConnectWithoutProductInput | product_specCreateOrConnectWithoutProductInput[]
    createMany?: product_specCreateManyProductInputEnvelope
    connect?: product_specWhereUniqueInput | product_specWhereUniqueInput[]
  }

  export type product_detailCreateNestedManyWithoutProductInput = {
    create?: XOR<product_detailCreateWithoutProductInput, product_detailUncheckedCreateWithoutProductInput> | product_detailCreateWithoutProductInput[] | product_detailUncheckedCreateWithoutProductInput[]
    connectOrCreate?: product_detailCreateOrConnectWithoutProductInput | product_detailCreateOrConnectWithoutProductInput[]
    createMany?: product_detailCreateManyProductInputEnvelope
    connect?: product_detailWhereUniqueInput | product_detailWhereUniqueInput[]
  }

  export type product_option_firstCreateNestedManyWithoutProductInput = {
    create?: XOR<product_option_firstCreateWithoutProductInput, product_option_firstUncheckedCreateWithoutProductInput> | product_option_firstCreateWithoutProductInput[] | product_option_firstUncheckedCreateWithoutProductInput[]
    connectOrCreate?: product_option_firstCreateOrConnectWithoutProductInput | product_option_firstCreateOrConnectWithoutProductInput[]
    createMany?: product_option_firstCreateManyProductInputEnvelope
    connect?: product_option_firstWhereUniqueInput | product_option_firstWhereUniqueInput[]
  }

  export type product_option_secondCreateNestedManyWithoutProductInput = {
    create?: XOR<product_option_secondCreateWithoutProductInput, product_option_secondUncheckedCreateWithoutProductInput> | product_option_secondCreateWithoutProductInput[] | product_option_secondUncheckedCreateWithoutProductInput[]
    connectOrCreate?: product_option_secondCreateOrConnectWithoutProductInput | product_option_secondCreateOrConnectWithoutProductInput[]
    createMany?: product_option_secondCreateManyProductInputEnvelope
    connect?: product_option_secondWhereUniqueInput | product_option_secondWhereUniqueInput[]
  }

  export type product_priceCreateNestedManyWithoutProductInput = {
    create?: XOR<product_priceCreateWithoutProductInput, product_priceUncheckedCreateWithoutProductInput> | product_priceCreateWithoutProductInput[] | product_priceUncheckedCreateWithoutProductInput[]
    connectOrCreate?: product_priceCreateOrConnectWithoutProductInput | product_priceCreateOrConnectWithoutProductInput[]
    createMany?: product_priceCreateManyProductInputEnvelope
    connect?: product_priceWhereUniqueInput | product_priceWhereUniqueInput[]
  }

  export type product_wholesaleCreateNestedManyWithoutProductInput = {
    create?: XOR<product_wholesaleCreateWithoutProductInput, product_wholesaleUncheckedCreateWithoutProductInput> | product_wholesaleCreateWithoutProductInput[] | product_wholesaleUncheckedCreateWithoutProductInput[]
    connectOrCreate?: product_wholesaleCreateOrConnectWithoutProductInput | product_wholesaleCreateOrConnectWithoutProductInput[]
    createMany?: product_wholesaleCreateManyProductInputEnvelope
    connect?: product_wholesaleWhereUniqueInput | product_wholesaleWhereUniqueInput[]
  }

  export type product_reviewCreateNestedManyWithoutProductInput = {
    create?: XOR<product_reviewCreateWithoutProductInput, product_reviewUncheckedCreateWithoutProductInput> | product_reviewCreateWithoutProductInput[] | product_reviewUncheckedCreateWithoutProductInput[]
    connectOrCreate?: product_reviewCreateOrConnectWithoutProductInput | product_reviewCreateOrConnectWithoutProductInput[]
    createMany?: product_reviewCreateManyProductInputEnvelope
    connect?: product_reviewWhereUniqueInput | product_reviewWhereUniqueInput[]
  }

  export type product_tagCreateNestedManyWithoutProductInput = {
    create?: XOR<product_tagCreateWithoutProductInput, product_tagUncheckedCreateWithoutProductInput> | product_tagCreateWithoutProductInput[] | product_tagUncheckedCreateWithoutProductInput[]
    connectOrCreate?: product_tagCreateOrConnectWithoutProductInput | product_tagCreateOrConnectWithoutProductInput[]
    createMany?: product_tagCreateManyProductInputEnvelope
    connect?: product_tagWhereUniqueInput | product_tagWhereUniqueInput[]
  }

  export type cartCreateNestedManyWithoutProductInput = {
    create?: XOR<cartCreateWithoutProductInput, cartUncheckedCreateWithoutProductInput> | cartCreateWithoutProductInput[] | cartUncheckedCreateWithoutProductInput[]
    connectOrCreate?: cartCreateOrConnectWithoutProductInput | cartCreateOrConnectWithoutProductInput[]
    createMany?: cartCreateManyProductInputEnvelope
    connect?: cartWhereUniqueInput | cartWhereUniqueInput[]
  }

  export type order_productCreateNestedManyWithoutProductInput = {
    create?: XOR<order_productCreateWithoutProductInput, order_productUncheckedCreateWithoutProductInput> | order_productCreateWithoutProductInput[] | order_productUncheckedCreateWithoutProductInput[]
    connectOrCreate?: order_productCreateOrConnectWithoutProductInput | order_productCreateOrConnectWithoutProductInput[]
    createMany?: order_productCreateManyProductInputEnvelope
    connect?: order_productWhereUniqueInput | order_productWhereUniqueInput[]
  }

  export type product_imageUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<product_imageCreateWithoutProductInput, product_imageUncheckedCreateWithoutProductInput> | product_imageCreateWithoutProductInput[] | product_imageUncheckedCreateWithoutProductInput[]
    connectOrCreate?: product_imageCreateOrConnectWithoutProductInput | product_imageCreateOrConnectWithoutProductInput[]
    createMany?: product_imageCreateManyProductInputEnvelope
    connect?: product_imageWhereUniqueInput | product_imageWhereUniqueInput[]
  }

  export type product_specUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<product_specCreateWithoutProductInput, product_specUncheckedCreateWithoutProductInput> | product_specCreateWithoutProductInput[] | product_specUncheckedCreateWithoutProductInput[]
    connectOrCreate?: product_specCreateOrConnectWithoutProductInput | product_specCreateOrConnectWithoutProductInput[]
    createMany?: product_specCreateManyProductInputEnvelope
    connect?: product_specWhereUniqueInput | product_specWhereUniqueInput[]
  }

  export type product_detailUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<product_detailCreateWithoutProductInput, product_detailUncheckedCreateWithoutProductInput> | product_detailCreateWithoutProductInput[] | product_detailUncheckedCreateWithoutProductInput[]
    connectOrCreate?: product_detailCreateOrConnectWithoutProductInput | product_detailCreateOrConnectWithoutProductInput[]
    createMany?: product_detailCreateManyProductInputEnvelope
    connect?: product_detailWhereUniqueInput | product_detailWhereUniqueInput[]
  }

  export type product_option_firstUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<product_option_firstCreateWithoutProductInput, product_option_firstUncheckedCreateWithoutProductInput> | product_option_firstCreateWithoutProductInput[] | product_option_firstUncheckedCreateWithoutProductInput[]
    connectOrCreate?: product_option_firstCreateOrConnectWithoutProductInput | product_option_firstCreateOrConnectWithoutProductInput[]
    createMany?: product_option_firstCreateManyProductInputEnvelope
    connect?: product_option_firstWhereUniqueInput | product_option_firstWhereUniqueInput[]
  }

  export type product_option_secondUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<product_option_secondCreateWithoutProductInput, product_option_secondUncheckedCreateWithoutProductInput> | product_option_secondCreateWithoutProductInput[] | product_option_secondUncheckedCreateWithoutProductInput[]
    connectOrCreate?: product_option_secondCreateOrConnectWithoutProductInput | product_option_secondCreateOrConnectWithoutProductInput[]
    createMany?: product_option_secondCreateManyProductInputEnvelope
    connect?: product_option_secondWhereUniqueInput | product_option_secondWhereUniqueInput[]
  }

  export type product_priceUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<product_priceCreateWithoutProductInput, product_priceUncheckedCreateWithoutProductInput> | product_priceCreateWithoutProductInput[] | product_priceUncheckedCreateWithoutProductInput[]
    connectOrCreate?: product_priceCreateOrConnectWithoutProductInput | product_priceCreateOrConnectWithoutProductInput[]
    createMany?: product_priceCreateManyProductInputEnvelope
    connect?: product_priceWhereUniqueInput | product_priceWhereUniqueInput[]
  }

  export type product_wholesaleUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<product_wholesaleCreateWithoutProductInput, product_wholesaleUncheckedCreateWithoutProductInput> | product_wholesaleCreateWithoutProductInput[] | product_wholesaleUncheckedCreateWithoutProductInput[]
    connectOrCreate?: product_wholesaleCreateOrConnectWithoutProductInput | product_wholesaleCreateOrConnectWithoutProductInput[]
    createMany?: product_wholesaleCreateManyProductInputEnvelope
    connect?: product_wholesaleWhereUniqueInput | product_wholesaleWhereUniqueInput[]
  }

  export type product_reviewUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<product_reviewCreateWithoutProductInput, product_reviewUncheckedCreateWithoutProductInput> | product_reviewCreateWithoutProductInput[] | product_reviewUncheckedCreateWithoutProductInput[]
    connectOrCreate?: product_reviewCreateOrConnectWithoutProductInput | product_reviewCreateOrConnectWithoutProductInput[]
    createMany?: product_reviewCreateManyProductInputEnvelope
    connect?: product_reviewWhereUniqueInput | product_reviewWhereUniqueInput[]
  }

  export type product_tagUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<product_tagCreateWithoutProductInput, product_tagUncheckedCreateWithoutProductInput> | product_tagCreateWithoutProductInput[] | product_tagUncheckedCreateWithoutProductInput[]
    connectOrCreate?: product_tagCreateOrConnectWithoutProductInput | product_tagCreateOrConnectWithoutProductInput[]
    createMany?: product_tagCreateManyProductInputEnvelope
    connect?: product_tagWhereUniqueInput | product_tagWhereUniqueInput[]
  }

  export type cartUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<cartCreateWithoutProductInput, cartUncheckedCreateWithoutProductInput> | cartCreateWithoutProductInput[] | cartUncheckedCreateWithoutProductInput[]
    connectOrCreate?: cartCreateOrConnectWithoutProductInput | cartCreateOrConnectWithoutProductInput[]
    createMany?: cartCreateManyProductInputEnvelope
    connect?: cartWhereUniqueInput | cartWhereUniqueInput[]
  }

  export type order_productUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<order_productCreateWithoutProductInput, order_productUncheckedCreateWithoutProductInput> | order_productCreateWithoutProductInput[] | order_productUncheckedCreateWithoutProductInput[]
    connectOrCreate?: order_productCreateOrConnectWithoutProductInput | order_productCreateOrConnectWithoutProductInput[]
    createMany?: order_productCreateManyProductInputEnvelope
    connect?: order_productWhereUniqueInput | order_productWhereUniqueInput[]
  }

  export type brandUpdateOneRequiredWithoutProductNestedInput = {
    create?: XOR<brandCreateWithoutProductInput, brandUncheckedCreateWithoutProductInput>
    connectOrCreate?: brandCreateOrConnectWithoutProductInput
    upsert?: brandUpsertWithoutProductInput
    connect?: brandWhereUniqueInput
    update?: XOR<XOR<brandUpdateToOneWithWhereWithoutProductInput, brandUpdateWithoutProductInput>, brandUncheckedUpdateWithoutProductInput>
  }

  export type adminUpdateOneRequiredWithoutProductNestedInput = {
    create?: XOR<adminCreateWithoutProductInput, adminUncheckedCreateWithoutProductInput>
    connectOrCreate?: adminCreateOrConnectWithoutProductInput
    upsert?: adminUpsertWithoutProductInput
    connect?: adminWhereUniqueInput
    update?: XOR<XOR<adminUpdateToOneWithWhereWithoutProductInput, adminUpdateWithoutProductInput>, adminUncheckedUpdateWithoutProductInput>
  }

  export type product_imageUpdateManyWithoutProductNestedInput = {
    create?: XOR<product_imageCreateWithoutProductInput, product_imageUncheckedCreateWithoutProductInput> | product_imageCreateWithoutProductInput[] | product_imageUncheckedCreateWithoutProductInput[]
    connectOrCreate?: product_imageCreateOrConnectWithoutProductInput | product_imageCreateOrConnectWithoutProductInput[]
    upsert?: product_imageUpsertWithWhereUniqueWithoutProductInput | product_imageUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: product_imageCreateManyProductInputEnvelope
    set?: product_imageWhereUniqueInput | product_imageWhereUniqueInput[]
    disconnect?: product_imageWhereUniqueInput | product_imageWhereUniqueInput[]
    delete?: product_imageWhereUniqueInput | product_imageWhereUniqueInput[]
    connect?: product_imageWhereUniqueInput | product_imageWhereUniqueInput[]
    update?: product_imageUpdateWithWhereUniqueWithoutProductInput | product_imageUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: product_imageUpdateManyWithWhereWithoutProductInput | product_imageUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: product_imageScalarWhereInput | product_imageScalarWhereInput[]
  }

  export type product_specUpdateManyWithoutProductNestedInput = {
    create?: XOR<product_specCreateWithoutProductInput, product_specUncheckedCreateWithoutProductInput> | product_specCreateWithoutProductInput[] | product_specUncheckedCreateWithoutProductInput[]
    connectOrCreate?: product_specCreateOrConnectWithoutProductInput | product_specCreateOrConnectWithoutProductInput[]
    upsert?: product_specUpsertWithWhereUniqueWithoutProductInput | product_specUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: product_specCreateManyProductInputEnvelope
    set?: product_specWhereUniqueInput | product_specWhereUniqueInput[]
    disconnect?: product_specWhereUniqueInput | product_specWhereUniqueInput[]
    delete?: product_specWhereUniqueInput | product_specWhereUniqueInput[]
    connect?: product_specWhereUniqueInput | product_specWhereUniqueInput[]
    update?: product_specUpdateWithWhereUniqueWithoutProductInput | product_specUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: product_specUpdateManyWithWhereWithoutProductInput | product_specUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: product_specScalarWhereInput | product_specScalarWhereInput[]
  }

  export type product_detailUpdateManyWithoutProductNestedInput = {
    create?: XOR<product_detailCreateWithoutProductInput, product_detailUncheckedCreateWithoutProductInput> | product_detailCreateWithoutProductInput[] | product_detailUncheckedCreateWithoutProductInput[]
    connectOrCreate?: product_detailCreateOrConnectWithoutProductInput | product_detailCreateOrConnectWithoutProductInput[]
    upsert?: product_detailUpsertWithWhereUniqueWithoutProductInput | product_detailUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: product_detailCreateManyProductInputEnvelope
    set?: product_detailWhereUniqueInput | product_detailWhereUniqueInput[]
    disconnect?: product_detailWhereUniqueInput | product_detailWhereUniqueInput[]
    delete?: product_detailWhereUniqueInput | product_detailWhereUniqueInput[]
    connect?: product_detailWhereUniqueInput | product_detailWhereUniqueInput[]
    update?: product_detailUpdateWithWhereUniqueWithoutProductInput | product_detailUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: product_detailUpdateManyWithWhereWithoutProductInput | product_detailUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: product_detailScalarWhereInput | product_detailScalarWhereInput[]
  }

  export type product_option_firstUpdateManyWithoutProductNestedInput = {
    create?: XOR<product_option_firstCreateWithoutProductInput, product_option_firstUncheckedCreateWithoutProductInput> | product_option_firstCreateWithoutProductInput[] | product_option_firstUncheckedCreateWithoutProductInput[]
    connectOrCreate?: product_option_firstCreateOrConnectWithoutProductInput | product_option_firstCreateOrConnectWithoutProductInput[]
    upsert?: product_option_firstUpsertWithWhereUniqueWithoutProductInput | product_option_firstUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: product_option_firstCreateManyProductInputEnvelope
    set?: product_option_firstWhereUniqueInput | product_option_firstWhereUniqueInput[]
    disconnect?: product_option_firstWhereUniqueInput | product_option_firstWhereUniqueInput[]
    delete?: product_option_firstWhereUniqueInput | product_option_firstWhereUniqueInput[]
    connect?: product_option_firstWhereUniqueInput | product_option_firstWhereUniqueInput[]
    update?: product_option_firstUpdateWithWhereUniqueWithoutProductInput | product_option_firstUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: product_option_firstUpdateManyWithWhereWithoutProductInput | product_option_firstUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: product_option_firstScalarWhereInput | product_option_firstScalarWhereInput[]
  }

  export type product_option_secondUpdateManyWithoutProductNestedInput = {
    create?: XOR<product_option_secondCreateWithoutProductInput, product_option_secondUncheckedCreateWithoutProductInput> | product_option_secondCreateWithoutProductInput[] | product_option_secondUncheckedCreateWithoutProductInput[]
    connectOrCreate?: product_option_secondCreateOrConnectWithoutProductInput | product_option_secondCreateOrConnectWithoutProductInput[]
    upsert?: product_option_secondUpsertWithWhereUniqueWithoutProductInput | product_option_secondUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: product_option_secondCreateManyProductInputEnvelope
    set?: product_option_secondWhereUniqueInput | product_option_secondWhereUniqueInput[]
    disconnect?: product_option_secondWhereUniqueInput | product_option_secondWhereUniqueInput[]
    delete?: product_option_secondWhereUniqueInput | product_option_secondWhereUniqueInput[]
    connect?: product_option_secondWhereUniqueInput | product_option_secondWhereUniqueInput[]
    update?: product_option_secondUpdateWithWhereUniqueWithoutProductInput | product_option_secondUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: product_option_secondUpdateManyWithWhereWithoutProductInput | product_option_secondUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: product_option_secondScalarWhereInput | product_option_secondScalarWhereInput[]
  }

  export type product_priceUpdateManyWithoutProductNestedInput = {
    create?: XOR<product_priceCreateWithoutProductInput, product_priceUncheckedCreateWithoutProductInput> | product_priceCreateWithoutProductInput[] | product_priceUncheckedCreateWithoutProductInput[]
    connectOrCreate?: product_priceCreateOrConnectWithoutProductInput | product_priceCreateOrConnectWithoutProductInput[]
    upsert?: product_priceUpsertWithWhereUniqueWithoutProductInput | product_priceUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: product_priceCreateManyProductInputEnvelope
    set?: product_priceWhereUniqueInput | product_priceWhereUniqueInput[]
    disconnect?: product_priceWhereUniqueInput | product_priceWhereUniqueInput[]
    delete?: product_priceWhereUniqueInput | product_priceWhereUniqueInput[]
    connect?: product_priceWhereUniqueInput | product_priceWhereUniqueInput[]
    update?: product_priceUpdateWithWhereUniqueWithoutProductInput | product_priceUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: product_priceUpdateManyWithWhereWithoutProductInput | product_priceUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: product_priceScalarWhereInput | product_priceScalarWhereInput[]
  }

  export type product_wholesaleUpdateManyWithoutProductNestedInput = {
    create?: XOR<product_wholesaleCreateWithoutProductInput, product_wholesaleUncheckedCreateWithoutProductInput> | product_wholesaleCreateWithoutProductInput[] | product_wholesaleUncheckedCreateWithoutProductInput[]
    connectOrCreate?: product_wholesaleCreateOrConnectWithoutProductInput | product_wholesaleCreateOrConnectWithoutProductInput[]
    upsert?: product_wholesaleUpsertWithWhereUniqueWithoutProductInput | product_wholesaleUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: product_wholesaleCreateManyProductInputEnvelope
    set?: product_wholesaleWhereUniqueInput | product_wholesaleWhereUniqueInput[]
    disconnect?: product_wholesaleWhereUniqueInput | product_wholesaleWhereUniqueInput[]
    delete?: product_wholesaleWhereUniqueInput | product_wholesaleWhereUniqueInput[]
    connect?: product_wholesaleWhereUniqueInput | product_wholesaleWhereUniqueInput[]
    update?: product_wholesaleUpdateWithWhereUniqueWithoutProductInput | product_wholesaleUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: product_wholesaleUpdateManyWithWhereWithoutProductInput | product_wholesaleUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: product_wholesaleScalarWhereInput | product_wholesaleScalarWhereInput[]
  }

  export type product_reviewUpdateManyWithoutProductNestedInput = {
    create?: XOR<product_reviewCreateWithoutProductInput, product_reviewUncheckedCreateWithoutProductInput> | product_reviewCreateWithoutProductInput[] | product_reviewUncheckedCreateWithoutProductInput[]
    connectOrCreate?: product_reviewCreateOrConnectWithoutProductInput | product_reviewCreateOrConnectWithoutProductInput[]
    upsert?: product_reviewUpsertWithWhereUniqueWithoutProductInput | product_reviewUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: product_reviewCreateManyProductInputEnvelope
    set?: product_reviewWhereUniqueInput | product_reviewWhereUniqueInput[]
    disconnect?: product_reviewWhereUniqueInput | product_reviewWhereUniqueInput[]
    delete?: product_reviewWhereUniqueInput | product_reviewWhereUniqueInput[]
    connect?: product_reviewWhereUniqueInput | product_reviewWhereUniqueInput[]
    update?: product_reviewUpdateWithWhereUniqueWithoutProductInput | product_reviewUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: product_reviewUpdateManyWithWhereWithoutProductInput | product_reviewUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: product_reviewScalarWhereInput | product_reviewScalarWhereInput[]
  }

  export type product_tagUpdateManyWithoutProductNestedInput = {
    create?: XOR<product_tagCreateWithoutProductInput, product_tagUncheckedCreateWithoutProductInput> | product_tagCreateWithoutProductInput[] | product_tagUncheckedCreateWithoutProductInput[]
    connectOrCreate?: product_tagCreateOrConnectWithoutProductInput | product_tagCreateOrConnectWithoutProductInput[]
    upsert?: product_tagUpsertWithWhereUniqueWithoutProductInput | product_tagUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: product_tagCreateManyProductInputEnvelope
    set?: product_tagWhereUniqueInput | product_tagWhereUniqueInput[]
    disconnect?: product_tagWhereUniqueInput | product_tagWhereUniqueInput[]
    delete?: product_tagWhereUniqueInput | product_tagWhereUniqueInput[]
    connect?: product_tagWhereUniqueInput | product_tagWhereUniqueInput[]
    update?: product_tagUpdateWithWhereUniqueWithoutProductInput | product_tagUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: product_tagUpdateManyWithWhereWithoutProductInput | product_tagUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: product_tagScalarWhereInput | product_tagScalarWhereInput[]
  }

  export type cartUpdateManyWithoutProductNestedInput = {
    create?: XOR<cartCreateWithoutProductInput, cartUncheckedCreateWithoutProductInput> | cartCreateWithoutProductInput[] | cartUncheckedCreateWithoutProductInput[]
    connectOrCreate?: cartCreateOrConnectWithoutProductInput | cartCreateOrConnectWithoutProductInput[]
    upsert?: cartUpsertWithWhereUniqueWithoutProductInput | cartUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: cartCreateManyProductInputEnvelope
    set?: cartWhereUniqueInput | cartWhereUniqueInput[]
    disconnect?: cartWhereUniqueInput | cartWhereUniqueInput[]
    delete?: cartWhereUniqueInput | cartWhereUniqueInput[]
    connect?: cartWhereUniqueInput | cartWhereUniqueInput[]
    update?: cartUpdateWithWhereUniqueWithoutProductInput | cartUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: cartUpdateManyWithWhereWithoutProductInput | cartUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: cartScalarWhereInput | cartScalarWhereInput[]
  }

  export type order_productUpdateManyWithoutProductNestedInput = {
    create?: XOR<order_productCreateWithoutProductInput, order_productUncheckedCreateWithoutProductInput> | order_productCreateWithoutProductInput[] | order_productUncheckedCreateWithoutProductInput[]
    connectOrCreate?: order_productCreateOrConnectWithoutProductInput | order_productCreateOrConnectWithoutProductInput[]
    upsert?: order_productUpsertWithWhereUniqueWithoutProductInput | order_productUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: order_productCreateManyProductInputEnvelope
    set?: order_productWhereUniqueInput | order_productWhereUniqueInput[]
    disconnect?: order_productWhereUniqueInput | order_productWhereUniqueInput[]
    delete?: order_productWhereUniqueInput | order_productWhereUniqueInput[]
    connect?: order_productWhereUniqueInput | order_productWhereUniqueInput[]
    update?: order_productUpdateWithWhereUniqueWithoutProductInput | order_productUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: order_productUpdateManyWithWhereWithoutProductInput | order_productUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: order_productScalarWhereInput | order_productScalarWhereInput[]
  }

  export type product_imageUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<product_imageCreateWithoutProductInput, product_imageUncheckedCreateWithoutProductInput> | product_imageCreateWithoutProductInput[] | product_imageUncheckedCreateWithoutProductInput[]
    connectOrCreate?: product_imageCreateOrConnectWithoutProductInput | product_imageCreateOrConnectWithoutProductInput[]
    upsert?: product_imageUpsertWithWhereUniqueWithoutProductInput | product_imageUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: product_imageCreateManyProductInputEnvelope
    set?: product_imageWhereUniqueInput | product_imageWhereUniqueInput[]
    disconnect?: product_imageWhereUniqueInput | product_imageWhereUniqueInput[]
    delete?: product_imageWhereUniqueInput | product_imageWhereUniqueInput[]
    connect?: product_imageWhereUniqueInput | product_imageWhereUniqueInput[]
    update?: product_imageUpdateWithWhereUniqueWithoutProductInput | product_imageUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: product_imageUpdateManyWithWhereWithoutProductInput | product_imageUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: product_imageScalarWhereInput | product_imageScalarWhereInput[]
  }

  export type product_specUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<product_specCreateWithoutProductInput, product_specUncheckedCreateWithoutProductInput> | product_specCreateWithoutProductInput[] | product_specUncheckedCreateWithoutProductInput[]
    connectOrCreate?: product_specCreateOrConnectWithoutProductInput | product_specCreateOrConnectWithoutProductInput[]
    upsert?: product_specUpsertWithWhereUniqueWithoutProductInput | product_specUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: product_specCreateManyProductInputEnvelope
    set?: product_specWhereUniqueInput | product_specWhereUniqueInput[]
    disconnect?: product_specWhereUniqueInput | product_specWhereUniqueInput[]
    delete?: product_specWhereUniqueInput | product_specWhereUniqueInput[]
    connect?: product_specWhereUniqueInput | product_specWhereUniqueInput[]
    update?: product_specUpdateWithWhereUniqueWithoutProductInput | product_specUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: product_specUpdateManyWithWhereWithoutProductInput | product_specUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: product_specScalarWhereInput | product_specScalarWhereInput[]
  }

  export type product_detailUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<product_detailCreateWithoutProductInput, product_detailUncheckedCreateWithoutProductInput> | product_detailCreateWithoutProductInput[] | product_detailUncheckedCreateWithoutProductInput[]
    connectOrCreate?: product_detailCreateOrConnectWithoutProductInput | product_detailCreateOrConnectWithoutProductInput[]
    upsert?: product_detailUpsertWithWhereUniqueWithoutProductInput | product_detailUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: product_detailCreateManyProductInputEnvelope
    set?: product_detailWhereUniqueInput | product_detailWhereUniqueInput[]
    disconnect?: product_detailWhereUniqueInput | product_detailWhereUniqueInput[]
    delete?: product_detailWhereUniqueInput | product_detailWhereUniqueInput[]
    connect?: product_detailWhereUniqueInput | product_detailWhereUniqueInput[]
    update?: product_detailUpdateWithWhereUniqueWithoutProductInput | product_detailUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: product_detailUpdateManyWithWhereWithoutProductInput | product_detailUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: product_detailScalarWhereInput | product_detailScalarWhereInput[]
  }

  export type product_option_firstUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<product_option_firstCreateWithoutProductInput, product_option_firstUncheckedCreateWithoutProductInput> | product_option_firstCreateWithoutProductInput[] | product_option_firstUncheckedCreateWithoutProductInput[]
    connectOrCreate?: product_option_firstCreateOrConnectWithoutProductInput | product_option_firstCreateOrConnectWithoutProductInput[]
    upsert?: product_option_firstUpsertWithWhereUniqueWithoutProductInput | product_option_firstUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: product_option_firstCreateManyProductInputEnvelope
    set?: product_option_firstWhereUniqueInput | product_option_firstWhereUniqueInput[]
    disconnect?: product_option_firstWhereUniqueInput | product_option_firstWhereUniqueInput[]
    delete?: product_option_firstWhereUniqueInput | product_option_firstWhereUniqueInput[]
    connect?: product_option_firstWhereUniqueInput | product_option_firstWhereUniqueInput[]
    update?: product_option_firstUpdateWithWhereUniqueWithoutProductInput | product_option_firstUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: product_option_firstUpdateManyWithWhereWithoutProductInput | product_option_firstUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: product_option_firstScalarWhereInput | product_option_firstScalarWhereInput[]
  }

  export type product_option_secondUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<product_option_secondCreateWithoutProductInput, product_option_secondUncheckedCreateWithoutProductInput> | product_option_secondCreateWithoutProductInput[] | product_option_secondUncheckedCreateWithoutProductInput[]
    connectOrCreate?: product_option_secondCreateOrConnectWithoutProductInput | product_option_secondCreateOrConnectWithoutProductInput[]
    upsert?: product_option_secondUpsertWithWhereUniqueWithoutProductInput | product_option_secondUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: product_option_secondCreateManyProductInputEnvelope
    set?: product_option_secondWhereUniqueInput | product_option_secondWhereUniqueInput[]
    disconnect?: product_option_secondWhereUniqueInput | product_option_secondWhereUniqueInput[]
    delete?: product_option_secondWhereUniqueInput | product_option_secondWhereUniqueInput[]
    connect?: product_option_secondWhereUniqueInput | product_option_secondWhereUniqueInput[]
    update?: product_option_secondUpdateWithWhereUniqueWithoutProductInput | product_option_secondUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: product_option_secondUpdateManyWithWhereWithoutProductInput | product_option_secondUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: product_option_secondScalarWhereInput | product_option_secondScalarWhereInput[]
  }

  export type product_priceUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<product_priceCreateWithoutProductInput, product_priceUncheckedCreateWithoutProductInput> | product_priceCreateWithoutProductInput[] | product_priceUncheckedCreateWithoutProductInput[]
    connectOrCreate?: product_priceCreateOrConnectWithoutProductInput | product_priceCreateOrConnectWithoutProductInput[]
    upsert?: product_priceUpsertWithWhereUniqueWithoutProductInput | product_priceUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: product_priceCreateManyProductInputEnvelope
    set?: product_priceWhereUniqueInput | product_priceWhereUniqueInput[]
    disconnect?: product_priceWhereUniqueInput | product_priceWhereUniqueInput[]
    delete?: product_priceWhereUniqueInput | product_priceWhereUniqueInput[]
    connect?: product_priceWhereUniqueInput | product_priceWhereUniqueInput[]
    update?: product_priceUpdateWithWhereUniqueWithoutProductInput | product_priceUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: product_priceUpdateManyWithWhereWithoutProductInput | product_priceUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: product_priceScalarWhereInput | product_priceScalarWhereInput[]
  }

  export type product_wholesaleUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<product_wholesaleCreateWithoutProductInput, product_wholesaleUncheckedCreateWithoutProductInput> | product_wholesaleCreateWithoutProductInput[] | product_wholesaleUncheckedCreateWithoutProductInput[]
    connectOrCreate?: product_wholesaleCreateOrConnectWithoutProductInput | product_wholesaleCreateOrConnectWithoutProductInput[]
    upsert?: product_wholesaleUpsertWithWhereUniqueWithoutProductInput | product_wholesaleUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: product_wholesaleCreateManyProductInputEnvelope
    set?: product_wholesaleWhereUniqueInput | product_wholesaleWhereUniqueInput[]
    disconnect?: product_wholesaleWhereUniqueInput | product_wholesaleWhereUniqueInput[]
    delete?: product_wholesaleWhereUniqueInput | product_wholesaleWhereUniqueInput[]
    connect?: product_wholesaleWhereUniqueInput | product_wholesaleWhereUniqueInput[]
    update?: product_wholesaleUpdateWithWhereUniqueWithoutProductInput | product_wholesaleUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: product_wholesaleUpdateManyWithWhereWithoutProductInput | product_wholesaleUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: product_wholesaleScalarWhereInput | product_wholesaleScalarWhereInput[]
  }

  export type product_reviewUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<product_reviewCreateWithoutProductInput, product_reviewUncheckedCreateWithoutProductInput> | product_reviewCreateWithoutProductInput[] | product_reviewUncheckedCreateWithoutProductInput[]
    connectOrCreate?: product_reviewCreateOrConnectWithoutProductInput | product_reviewCreateOrConnectWithoutProductInput[]
    upsert?: product_reviewUpsertWithWhereUniqueWithoutProductInput | product_reviewUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: product_reviewCreateManyProductInputEnvelope
    set?: product_reviewWhereUniqueInput | product_reviewWhereUniqueInput[]
    disconnect?: product_reviewWhereUniqueInput | product_reviewWhereUniqueInput[]
    delete?: product_reviewWhereUniqueInput | product_reviewWhereUniqueInput[]
    connect?: product_reviewWhereUniqueInput | product_reviewWhereUniqueInput[]
    update?: product_reviewUpdateWithWhereUniqueWithoutProductInput | product_reviewUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: product_reviewUpdateManyWithWhereWithoutProductInput | product_reviewUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: product_reviewScalarWhereInput | product_reviewScalarWhereInput[]
  }

  export type product_tagUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<product_tagCreateWithoutProductInput, product_tagUncheckedCreateWithoutProductInput> | product_tagCreateWithoutProductInput[] | product_tagUncheckedCreateWithoutProductInput[]
    connectOrCreate?: product_tagCreateOrConnectWithoutProductInput | product_tagCreateOrConnectWithoutProductInput[]
    upsert?: product_tagUpsertWithWhereUniqueWithoutProductInput | product_tagUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: product_tagCreateManyProductInputEnvelope
    set?: product_tagWhereUniqueInput | product_tagWhereUniqueInput[]
    disconnect?: product_tagWhereUniqueInput | product_tagWhereUniqueInput[]
    delete?: product_tagWhereUniqueInput | product_tagWhereUniqueInput[]
    connect?: product_tagWhereUniqueInput | product_tagWhereUniqueInput[]
    update?: product_tagUpdateWithWhereUniqueWithoutProductInput | product_tagUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: product_tagUpdateManyWithWhereWithoutProductInput | product_tagUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: product_tagScalarWhereInput | product_tagScalarWhereInput[]
  }

  export type cartUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<cartCreateWithoutProductInput, cartUncheckedCreateWithoutProductInput> | cartCreateWithoutProductInput[] | cartUncheckedCreateWithoutProductInput[]
    connectOrCreate?: cartCreateOrConnectWithoutProductInput | cartCreateOrConnectWithoutProductInput[]
    upsert?: cartUpsertWithWhereUniqueWithoutProductInput | cartUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: cartCreateManyProductInputEnvelope
    set?: cartWhereUniqueInput | cartWhereUniqueInput[]
    disconnect?: cartWhereUniqueInput | cartWhereUniqueInput[]
    delete?: cartWhereUniqueInput | cartWhereUniqueInput[]
    connect?: cartWhereUniqueInput | cartWhereUniqueInput[]
    update?: cartUpdateWithWhereUniqueWithoutProductInput | cartUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: cartUpdateManyWithWhereWithoutProductInput | cartUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: cartScalarWhereInput | cartScalarWhereInput[]
  }

  export type order_productUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<order_productCreateWithoutProductInput, order_productUncheckedCreateWithoutProductInput> | order_productCreateWithoutProductInput[] | order_productUncheckedCreateWithoutProductInput[]
    connectOrCreate?: order_productCreateOrConnectWithoutProductInput | order_productCreateOrConnectWithoutProductInput[]
    upsert?: order_productUpsertWithWhereUniqueWithoutProductInput | order_productUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: order_productCreateManyProductInputEnvelope
    set?: order_productWhereUniqueInput | order_productWhereUniqueInput[]
    disconnect?: order_productWhereUniqueInput | order_productWhereUniqueInput[]
    delete?: order_productWhereUniqueInput | order_productWhereUniqueInput[]
    connect?: order_productWhereUniqueInput | order_productWhereUniqueInput[]
    update?: order_productUpdateWithWhereUniqueWithoutProductInput | order_productUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: order_productUpdateManyWithWhereWithoutProductInput | order_productUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: order_productScalarWhereInput | order_productScalarWhereInput[]
  }

  export type productCreateNestedOneWithoutProduct_tagInput = {
    create?: XOR<productCreateWithoutProduct_tagInput, productUncheckedCreateWithoutProduct_tagInput>
    connectOrCreate?: productCreateOrConnectWithoutProduct_tagInput
    connect?: productWhereUniqueInput
  }

  export type tagCreateNestedOneWithoutProduct_tagInput = {
    create?: XOR<tagCreateWithoutProduct_tagInput, tagUncheckedCreateWithoutProduct_tagInput>
    connectOrCreate?: tagCreateOrConnectWithoutProduct_tagInput
    connect?: tagWhereUniqueInput
  }

  export type productUpdateOneRequiredWithoutProduct_tagNestedInput = {
    create?: XOR<productCreateWithoutProduct_tagInput, productUncheckedCreateWithoutProduct_tagInput>
    connectOrCreate?: productCreateOrConnectWithoutProduct_tagInput
    upsert?: productUpsertWithoutProduct_tagInput
    connect?: productWhereUniqueInput
    update?: XOR<XOR<productUpdateToOneWithWhereWithoutProduct_tagInput, productUpdateWithoutProduct_tagInput>, productUncheckedUpdateWithoutProduct_tagInput>
  }

  export type tagUpdateOneRequiredWithoutProduct_tagNestedInput = {
    create?: XOR<tagCreateWithoutProduct_tagInput, tagUncheckedCreateWithoutProduct_tagInput>
    connectOrCreate?: tagCreateOrConnectWithoutProduct_tagInput
    upsert?: tagUpsertWithoutProduct_tagInput
    connect?: tagWhereUniqueInput
    update?: XOR<XOR<tagUpdateToOneWithWhereWithoutProduct_tagInput, tagUpdateWithoutProduct_tagInput>, tagUncheckedUpdateWithoutProduct_tagInput>
  }

  export type productCreateNestedOneWithoutProduct_wholesaleInput = {
    create?: XOR<productCreateWithoutProduct_wholesaleInput, productUncheckedCreateWithoutProduct_wholesaleInput>
    connectOrCreate?: productCreateOrConnectWithoutProduct_wholesaleInput
    connect?: productWhereUniqueInput
  }

  export type productUpdateOneRequiredWithoutProduct_wholesaleNestedInput = {
    create?: XOR<productCreateWithoutProduct_wholesaleInput, productUncheckedCreateWithoutProduct_wholesaleInput>
    connectOrCreate?: productCreateOrConnectWithoutProduct_wholesaleInput
    upsert?: productUpsertWithoutProduct_wholesaleInput
    connect?: productWhereUniqueInput
    update?: XOR<XOR<productUpdateToOneWithWhereWithoutProduct_wholesaleInput, productUpdateWithoutProduct_wholesaleInput>, productUncheckedUpdateWithoutProduct_wholesaleInput>
  }

  export type productCreateNestedOneWithoutProduct_option_firstInput = {
    create?: XOR<productCreateWithoutProduct_option_firstInput, productUncheckedCreateWithoutProduct_option_firstInput>
    connectOrCreate?: productCreateOrConnectWithoutProduct_option_firstInput
    connect?: productWhereUniqueInput
  }

  export type product_priceCreateNestedManyWithoutProduct_option_firstInput = {
    create?: XOR<product_priceCreateWithoutProduct_option_firstInput, product_priceUncheckedCreateWithoutProduct_option_firstInput> | product_priceCreateWithoutProduct_option_firstInput[] | product_priceUncheckedCreateWithoutProduct_option_firstInput[]
    connectOrCreate?: product_priceCreateOrConnectWithoutProduct_option_firstInput | product_priceCreateOrConnectWithoutProduct_option_firstInput[]
    createMany?: product_priceCreateManyProduct_option_firstInputEnvelope
    connect?: product_priceWhereUniqueInput | product_priceWhereUniqueInput[]
  }

  export type product_priceUncheckedCreateNestedManyWithoutProduct_option_firstInput = {
    create?: XOR<product_priceCreateWithoutProduct_option_firstInput, product_priceUncheckedCreateWithoutProduct_option_firstInput> | product_priceCreateWithoutProduct_option_firstInput[] | product_priceUncheckedCreateWithoutProduct_option_firstInput[]
    connectOrCreate?: product_priceCreateOrConnectWithoutProduct_option_firstInput | product_priceCreateOrConnectWithoutProduct_option_firstInput[]
    createMany?: product_priceCreateManyProduct_option_firstInputEnvelope
    connect?: product_priceWhereUniqueInput | product_priceWhereUniqueInput[]
  }

  export type productUpdateOneRequiredWithoutProduct_option_firstNestedInput = {
    create?: XOR<productCreateWithoutProduct_option_firstInput, productUncheckedCreateWithoutProduct_option_firstInput>
    connectOrCreate?: productCreateOrConnectWithoutProduct_option_firstInput
    upsert?: productUpsertWithoutProduct_option_firstInput
    connect?: productWhereUniqueInput
    update?: XOR<XOR<productUpdateToOneWithWhereWithoutProduct_option_firstInput, productUpdateWithoutProduct_option_firstInput>, productUncheckedUpdateWithoutProduct_option_firstInput>
  }

  export type product_priceUpdateManyWithoutProduct_option_firstNestedInput = {
    create?: XOR<product_priceCreateWithoutProduct_option_firstInput, product_priceUncheckedCreateWithoutProduct_option_firstInput> | product_priceCreateWithoutProduct_option_firstInput[] | product_priceUncheckedCreateWithoutProduct_option_firstInput[]
    connectOrCreate?: product_priceCreateOrConnectWithoutProduct_option_firstInput | product_priceCreateOrConnectWithoutProduct_option_firstInput[]
    upsert?: product_priceUpsertWithWhereUniqueWithoutProduct_option_firstInput | product_priceUpsertWithWhereUniqueWithoutProduct_option_firstInput[]
    createMany?: product_priceCreateManyProduct_option_firstInputEnvelope
    set?: product_priceWhereUniqueInput | product_priceWhereUniqueInput[]
    disconnect?: product_priceWhereUniqueInput | product_priceWhereUniqueInput[]
    delete?: product_priceWhereUniqueInput | product_priceWhereUniqueInput[]
    connect?: product_priceWhereUniqueInput | product_priceWhereUniqueInput[]
    update?: product_priceUpdateWithWhereUniqueWithoutProduct_option_firstInput | product_priceUpdateWithWhereUniqueWithoutProduct_option_firstInput[]
    updateMany?: product_priceUpdateManyWithWhereWithoutProduct_option_firstInput | product_priceUpdateManyWithWhereWithoutProduct_option_firstInput[]
    deleteMany?: product_priceScalarWhereInput | product_priceScalarWhereInput[]
  }

  export type product_priceUncheckedUpdateManyWithoutProduct_option_firstNestedInput = {
    create?: XOR<product_priceCreateWithoutProduct_option_firstInput, product_priceUncheckedCreateWithoutProduct_option_firstInput> | product_priceCreateWithoutProduct_option_firstInput[] | product_priceUncheckedCreateWithoutProduct_option_firstInput[]
    connectOrCreate?: product_priceCreateOrConnectWithoutProduct_option_firstInput | product_priceCreateOrConnectWithoutProduct_option_firstInput[]
    upsert?: product_priceUpsertWithWhereUniqueWithoutProduct_option_firstInput | product_priceUpsertWithWhereUniqueWithoutProduct_option_firstInput[]
    createMany?: product_priceCreateManyProduct_option_firstInputEnvelope
    set?: product_priceWhereUniqueInput | product_priceWhereUniqueInput[]
    disconnect?: product_priceWhereUniqueInput | product_priceWhereUniqueInput[]
    delete?: product_priceWhereUniqueInput | product_priceWhereUniqueInput[]
    connect?: product_priceWhereUniqueInput | product_priceWhereUniqueInput[]
    update?: product_priceUpdateWithWhereUniqueWithoutProduct_option_firstInput | product_priceUpdateWithWhereUniqueWithoutProduct_option_firstInput[]
    updateMany?: product_priceUpdateManyWithWhereWithoutProduct_option_firstInput | product_priceUpdateManyWithWhereWithoutProduct_option_firstInput[]
    deleteMany?: product_priceScalarWhereInput | product_priceScalarWhereInput[]
  }

  export type productCreateNestedOneWithoutProduct_option_secondInput = {
    create?: XOR<productCreateWithoutProduct_option_secondInput, productUncheckedCreateWithoutProduct_option_secondInput>
    connectOrCreate?: productCreateOrConnectWithoutProduct_option_secondInput
    connect?: productWhereUniqueInput
  }

  export type product_priceCreateNestedManyWithoutProduct_option_secondInput = {
    create?: XOR<product_priceCreateWithoutProduct_option_secondInput, product_priceUncheckedCreateWithoutProduct_option_secondInput> | product_priceCreateWithoutProduct_option_secondInput[] | product_priceUncheckedCreateWithoutProduct_option_secondInput[]
    connectOrCreate?: product_priceCreateOrConnectWithoutProduct_option_secondInput | product_priceCreateOrConnectWithoutProduct_option_secondInput[]
    createMany?: product_priceCreateManyProduct_option_secondInputEnvelope
    connect?: product_priceWhereUniqueInput | product_priceWhereUniqueInput[]
  }

  export type product_priceUncheckedCreateNestedManyWithoutProduct_option_secondInput = {
    create?: XOR<product_priceCreateWithoutProduct_option_secondInput, product_priceUncheckedCreateWithoutProduct_option_secondInput> | product_priceCreateWithoutProduct_option_secondInput[] | product_priceUncheckedCreateWithoutProduct_option_secondInput[]
    connectOrCreate?: product_priceCreateOrConnectWithoutProduct_option_secondInput | product_priceCreateOrConnectWithoutProduct_option_secondInput[]
    createMany?: product_priceCreateManyProduct_option_secondInputEnvelope
    connect?: product_priceWhereUniqueInput | product_priceWhereUniqueInput[]
  }

  export type productUpdateOneRequiredWithoutProduct_option_secondNestedInput = {
    create?: XOR<productCreateWithoutProduct_option_secondInput, productUncheckedCreateWithoutProduct_option_secondInput>
    connectOrCreate?: productCreateOrConnectWithoutProduct_option_secondInput
    upsert?: productUpsertWithoutProduct_option_secondInput
    connect?: productWhereUniqueInput
    update?: XOR<XOR<productUpdateToOneWithWhereWithoutProduct_option_secondInput, productUpdateWithoutProduct_option_secondInput>, productUncheckedUpdateWithoutProduct_option_secondInput>
  }

  export type product_priceUpdateManyWithoutProduct_option_secondNestedInput = {
    create?: XOR<product_priceCreateWithoutProduct_option_secondInput, product_priceUncheckedCreateWithoutProduct_option_secondInput> | product_priceCreateWithoutProduct_option_secondInput[] | product_priceUncheckedCreateWithoutProduct_option_secondInput[]
    connectOrCreate?: product_priceCreateOrConnectWithoutProduct_option_secondInput | product_priceCreateOrConnectWithoutProduct_option_secondInput[]
    upsert?: product_priceUpsertWithWhereUniqueWithoutProduct_option_secondInput | product_priceUpsertWithWhereUniqueWithoutProduct_option_secondInput[]
    createMany?: product_priceCreateManyProduct_option_secondInputEnvelope
    set?: product_priceWhereUniqueInput | product_priceWhereUniqueInput[]
    disconnect?: product_priceWhereUniqueInput | product_priceWhereUniqueInput[]
    delete?: product_priceWhereUniqueInput | product_priceWhereUniqueInput[]
    connect?: product_priceWhereUniqueInput | product_priceWhereUniqueInput[]
    update?: product_priceUpdateWithWhereUniqueWithoutProduct_option_secondInput | product_priceUpdateWithWhereUniqueWithoutProduct_option_secondInput[]
    updateMany?: product_priceUpdateManyWithWhereWithoutProduct_option_secondInput | product_priceUpdateManyWithWhereWithoutProduct_option_secondInput[]
    deleteMany?: product_priceScalarWhereInput | product_priceScalarWhereInput[]
  }

  export type product_priceUncheckedUpdateManyWithoutProduct_option_secondNestedInput = {
    create?: XOR<product_priceCreateWithoutProduct_option_secondInput, product_priceUncheckedCreateWithoutProduct_option_secondInput> | product_priceCreateWithoutProduct_option_secondInput[] | product_priceUncheckedCreateWithoutProduct_option_secondInput[]
    connectOrCreate?: product_priceCreateOrConnectWithoutProduct_option_secondInput | product_priceCreateOrConnectWithoutProduct_option_secondInput[]
    upsert?: product_priceUpsertWithWhereUniqueWithoutProduct_option_secondInput | product_priceUpsertWithWhereUniqueWithoutProduct_option_secondInput[]
    createMany?: product_priceCreateManyProduct_option_secondInputEnvelope
    set?: product_priceWhereUniqueInput | product_priceWhereUniqueInput[]
    disconnect?: product_priceWhereUniqueInput | product_priceWhereUniqueInput[]
    delete?: product_priceWhereUniqueInput | product_priceWhereUniqueInput[]
    connect?: product_priceWhereUniqueInput | product_priceWhereUniqueInput[]
    update?: product_priceUpdateWithWhereUniqueWithoutProduct_option_secondInput | product_priceUpdateWithWhereUniqueWithoutProduct_option_secondInput[]
    updateMany?: product_priceUpdateManyWithWhereWithoutProduct_option_secondInput | product_priceUpdateManyWithWhereWithoutProduct_option_secondInput[]
    deleteMany?: product_priceScalarWhereInput | product_priceScalarWhereInput[]
  }

  export type productCreateNestedOneWithoutProduct_priceInput = {
    create?: XOR<productCreateWithoutProduct_priceInput, productUncheckedCreateWithoutProduct_priceInput>
    connectOrCreate?: productCreateOrConnectWithoutProduct_priceInput
    connect?: productWhereUniqueInput
  }

  export type product_option_firstCreateNestedOneWithoutProduct_priceInput = {
    create?: XOR<product_option_firstCreateWithoutProduct_priceInput, product_option_firstUncheckedCreateWithoutProduct_priceInput>
    connectOrCreate?: product_option_firstCreateOrConnectWithoutProduct_priceInput
    connect?: product_option_firstWhereUniqueInput
  }

  export type product_option_secondCreateNestedOneWithoutProduct_priceInput = {
    create?: XOR<product_option_secondCreateWithoutProduct_priceInput, product_option_secondUncheckedCreateWithoutProduct_priceInput>
    connectOrCreate?: product_option_secondCreateOrConnectWithoutProduct_priceInput
    connect?: product_option_secondWhereUniqueInput
  }

  export type cartCreateNestedManyWithoutProduct_priceInput = {
    create?: XOR<cartCreateWithoutProduct_priceInput, cartUncheckedCreateWithoutProduct_priceInput> | cartCreateWithoutProduct_priceInput[] | cartUncheckedCreateWithoutProduct_priceInput[]
    connectOrCreate?: cartCreateOrConnectWithoutProduct_priceInput | cartCreateOrConnectWithoutProduct_priceInput[]
    createMany?: cartCreateManyProduct_priceInputEnvelope
    connect?: cartWhereUniqueInput | cartWhereUniqueInput[]
  }

  export type order_productCreateNestedManyWithoutProduct_priceInput = {
    create?: XOR<order_productCreateWithoutProduct_priceInput, order_productUncheckedCreateWithoutProduct_priceInput> | order_productCreateWithoutProduct_priceInput[] | order_productUncheckedCreateWithoutProduct_priceInput[]
    connectOrCreate?: order_productCreateOrConnectWithoutProduct_priceInput | order_productCreateOrConnectWithoutProduct_priceInput[]
    createMany?: order_productCreateManyProduct_priceInputEnvelope
    connect?: order_productWhereUniqueInput | order_productWhereUniqueInput[]
  }

  export type cartUncheckedCreateNestedManyWithoutProduct_priceInput = {
    create?: XOR<cartCreateWithoutProduct_priceInput, cartUncheckedCreateWithoutProduct_priceInput> | cartCreateWithoutProduct_priceInput[] | cartUncheckedCreateWithoutProduct_priceInput[]
    connectOrCreate?: cartCreateOrConnectWithoutProduct_priceInput | cartCreateOrConnectWithoutProduct_priceInput[]
    createMany?: cartCreateManyProduct_priceInputEnvelope
    connect?: cartWhereUniqueInput | cartWhereUniqueInput[]
  }

  export type order_productUncheckedCreateNestedManyWithoutProduct_priceInput = {
    create?: XOR<order_productCreateWithoutProduct_priceInput, order_productUncheckedCreateWithoutProduct_priceInput> | order_productCreateWithoutProduct_priceInput[] | order_productUncheckedCreateWithoutProduct_priceInput[]
    connectOrCreate?: order_productCreateOrConnectWithoutProduct_priceInput | order_productCreateOrConnectWithoutProduct_priceInput[]
    createMany?: order_productCreateManyProduct_priceInputEnvelope
    connect?: order_productWhereUniqueInput | order_productWhereUniqueInput[]
  }

  export type productUpdateOneRequiredWithoutProduct_priceNestedInput = {
    create?: XOR<productCreateWithoutProduct_priceInput, productUncheckedCreateWithoutProduct_priceInput>
    connectOrCreate?: productCreateOrConnectWithoutProduct_priceInput
    upsert?: productUpsertWithoutProduct_priceInput
    connect?: productWhereUniqueInput
    update?: XOR<XOR<productUpdateToOneWithWhereWithoutProduct_priceInput, productUpdateWithoutProduct_priceInput>, productUncheckedUpdateWithoutProduct_priceInput>
  }

  export type product_option_firstUpdateOneWithoutProduct_priceNestedInput = {
    create?: XOR<product_option_firstCreateWithoutProduct_priceInput, product_option_firstUncheckedCreateWithoutProduct_priceInput>
    connectOrCreate?: product_option_firstCreateOrConnectWithoutProduct_priceInput
    upsert?: product_option_firstUpsertWithoutProduct_priceInput
    disconnect?: product_option_firstWhereInput | boolean
    delete?: product_option_firstWhereInput | boolean
    connect?: product_option_firstWhereUniqueInput
    update?: XOR<XOR<product_option_firstUpdateToOneWithWhereWithoutProduct_priceInput, product_option_firstUpdateWithoutProduct_priceInput>, product_option_firstUncheckedUpdateWithoutProduct_priceInput>
  }

  export type product_option_secondUpdateOneWithoutProduct_priceNestedInput = {
    create?: XOR<product_option_secondCreateWithoutProduct_priceInput, product_option_secondUncheckedCreateWithoutProduct_priceInput>
    connectOrCreate?: product_option_secondCreateOrConnectWithoutProduct_priceInput
    upsert?: product_option_secondUpsertWithoutProduct_priceInput
    disconnect?: product_option_secondWhereInput | boolean
    delete?: product_option_secondWhereInput | boolean
    connect?: product_option_secondWhereUniqueInput
    update?: XOR<XOR<product_option_secondUpdateToOneWithWhereWithoutProduct_priceInput, product_option_secondUpdateWithoutProduct_priceInput>, product_option_secondUncheckedUpdateWithoutProduct_priceInput>
  }

  export type cartUpdateManyWithoutProduct_priceNestedInput = {
    create?: XOR<cartCreateWithoutProduct_priceInput, cartUncheckedCreateWithoutProduct_priceInput> | cartCreateWithoutProduct_priceInput[] | cartUncheckedCreateWithoutProduct_priceInput[]
    connectOrCreate?: cartCreateOrConnectWithoutProduct_priceInput | cartCreateOrConnectWithoutProduct_priceInput[]
    upsert?: cartUpsertWithWhereUniqueWithoutProduct_priceInput | cartUpsertWithWhereUniqueWithoutProduct_priceInput[]
    createMany?: cartCreateManyProduct_priceInputEnvelope
    set?: cartWhereUniqueInput | cartWhereUniqueInput[]
    disconnect?: cartWhereUniqueInput | cartWhereUniqueInput[]
    delete?: cartWhereUniqueInput | cartWhereUniqueInput[]
    connect?: cartWhereUniqueInput | cartWhereUniqueInput[]
    update?: cartUpdateWithWhereUniqueWithoutProduct_priceInput | cartUpdateWithWhereUniqueWithoutProduct_priceInput[]
    updateMany?: cartUpdateManyWithWhereWithoutProduct_priceInput | cartUpdateManyWithWhereWithoutProduct_priceInput[]
    deleteMany?: cartScalarWhereInput | cartScalarWhereInput[]
  }

  export type order_productUpdateManyWithoutProduct_priceNestedInput = {
    create?: XOR<order_productCreateWithoutProduct_priceInput, order_productUncheckedCreateWithoutProduct_priceInput> | order_productCreateWithoutProduct_priceInput[] | order_productUncheckedCreateWithoutProduct_priceInput[]
    connectOrCreate?: order_productCreateOrConnectWithoutProduct_priceInput | order_productCreateOrConnectWithoutProduct_priceInput[]
    upsert?: order_productUpsertWithWhereUniqueWithoutProduct_priceInput | order_productUpsertWithWhereUniqueWithoutProduct_priceInput[]
    createMany?: order_productCreateManyProduct_priceInputEnvelope
    set?: order_productWhereUniqueInput | order_productWhereUniqueInput[]
    disconnect?: order_productWhereUniqueInput | order_productWhereUniqueInput[]
    delete?: order_productWhereUniqueInput | order_productWhereUniqueInput[]
    connect?: order_productWhereUniqueInput | order_productWhereUniqueInput[]
    update?: order_productUpdateWithWhereUniqueWithoutProduct_priceInput | order_productUpdateWithWhereUniqueWithoutProduct_priceInput[]
    updateMany?: order_productUpdateManyWithWhereWithoutProduct_priceInput | order_productUpdateManyWithWhereWithoutProduct_priceInput[]
    deleteMany?: order_productScalarWhereInput | order_productScalarWhereInput[]
  }

  export type cartUncheckedUpdateManyWithoutProduct_priceNestedInput = {
    create?: XOR<cartCreateWithoutProduct_priceInput, cartUncheckedCreateWithoutProduct_priceInput> | cartCreateWithoutProduct_priceInput[] | cartUncheckedCreateWithoutProduct_priceInput[]
    connectOrCreate?: cartCreateOrConnectWithoutProduct_priceInput | cartCreateOrConnectWithoutProduct_priceInput[]
    upsert?: cartUpsertWithWhereUniqueWithoutProduct_priceInput | cartUpsertWithWhereUniqueWithoutProduct_priceInput[]
    createMany?: cartCreateManyProduct_priceInputEnvelope
    set?: cartWhereUniqueInput | cartWhereUniqueInput[]
    disconnect?: cartWhereUniqueInput | cartWhereUniqueInput[]
    delete?: cartWhereUniqueInput | cartWhereUniqueInput[]
    connect?: cartWhereUniqueInput | cartWhereUniqueInput[]
    update?: cartUpdateWithWhereUniqueWithoutProduct_priceInput | cartUpdateWithWhereUniqueWithoutProduct_priceInput[]
    updateMany?: cartUpdateManyWithWhereWithoutProduct_priceInput | cartUpdateManyWithWhereWithoutProduct_priceInput[]
    deleteMany?: cartScalarWhereInput | cartScalarWhereInput[]
  }

  export type order_productUncheckedUpdateManyWithoutProduct_priceNestedInput = {
    create?: XOR<order_productCreateWithoutProduct_priceInput, order_productUncheckedCreateWithoutProduct_priceInput> | order_productCreateWithoutProduct_priceInput[] | order_productUncheckedCreateWithoutProduct_priceInput[]
    connectOrCreate?: order_productCreateOrConnectWithoutProduct_priceInput | order_productCreateOrConnectWithoutProduct_priceInput[]
    upsert?: order_productUpsertWithWhereUniqueWithoutProduct_priceInput | order_productUpsertWithWhereUniqueWithoutProduct_priceInput[]
    createMany?: order_productCreateManyProduct_priceInputEnvelope
    set?: order_productWhereUniqueInput | order_productWhereUniqueInput[]
    disconnect?: order_productWhereUniqueInput | order_productWhereUniqueInput[]
    delete?: order_productWhereUniqueInput | order_productWhereUniqueInput[]
    connect?: order_productWhereUniqueInput | order_productWhereUniqueInput[]
    update?: order_productUpdateWithWhereUniqueWithoutProduct_priceInput | order_productUpdateWithWhereUniqueWithoutProduct_priceInput[]
    updateMany?: order_productUpdateManyWithWhereWithoutProduct_priceInput | order_productUpdateManyWithWhereWithoutProduct_priceInput[]
    deleteMany?: order_productScalarWhereInput | order_productScalarWhereInput[]
  }

  export type productCreateNestedOneWithoutProduct_detailInput = {
    create?: XOR<productCreateWithoutProduct_detailInput, productUncheckedCreateWithoutProduct_detailInput>
    connectOrCreate?: productCreateOrConnectWithoutProduct_detailInput
    connect?: productWhereUniqueInput
  }

  export type productUpdateOneRequiredWithoutProduct_detailNestedInput = {
    create?: XOR<productCreateWithoutProduct_detailInput, productUncheckedCreateWithoutProduct_detailInput>
    connectOrCreate?: productCreateOrConnectWithoutProduct_detailInput
    upsert?: productUpsertWithoutProduct_detailInput
    connect?: productWhereUniqueInput
    update?: XOR<XOR<productUpdateToOneWithWhereWithoutProduct_detailInput, productUpdateWithoutProduct_detailInput>, productUncheckedUpdateWithoutProduct_detailInput>
  }

  export type productCreateNestedOneWithoutProduct_imageInput = {
    create?: XOR<productCreateWithoutProduct_imageInput, productUncheckedCreateWithoutProduct_imageInput>
    connectOrCreate?: productCreateOrConnectWithoutProduct_imageInput
    connect?: productWhereUniqueInput
  }

  export type productUpdateOneRequiredWithoutProduct_imageNestedInput = {
    create?: XOR<productCreateWithoutProduct_imageInput, productUncheckedCreateWithoutProduct_imageInput>
    connectOrCreate?: productCreateOrConnectWithoutProduct_imageInput
    upsert?: productUpsertWithoutProduct_imageInput
    connect?: productWhereUniqueInput
    update?: XOR<XOR<productUpdateToOneWithWhereWithoutProduct_imageInput, productUpdateWithoutProduct_imageInput>, productUncheckedUpdateWithoutProduct_imageInput>
  }

  export type productCreateNestedOneWithoutProduct_specInput = {
    create?: XOR<productCreateWithoutProduct_specInput, productUncheckedCreateWithoutProduct_specInput>
    connectOrCreate?: productCreateOrConnectWithoutProduct_specInput
    connect?: productWhereUniqueInput
  }

  export type productUpdateOneRequiredWithoutProduct_specNestedInput = {
    create?: XOR<productCreateWithoutProduct_specInput, productUncheckedCreateWithoutProduct_specInput>
    connectOrCreate?: productCreateOrConnectWithoutProduct_specInput
    upsert?: productUpsertWithoutProduct_specInput
    connect?: productWhereUniqueInput
    update?: XOR<XOR<productUpdateToOneWithWhereWithoutProduct_specInput, productUpdateWithoutProduct_specInput>, productUncheckedUpdateWithoutProduct_specInput>
  }

  export type userCreateNestedOneWithoutCartInput = {
    create?: XOR<userCreateWithoutCartInput, userUncheckedCreateWithoutCartInput>
    connectOrCreate?: userCreateOrConnectWithoutCartInput
    connect?: userWhereUniqueInput
  }

  export type productCreateNestedOneWithoutCartInput = {
    create?: XOR<productCreateWithoutCartInput, productUncheckedCreateWithoutCartInput>
    connectOrCreate?: productCreateOrConnectWithoutCartInput
    connect?: productWhereUniqueInput
  }

  export type product_priceCreateNestedOneWithoutCartInput = {
    create?: XOR<product_priceCreateWithoutCartInput, product_priceUncheckedCreateWithoutCartInput>
    connectOrCreate?: product_priceCreateOrConnectWithoutCartInput
    connect?: product_priceWhereUniqueInput
  }

  export type userUpdateOneRequiredWithoutCartNestedInput = {
    create?: XOR<userCreateWithoutCartInput, userUncheckedCreateWithoutCartInput>
    connectOrCreate?: userCreateOrConnectWithoutCartInput
    upsert?: userUpsertWithoutCartInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutCartInput, userUpdateWithoutCartInput>, userUncheckedUpdateWithoutCartInput>
  }

  export type productUpdateOneRequiredWithoutCartNestedInput = {
    create?: XOR<productCreateWithoutCartInput, productUncheckedCreateWithoutCartInput>
    connectOrCreate?: productCreateOrConnectWithoutCartInput
    upsert?: productUpsertWithoutCartInput
    connect?: productWhereUniqueInput
    update?: XOR<XOR<productUpdateToOneWithWhereWithoutCartInput, productUpdateWithoutCartInput>, productUncheckedUpdateWithoutCartInput>
  }

  export type product_priceUpdateOneRequiredWithoutCartNestedInput = {
    create?: XOR<product_priceCreateWithoutCartInput, product_priceUncheckedCreateWithoutCartInput>
    connectOrCreate?: product_priceCreateOrConnectWithoutCartInput
    upsert?: product_priceUpsertWithoutCartInput
    connect?: product_priceWhereUniqueInput
    update?: XOR<XOR<product_priceUpdateToOneWithWhereWithoutCartInput, product_priceUpdateWithoutCartInput>, product_priceUncheckedUpdateWithoutCartInput>
  }

  export type userCreateNestedOneWithoutOrderInput = {
    create?: XOR<userCreateWithoutOrderInput, userUncheckedCreateWithoutOrderInput>
    connectOrCreate?: userCreateOrConnectWithoutOrderInput
    connect?: userWhereUniqueInput
  }

  export type addressCreateNestedOneWithoutOrderInput = {
    create?: XOR<addressCreateWithoutOrderInput, addressUncheckedCreateWithoutOrderInput>
    connectOrCreate?: addressCreateOrConnectWithoutOrderInput
    connect?: addressWhereUniqueInput
  }

  export type order_productCreateNestedManyWithoutOrderInput = {
    create?: XOR<order_productCreateWithoutOrderInput, order_productUncheckedCreateWithoutOrderInput> | order_productCreateWithoutOrderInput[] | order_productUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: order_productCreateOrConnectWithoutOrderInput | order_productCreateOrConnectWithoutOrderInput[]
    createMany?: order_productCreateManyOrderInputEnvelope
    connect?: order_productWhereUniqueInput | order_productWhereUniqueInput[]
  }

  export type order_productUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<order_productCreateWithoutOrderInput, order_productUncheckedCreateWithoutOrderInput> | order_productCreateWithoutOrderInput[] | order_productUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: order_productCreateOrConnectWithoutOrderInput | order_productCreateOrConnectWithoutOrderInput[]
    createMany?: order_productCreateManyOrderInputEnvelope
    connect?: order_productWhereUniqueInput | order_productWhereUniqueInput[]
  }

  export type userUpdateOneRequiredWithoutOrderNestedInput = {
    create?: XOR<userCreateWithoutOrderInput, userUncheckedCreateWithoutOrderInput>
    connectOrCreate?: userCreateOrConnectWithoutOrderInput
    upsert?: userUpsertWithoutOrderInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutOrderInput, userUpdateWithoutOrderInput>, userUncheckedUpdateWithoutOrderInput>
  }

  export type addressUpdateOneRequiredWithoutOrderNestedInput = {
    create?: XOR<addressCreateWithoutOrderInput, addressUncheckedCreateWithoutOrderInput>
    connectOrCreate?: addressCreateOrConnectWithoutOrderInput
    upsert?: addressUpsertWithoutOrderInput
    connect?: addressWhereUniqueInput
    update?: XOR<XOR<addressUpdateToOneWithWhereWithoutOrderInput, addressUpdateWithoutOrderInput>, addressUncheckedUpdateWithoutOrderInput>
  }

  export type order_productUpdateManyWithoutOrderNestedInput = {
    create?: XOR<order_productCreateWithoutOrderInput, order_productUncheckedCreateWithoutOrderInput> | order_productCreateWithoutOrderInput[] | order_productUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: order_productCreateOrConnectWithoutOrderInput | order_productCreateOrConnectWithoutOrderInput[]
    upsert?: order_productUpsertWithWhereUniqueWithoutOrderInput | order_productUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: order_productCreateManyOrderInputEnvelope
    set?: order_productWhereUniqueInput | order_productWhereUniqueInput[]
    disconnect?: order_productWhereUniqueInput | order_productWhereUniqueInput[]
    delete?: order_productWhereUniqueInput | order_productWhereUniqueInput[]
    connect?: order_productWhereUniqueInput | order_productWhereUniqueInput[]
    update?: order_productUpdateWithWhereUniqueWithoutOrderInput | order_productUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: order_productUpdateManyWithWhereWithoutOrderInput | order_productUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: order_productScalarWhereInput | order_productScalarWhereInput[]
  }

  export type order_productUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<order_productCreateWithoutOrderInput, order_productUncheckedCreateWithoutOrderInput> | order_productCreateWithoutOrderInput[] | order_productUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: order_productCreateOrConnectWithoutOrderInput | order_productCreateOrConnectWithoutOrderInput[]
    upsert?: order_productUpsertWithWhereUniqueWithoutOrderInput | order_productUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: order_productCreateManyOrderInputEnvelope
    set?: order_productWhereUniqueInput | order_productWhereUniqueInput[]
    disconnect?: order_productWhereUniqueInput | order_productWhereUniqueInput[]
    delete?: order_productWhereUniqueInput | order_productWhereUniqueInput[]
    connect?: order_productWhereUniqueInput | order_productWhereUniqueInput[]
    update?: order_productUpdateWithWhereUniqueWithoutOrderInput | order_productUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: order_productUpdateManyWithWhereWithoutOrderInput | order_productUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: order_productScalarWhereInput | order_productScalarWhereInput[]
  }

  export type userCreateNestedOneWithoutOrder_productInput = {
    create?: XOR<userCreateWithoutOrder_productInput, userUncheckedCreateWithoutOrder_productInput>
    connectOrCreate?: userCreateOrConnectWithoutOrder_productInput
    connect?: userWhereUniqueInput
  }

  export type productCreateNestedOneWithoutOrder_productInput = {
    create?: XOR<productCreateWithoutOrder_productInput, productUncheckedCreateWithoutOrder_productInput>
    connectOrCreate?: productCreateOrConnectWithoutOrder_productInput
    connect?: productWhereUniqueInput
  }

  export type orderCreateNestedOneWithoutOrder_productInput = {
    create?: XOR<orderCreateWithoutOrder_productInput, orderUncheckedCreateWithoutOrder_productInput>
    connectOrCreate?: orderCreateOrConnectWithoutOrder_productInput
    connect?: orderWhereUniqueInput
  }

  export type product_priceCreateNestedOneWithoutOrder_productInput = {
    create?: XOR<product_priceCreateWithoutOrder_productInput, product_priceUncheckedCreateWithoutOrder_productInput>
    connectOrCreate?: product_priceCreateOrConnectWithoutOrder_productInput
    connect?: product_priceWhereUniqueInput
  }

  export type userUpdateOneRequiredWithoutOrder_productNestedInput = {
    create?: XOR<userCreateWithoutOrder_productInput, userUncheckedCreateWithoutOrder_productInput>
    connectOrCreate?: userCreateOrConnectWithoutOrder_productInput
    upsert?: userUpsertWithoutOrder_productInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutOrder_productInput, userUpdateWithoutOrder_productInput>, userUncheckedUpdateWithoutOrder_productInput>
  }

  export type productUpdateOneRequiredWithoutOrder_productNestedInput = {
    create?: XOR<productCreateWithoutOrder_productInput, productUncheckedCreateWithoutOrder_productInput>
    connectOrCreate?: productCreateOrConnectWithoutOrder_productInput
    upsert?: productUpsertWithoutOrder_productInput
    connect?: productWhereUniqueInput
    update?: XOR<XOR<productUpdateToOneWithWhereWithoutOrder_productInput, productUpdateWithoutOrder_productInput>, productUncheckedUpdateWithoutOrder_productInput>
  }

  export type orderUpdateOneRequiredWithoutOrder_productNestedInput = {
    create?: XOR<orderCreateWithoutOrder_productInput, orderUncheckedCreateWithoutOrder_productInput>
    connectOrCreate?: orderCreateOrConnectWithoutOrder_productInput
    upsert?: orderUpsertWithoutOrder_productInput
    connect?: orderWhereUniqueInput
    update?: XOR<XOR<orderUpdateToOneWithWhereWithoutOrder_productInput, orderUpdateWithoutOrder_productInput>, orderUncheckedUpdateWithoutOrder_productInput>
  }

  export type product_priceUpdateOneRequiredWithoutOrder_productNestedInput = {
    create?: XOR<product_priceCreateWithoutOrder_productInput, product_priceUncheckedCreateWithoutOrder_productInput>
    connectOrCreate?: product_priceCreateOrConnectWithoutOrder_productInput
    upsert?: product_priceUpsertWithoutOrder_productInput
    connect?: product_priceWhereUniqueInput
    update?: XOR<XOR<product_priceUpdateToOneWithWhereWithoutOrder_productInput, product_priceUpdateWithoutOrder_productInput>, product_priceUncheckedUpdateWithoutOrder_productInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type user_credit_transactionCreateWithoutAdminInput = {
    updateBy: string
    updateType: string
    beforeUpdate: number
    afterUpdate: number
    credit: number
    remark?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: userCreateNestedOneWithoutUser_credit_transactionInput
  }

  export type user_credit_transactionUncheckedCreateWithoutAdminInput = {
    id?: number
    userId: number
    updateBy: string
    updateType: string
    beforeUpdate: number
    afterUpdate: number
    credit: number
    remark?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type user_credit_transactionCreateOrConnectWithoutAdminInput = {
    where: user_credit_transactionWhereUniqueInput
    create: XOR<user_credit_transactionCreateWithoutAdminInput, user_credit_transactionUncheckedCreateWithoutAdminInput>
  }

  export type user_credit_transactionCreateManyAdminInputEnvelope = {
    data: user_credit_transactionCreateManyAdminInput | user_credit_transactionCreateManyAdminInput[]
    skipDuplicates?: boolean
  }

  export type user_point_transactionCreateWithoutAdminInput = {
    updateBy: string
    updateType: string
    beforeUpdate: number
    afterUpdate: number
    point: number
    remark?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: userCreateNestedOneWithoutUser_point_transactionInput
  }

  export type user_point_transactionUncheckedCreateWithoutAdminInput = {
    id?: number
    userId: number
    updateBy: string
    updateType: string
    beforeUpdate: number
    afterUpdate: number
    point: number
    remark?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type user_point_transactionCreateOrConnectWithoutAdminInput = {
    where: user_point_transactionWhereUniqueInput
    create: XOR<user_point_transactionCreateWithoutAdminInput, user_point_transactionUncheckedCreateWithoutAdminInput>
  }

  export type user_point_transactionCreateManyAdminInputEnvelope = {
    data: user_point_transactionCreateManyAdminInput | user_point_transactionCreateManyAdminInput[]
    skipDuplicates?: boolean
  }

  export type product_reviewCreateWithoutAdminInput = {
    detail?: string | null
    rating?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: userCreateNestedOneWithoutProduct_reviewInput
    product: productCreateNestedOneWithoutProduct_reviewInput
  }

  export type product_reviewUncheckedCreateWithoutAdminInput = {
    id?: number
    userId: number
    productId: number
    detail?: string | null
    rating?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type product_reviewCreateOrConnectWithoutAdminInput = {
    where: product_reviewWhereUniqueInput
    create: XOR<product_reviewCreateWithoutAdminInput, product_reviewUncheckedCreateWithoutAdminInput>
  }

  export type product_reviewCreateManyAdminInputEnvelope = {
    data: product_reviewCreateManyAdminInput | product_reviewCreateManyAdminInput[]
    skipDuplicates?: boolean
  }

  export type productCreateWithoutAdminInput = {
    name: string
    shortName?: string | null
    detail?: string | null
    isDiscount?: boolean
    discountPercent: number
    minPrice: number
    maxPrice: number
    slug: string
    cardImgPath: string
    cardImgSrc: string
    optionFirst?: string | null
    optionSecond?: string | null
    isWholesale?: boolean
    rating?: number
    sold?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    brand: brandCreateNestedOneWithoutProductInput
    product_image?: product_imageCreateNestedManyWithoutProductInput
    product_spec?: product_specCreateNestedManyWithoutProductInput
    product_detail?: product_detailCreateNestedManyWithoutProductInput
    product_option_first?: product_option_firstCreateNestedManyWithoutProductInput
    product_option_second?: product_option_secondCreateNestedManyWithoutProductInput
    product_price?: product_priceCreateNestedManyWithoutProductInput
    product_wholesale?: product_wholesaleCreateNestedManyWithoutProductInput
    product_review?: product_reviewCreateNestedManyWithoutProductInput
    product_tag?: product_tagCreateNestedManyWithoutProductInput
    cart?: cartCreateNestedManyWithoutProductInput
    order_product?: order_productCreateNestedManyWithoutProductInput
  }

  export type productUncheckedCreateWithoutAdminInput = {
    id?: number
    brandId: number
    name: string
    shortName?: string | null
    detail?: string | null
    isDiscount?: boolean
    discountPercent: number
    minPrice: number
    maxPrice: number
    slug: string
    cardImgPath: string
    cardImgSrc: string
    optionFirst?: string | null
    optionSecond?: string | null
    isWholesale?: boolean
    rating?: number
    sold?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    product_image?: product_imageUncheckedCreateNestedManyWithoutProductInput
    product_spec?: product_specUncheckedCreateNestedManyWithoutProductInput
    product_detail?: product_detailUncheckedCreateNestedManyWithoutProductInput
    product_option_first?: product_option_firstUncheckedCreateNestedManyWithoutProductInput
    product_option_second?: product_option_secondUncheckedCreateNestedManyWithoutProductInput
    product_price?: product_priceUncheckedCreateNestedManyWithoutProductInput
    product_wholesale?: product_wholesaleUncheckedCreateNestedManyWithoutProductInput
    product_review?: product_reviewUncheckedCreateNestedManyWithoutProductInput
    product_tag?: product_tagUncheckedCreateNestedManyWithoutProductInput
    cart?: cartUncheckedCreateNestedManyWithoutProductInput
    order_product?: order_productUncheckedCreateNestedManyWithoutProductInput
  }

  export type productCreateOrConnectWithoutAdminInput = {
    where: productWhereUniqueInput
    create: XOR<productCreateWithoutAdminInput, productUncheckedCreateWithoutAdminInput>
  }

  export type productCreateManyAdminInputEnvelope = {
    data: productCreateManyAdminInput | productCreateManyAdminInput[]
    skipDuplicates?: boolean
  }

  export type user_credit_transactionUpsertWithWhereUniqueWithoutAdminInput = {
    where: user_credit_transactionWhereUniqueInput
    update: XOR<user_credit_transactionUpdateWithoutAdminInput, user_credit_transactionUncheckedUpdateWithoutAdminInput>
    create: XOR<user_credit_transactionCreateWithoutAdminInput, user_credit_transactionUncheckedCreateWithoutAdminInput>
  }

  export type user_credit_transactionUpdateWithWhereUniqueWithoutAdminInput = {
    where: user_credit_transactionWhereUniqueInput
    data: XOR<user_credit_transactionUpdateWithoutAdminInput, user_credit_transactionUncheckedUpdateWithoutAdminInput>
  }

  export type user_credit_transactionUpdateManyWithWhereWithoutAdminInput = {
    where: user_credit_transactionScalarWhereInput
    data: XOR<user_credit_transactionUpdateManyMutationInput, user_credit_transactionUncheckedUpdateManyWithoutAdminInput>
  }

  export type user_credit_transactionScalarWhereInput = {
    AND?: user_credit_transactionScalarWhereInput | user_credit_transactionScalarWhereInput[]
    OR?: user_credit_transactionScalarWhereInput[]
    NOT?: user_credit_transactionScalarWhereInput | user_credit_transactionScalarWhereInput[]
    id?: IntFilter<"user_credit_transaction"> | number
    userId?: IntFilter<"user_credit_transaction"> | number
    adminId?: IntNullableFilter<"user_credit_transaction"> | number | null
    updateBy?: StringFilter<"user_credit_transaction"> | string
    updateType?: StringFilter<"user_credit_transaction"> | string
    beforeUpdate?: FloatFilter<"user_credit_transaction"> | number
    afterUpdate?: FloatFilter<"user_credit_transaction"> | number
    credit?: FloatFilter<"user_credit_transaction"> | number
    remark?: StringNullableFilter<"user_credit_transaction"> | string | null
    isActive?: BoolFilter<"user_credit_transaction"> | boolean
    createdAt?: DateTimeFilter<"user_credit_transaction"> | Date | string
    updatedAt?: DateTimeFilter<"user_credit_transaction"> | Date | string
  }

  export type user_point_transactionUpsertWithWhereUniqueWithoutAdminInput = {
    where: user_point_transactionWhereUniqueInput
    update: XOR<user_point_transactionUpdateWithoutAdminInput, user_point_transactionUncheckedUpdateWithoutAdminInput>
    create: XOR<user_point_transactionCreateWithoutAdminInput, user_point_transactionUncheckedCreateWithoutAdminInput>
  }

  export type user_point_transactionUpdateWithWhereUniqueWithoutAdminInput = {
    where: user_point_transactionWhereUniqueInput
    data: XOR<user_point_transactionUpdateWithoutAdminInput, user_point_transactionUncheckedUpdateWithoutAdminInput>
  }

  export type user_point_transactionUpdateManyWithWhereWithoutAdminInput = {
    where: user_point_transactionScalarWhereInput
    data: XOR<user_point_transactionUpdateManyMutationInput, user_point_transactionUncheckedUpdateManyWithoutAdminInput>
  }

  export type user_point_transactionScalarWhereInput = {
    AND?: user_point_transactionScalarWhereInput | user_point_transactionScalarWhereInput[]
    OR?: user_point_transactionScalarWhereInput[]
    NOT?: user_point_transactionScalarWhereInput | user_point_transactionScalarWhereInput[]
    id?: IntFilter<"user_point_transaction"> | number
    userId?: IntFilter<"user_point_transaction"> | number
    adminId?: IntNullableFilter<"user_point_transaction"> | number | null
    updateBy?: StringFilter<"user_point_transaction"> | string
    updateType?: StringFilter<"user_point_transaction"> | string
    beforeUpdate?: FloatFilter<"user_point_transaction"> | number
    afterUpdate?: FloatFilter<"user_point_transaction"> | number
    point?: FloatFilter<"user_point_transaction"> | number
    remark?: StringNullableFilter<"user_point_transaction"> | string | null
    isActive?: BoolFilter<"user_point_transaction"> | boolean
    createdAt?: DateTimeFilter<"user_point_transaction"> | Date | string
    updatedAt?: DateTimeFilter<"user_point_transaction"> | Date | string
  }

  export type product_reviewUpsertWithWhereUniqueWithoutAdminInput = {
    where: product_reviewWhereUniqueInput
    update: XOR<product_reviewUpdateWithoutAdminInput, product_reviewUncheckedUpdateWithoutAdminInput>
    create: XOR<product_reviewCreateWithoutAdminInput, product_reviewUncheckedCreateWithoutAdminInput>
  }

  export type product_reviewUpdateWithWhereUniqueWithoutAdminInput = {
    where: product_reviewWhereUniqueInput
    data: XOR<product_reviewUpdateWithoutAdminInput, product_reviewUncheckedUpdateWithoutAdminInput>
  }

  export type product_reviewUpdateManyWithWhereWithoutAdminInput = {
    where: product_reviewScalarWhereInput
    data: XOR<product_reviewUpdateManyMutationInput, product_reviewUncheckedUpdateManyWithoutAdminInput>
  }

  export type product_reviewScalarWhereInput = {
    AND?: product_reviewScalarWhereInput | product_reviewScalarWhereInput[]
    OR?: product_reviewScalarWhereInput[]
    NOT?: product_reviewScalarWhereInput | product_reviewScalarWhereInput[]
    id?: IntFilter<"product_review"> | number
    userId?: IntFilter<"product_review"> | number
    productId?: IntFilter<"product_review"> | number
    adminId?: IntFilter<"product_review"> | number
    detail?: StringNullableFilter<"product_review"> | string | null
    rating?: IntFilter<"product_review"> | number
    isActive?: BoolFilter<"product_review"> | boolean
    createdAt?: DateTimeFilter<"product_review"> | Date | string
    updatedAt?: DateTimeFilter<"product_review"> | Date | string
  }

  export type productUpsertWithWhereUniqueWithoutAdminInput = {
    where: productWhereUniqueInput
    update: XOR<productUpdateWithoutAdminInput, productUncheckedUpdateWithoutAdminInput>
    create: XOR<productCreateWithoutAdminInput, productUncheckedCreateWithoutAdminInput>
  }

  export type productUpdateWithWhereUniqueWithoutAdminInput = {
    where: productWhereUniqueInput
    data: XOR<productUpdateWithoutAdminInput, productUncheckedUpdateWithoutAdminInput>
  }

  export type productUpdateManyWithWhereWithoutAdminInput = {
    where: productScalarWhereInput
    data: XOR<productUpdateManyMutationInput, productUncheckedUpdateManyWithoutAdminInput>
  }

  export type productScalarWhereInput = {
    AND?: productScalarWhereInput | productScalarWhereInput[]
    OR?: productScalarWhereInput[]
    NOT?: productScalarWhereInput | productScalarWhereInput[]
    id?: IntFilter<"product"> | number
    brandId?: IntFilter<"product"> | number
    adminId?: IntFilter<"product"> | number
    name?: StringFilter<"product"> | string
    shortName?: StringNullableFilter<"product"> | string | null
    detail?: StringNullableFilter<"product"> | string | null
    isDiscount?: BoolFilter<"product"> | boolean
    discountPercent?: IntFilter<"product"> | number
    minPrice?: FloatFilter<"product"> | number
    maxPrice?: FloatFilter<"product"> | number
    slug?: StringFilter<"product"> | string
    cardImgPath?: StringFilter<"product"> | string
    cardImgSrc?: StringFilter<"product"> | string
    optionFirst?: StringNullableFilter<"product"> | string | null
    optionSecond?: StringNullableFilter<"product"> | string | null
    isWholesale?: BoolFilter<"product"> | boolean
    rating?: IntFilter<"product"> | number
    sold?: IntFilter<"product"> | number
    isActive?: BoolFilter<"product"> | boolean
    createdAt?: DateTimeFilter<"product"> | Date | string
    updatedAt?: DateTimeFilter<"product"> | Date | string
  }

  export type addressCreateWithoutUserInput = {
    default?: boolean
    addressName: string
    details?: string | null
    remarks?: string | null
    receiverFname: string
    receiverLname: string
    receiverFullname: string
    receiverPhone: string
    houseNo: string
    villageNo?: string | null
    road?: string | null
    province: string
    district: string
    subDistrict: string
    postCode: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    order?: orderCreateNestedManyWithoutAddressInput
  }

  export type addressUncheckedCreateWithoutUserInput = {
    id?: number
    default?: boolean
    addressName: string
    details?: string | null
    remarks?: string | null
    receiverFname: string
    receiverLname: string
    receiverFullname: string
    receiverPhone: string
    houseNo: string
    villageNo?: string | null
    road?: string | null
    province: string
    district: string
    subDistrict: string
    postCode: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    order?: orderUncheckedCreateNestedManyWithoutAddressInput
  }

  export type addressCreateOrConnectWithoutUserInput = {
    where: addressWhereUniqueInput
    create: XOR<addressCreateWithoutUserInput, addressUncheckedCreateWithoutUserInput>
  }

  export type addressCreateManyUserInputEnvelope = {
    data: addressCreateManyUserInput | addressCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type user_credit_transactionCreateWithoutUserInput = {
    updateBy: string
    updateType: string
    beforeUpdate: number
    afterUpdate: number
    credit: number
    remark?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    admin?: adminCreateNestedOneWithoutUser_credit_transactionInput
  }

  export type user_credit_transactionUncheckedCreateWithoutUserInput = {
    id?: number
    adminId?: number | null
    updateBy: string
    updateType: string
    beforeUpdate: number
    afterUpdate: number
    credit: number
    remark?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type user_credit_transactionCreateOrConnectWithoutUserInput = {
    where: user_credit_transactionWhereUniqueInput
    create: XOR<user_credit_transactionCreateWithoutUserInput, user_credit_transactionUncheckedCreateWithoutUserInput>
  }

  export type user_credit_transactionCreateManyUserInputEnvelope = {
    data: user_credit_transactionCreateManyUserInput | user_credit_transactionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type payment_transactionCreateWithoutUserInput = {
    price: number
    refCode: string
    status?: string
    base64?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type payment_transactionUncheckedCreateWithoutUserInput = {
    id?: number
    price: number
    refCode: string
    status?: string
    base64?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type payment_transactionCreateOrConnectWithoutUserInput = {
    where: payment_transactionWhereUniqueInput
    create: XOR<payment_transactionCreateWithoutUserInput, payment_transactionUncheckedCreateWithoutUserInput>
  }

  export type payment_transactionCreateManyUserInputEnvelope = {
    data: payment_transactionCreateManyUserInput | payment_transactionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type user_point_transactionCreateWithoutUserInput = {
    updateBy: string
    updateType: string
    beforeUpdate: number
    afterUpdate: number
    point: number
    remark?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    admin?: adminCreateNestedOneWithoutUser_point_transactionInput
  }

  export type user_point_transactionUncheckedCreateWithoutUserInput = {
    id?: number
    adminId?: number | null
    updateBy: string
    updateType: string
    beforeUpdate: number
    afterUpdate: number
    point: number
    remark?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type user_point_transactionCreateOrConnectWithoutUserInput = {
    where: user_point_transactionWhereUniqueInput
    create: XOR<user_point_transactionCreateWithoutUserInput, user_point_transactionUncheckedCreateWithoutUserInput>
  }

  export type user_point_transactionCreateManyUserInputEnvelope = {
    data: user_point_transactionCreateManyUserInput | user_point_transactionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type product_reviewCreateWithoutUserInput = {
    detail?: string | null
    rating?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    product: productCreateNestedOneWithoutProduct_reviewInput
    admin: adminCreateNestedOneWithoutProduct_reviewInput
  }

  export type product_reviewUncheckedCreateWithoutUserInput = {
    id?: number
    productId: number
    adminId: number
    detail?: string | null
    rating?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type product_reviewCreateOrConnectWithoutUserInput = {
    where: product_reviewWhereUniqueInput
    create: XOR<product_reviewCreateWithoutUserInput, product_reviewUncheckedCreateWithoutUserInput>
  }

  export type product_reviewCreateManyUserInputEnvelope = {
    data: product_reviewCreateManyUserInput | product_reviewCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type cartCreateWithoutUserInput = {
    qty: number
    price: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    product: productCreateNestedOneWithoutCartInput
    product_price: product_priceCreateNestedOneWithoutCartInput
  }

  export type cartUncheckedCreateWithoutUserInput = {
    id?: number
    productId: number
    product_priceId: number
    qty: number
    price: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type cartCreateOrConnectWithoutUserInput = {
    where: cartWhereUniqueInput
    create: XOR<cartCreateWithoutUserInput, cartUncheckedCreateWithoutUserInput>
  }

  export type cartCreateManyUserInputEnvelope = {
    data: cartCreateManyUserInput | cartCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type orderCreateWithoutUserInput = {
    statusNow?: string
    status: JsonNullValueInput | InputJsonValue
    paymentType: string
    paymentStatus?: string
    createUsing?: number
    pointUsing?: number
    orderPrice: number
    deliveryPrice: number
    netPrice: number
    orderDiscount: number
    deliveryDiscount: number
    orderDiscountCode: string
    deliveryDiscountCode: string
    addressData: JsonNullValueInput | InputJsonValue
    userData: JsonNullValueInput | InputJsonValue
    isReject?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    address: addressCreateNestedOneWithoutOrderInput
    order_product?: order_productCreateNestedManyWithoutOrderInput
  }

  export type orderUncheckedCreateWithoutUserInput = {
    id?: number
    statusNow?: string
    status: JsonNullValueInput | InputJsonValue
    paymentType: string
    paymentStatus?: string
    createUsing?: number
    pointUsing?: number
    orderPrice: number
    deliveryPrice: number
    netPrice: number
    orderDiscount: number
    deliveryDiscount: number
    orderDiscountCode: string
    deliveryDiscountCode: string
    addressId: number
    addressData: JsonNullValueInput | InputJsonValue
    userData: JsonNullValueInput | InputJsonValue
    isReject?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    order_product?: order_productUncheckedCreateNestedManyWithoutOrderInput
  }

  export type orderCreateOrConnectWithoutUserInput = {
    where: orderWhereUniqueInput
    create: XOR<orderCreateWithoutUserInput, orderUncheckedCreateWithoutUserInput>
  }

  export type orderCreateManyUserInputEnvelope = {
    data: orderCreateManyUserInput | orderCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type order_productCreateWithoutUserInput = {
    qty: number
    price: number
    productData: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    product: productCreateNestedOneWithoutOrder_productInput
    order: orderCreateNestedOneWithoutOrder_productInput
    product_price: product_priceCreateNestedOneWithoutOrder_productInput
  }

  export type order_productUncheckedCreateWithoutUserInput = {
    id?: number
    productId: number
    orderId: number
    product_priceId: number
    qty: number
    price: number
    productData: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type order_productCreateOrConnectWithoutUserInput = {
    where: order_productWhereUniqueInput
    create: XOR<order_productCreateWithoutUserInput, order_productUncheckedCreateWithoutUserInput>
  }

  export type order_productCreateManyUserInputEnvelope = {
    data: order_productCreateManyUserInput | order_productCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type addressUpsertWithWhereUniqueWithoutUserInput = {
    where: addressWhereUniqueInput
    update: XOR<addressUpdateWithoutUserInput, addressUncheckedUpdateWithoutUserInput>
    create: XOR<addressCreateWithoutUserInput, addressUncheckedCreateWithoutUserInput>
  }

  export type addressUpdateWithWhereUniqueWithoutUserInput = {
    where: addressWhereUniqueInput
    data: XOR<addressUpdateWithoutUserInput, addressUncheckedUpdateWithoutUserInput>
  }

  export type addressUpdateManyWithWhereWithoutUserInput = {
    where: addressScalarWhereInput
    data: XOR<addressUpdateManyMutationInput, addressUncheckedUpdateManyWithoutUserInput>
  }

  export type addressScalarWhereInput = {
    AND?: addressScalarWhereInput | addressScalarWhereInput[]
    OR?: addressScalarWhereInput[]
    NOT?: addressScalarWhereInput | addressScalarWhereInput[]
    id?: IntFilter<"address"> | number
    userId?: IntFilter<"address"> | number
    default?: BoolFilter<"address"> | boolean
    addressName?: StringFilter<"address"> | string
    details?: StringNullableFilter<"address"> | string | null
    remarks?: StringNullableFilter<"address"> | string | null
    receiverFname?: StringFilter<"address"> | string
    receiverLname?: StringFilter<"address"> | string
    receiverFullname?: StringFilter<"address"> | string
    receiverPhone?: StringFilter<"address"> | string
    houseNo?: StringFilter<"address"> | string
    villageNo?: StringNullableFilter<"address"> | string | null
    road?: StringNullableFilter<"address"> | string | null
    province?: StringFilter<"address"> | string
    district?: StringFilter<"address"> | string
    subDistrict?: StringFilter<"address"> | string
    postCode?: StringFilter<"address"> | string
    isActive?: BoolFilter<"address"> | boolean
    createdAt?: DateTimeFilter<"address"> | Date | string
    updatedAt?: DateTimeFilter<"address"> | Date | string
  }

  export type user_credit_transactionUpsertWithWhereUniqueWithoutUserInput = {
    where: user_credit_transactionWhereUniqueInput
    update: XOR<user_credit_transactionUpdateWithoutUserInput, user_credit_transactionUncheckedUpdateWithoutUserInput>
    create: XOR<user_credit_transactionCreateWithoutUserInput, user_credit_transactionUncheckedCreateWithoutUserInput>
  }

  export type user_credit_transactionUpdateWithWhereUniqueWithoutUserInput = {
    where: user_credit_transactionWhereUniqueInput
    data: XOR<user_credit_transactionUpdateWithoutUserInput, user_credit_transactionUncheckedUpdateWithoutUserInput>
  }

  export type user_credit_transactionUpdateManyWithWhereWithoutUserInput = {
    where: user_credit_transactionScalarWhereInput
    data: XOR<user_credit_transactionUpdateManyMutationInput, user_credit_transactionUncheckedUpdateManyWithoutUserInput>
  }

  export type payment_transactionUpsertWithWhereUniqueWithoutUserInput = {
    where: payment_transactionWhereUniqueInput
    update: XOR<payment_transactionUpdateWithoutUserInput, payment_transactionUncheckedUpdateWithoutUserInput>
    create: XOR<payment_transactionCreateWithoutUserInput, payment_transactionUncheckedCreateWithoutUserInput>
  }

  export type payment_transactionUpdateWithWhereUniqueWithoutUserInput = {
    where: payment_transactionWhereUniqueInput
    data: XOR<payment_transactionUpdateWithoutUserInput, payment_transactionUncheckedUpdateWithoutUserInput>
  }

  export type payment_transactionUpdateManyWithWhereWithoutUserInput = {
    where: payment_transactionScalarWhereInput
    data: XOR<payment_transactionUpdateManyMutationInput, payment_transactionUncheckedUpdateManyWithoutUserInput>
  }

  export type payment_transactionScalarWhereInput = {
    AND?: payment_transactionScalarWhereInput | payment_transactionScalarWhereInput[]
    OR?: payment_transactionScalarWhereInput[]
    NOT?: payment_transactionScalarWhereInput | payment_transactionScalarWhereInput[]
    id?: IntFilter<"payment_transaction"> | number
    userId?: IntFilter<"payment_transaction"> | number
    price?: FloatFilter<"payment_transaction"> | number
    refCode?: StringFilter<"payment_transaction"> | string
    status?: StringFilter<"payment_transaction"> | string
    base64?: StringNullableFilter<"payment_transaction"> | string | null
    isActive?: BoolFilter<"payment_transaction"> | boolean
    createdAt?: DateTimeFilter<"payment_transaction"> | Date | string
    updatedAt?: DateTimeFilter<"payment_transaction"> | Date | string
  }

  export type user_point_transactionUpsertWithWhereUniqueWithoutUserInput = {
    where: user_point_transactionWhereUniqueInput
    update: XOR<user_point_transactionUpdateWithoutUserInput, user_point_transactionUncheckedUpdateWithoutUserInput>
    create: XOR<user_point_transactionCreateWithoutUserInput, user_point_transactionUncheckedCreateWithoutUserInput>
  }

  export type user_point_transactionUpdateWithWhereUniqueWithoutUserInput = {
    where: user_point_transactionWhereUniqueInput
    data: XOR<user_point_transactionUpdateWithoutUserInput, user_point_transactionUncheckedUpdateWithoutUserInput>
  }

  export type user_point_transactionUpdateManyWithWhereWithoutUserInput = {
    where: user_point_transactionScalarWhereInput
    data: XOR<user_point_transactionUpdateManyMutationInput, user_point_transactionUncheckedUpdateManyWithoutUserInput>
  }

  export type product_reviewUpsertWithWhereUniqueWithoutUserInput = {
    where: product_reviewWhereUniqueInput
    update: XOR<product_reviewUpdateWithoutUserInput, product_reviewUncheckedUpdateWithoutUserInput>
    create: XOR<product_reviewCreateWithoutUserInput, product_reviewUncheckedCreateWithoutUserInput>
  }

  export type product_reviewUpdateWithWhereUniqueWithoutUserInput = {
    where: product_reviewWhereUniqueInput
    data: XOR<product_reviewUpdateWithoutUserInput, product_reviewUncheckedUpdateWithoutUserInput>
  }

  export type product_reviewUpdateManyWithWhereWithoutUserInput = {
    where: product_reviewScalarWhereInput
    data: XOR<product_reviewUpdateManyMutationInput, product_reviewUncheckedUpdateManyWithoutUserInput>
  }

  export type cartUpsertWithWhereUniqueWithoutUserInput = {
    where: cartWhereUniqueInput
    update: XOR<cartUpdateWithoutUserInput, cartUncheckedUpdateWithoutUserInput>
    create: XOR<cartCreateWithoutUserInput, cartUncheckedCreateWithoutUserInput>
  }

  export type cartUpdateWithWhereUniqueWithoutUserInput = {
    where: cartWhereUniqueInput
    data: XOR<cartUpdateWithoutUserInput, cartUncheckedUpdateWithoutUserInput>
  }

  export type cartUpdateManyWithWhereWithoutUserInput = {
    where: cartScalarWhereInput
    data: XOR<cartUpdateManyMutationInput, cartUncheckedUpdateManyWithoutUserInput>
  }

  export type cartScalarWhereInput = {
    AND?: cartScalarWhereInput | cartScalarWhereInput[]
    OR?: cartScalarWhereInput[]
    NOT?: cartScalarWhereInput | cartScalarWhereInput[]
    id?: IntFilter<"cart"> | number
    userId?: IntFilter<"cart"> | number
    productId?: IntFilter<"cart"> | number
    product_priceId?: IntFilter<"cart"> | number
    qty?: IntFilter<"cart"> | number
    price?: FloatFilter<"cart"> | number
    isActive?: BoolFilter<"cart"> | boolean
    createdAt?: DateTimeFilter<"cart"> | Date | string
    updatedAt?: DateTimeFilter<"cart"> | Date | string
  }

  export type orderUpsertWithWhereUniqueWithoutUserInput = {
    where: orderWhereUniqueInput
    update: XOR<orderUpdateWithoutUserInput, orderUncheckedUpdateWithoutUserInput>
    create: XOR<orderCreateWithoutUserInput, orderUncheckedCreateWithoutUserInput>
  }

  export type orderUpdateWithWhereUniqueWithoutUserInput = {
    where: orderWhereUniqueInput
    data: XOR<orderUpdateWithoutUserInput, orderUncheckedUpdateWithoutUserInput>
  }

  export type orderUpdateManyWithWhereWithoutUserInput = {
    where: orderScalarWhereInput
    data: XOR<orderUpdateManyMutationInput, orderUncheckedUpdateManyWithoutUserInput>
  }

  export type orderScalarWhereInput = {
    AND?: orderScalarWhereInput | orderScalarWhereInput[]
    OR?: orderScalarWhereInput[]
    NOT?: orderScalarWhereInput | orderScalarWhereInput[]
    id?: IntFilter<"order"> | number
    userId?: IntFilter<"order"> | number
    statusNow?: StringFilter<"order"> | string
    status?: JsonFilter<"order">
    paymentType?: StringFilter<"order"> | string
    paymentStatus?: StringFilter<"order"> | string
    createUsing?: FloatFilter<"order"> | number
    pointUsing?: FloatFilter<"order"> | number
    orderPrice?: FloatFilter<"order"> | number
    deliveryPrice?: FloatFilter<"order"> | number
    netPrice?: FloatFilter<"order"> | number
    orderDiscount?: FloatFilter<"order"> | number
    deliveryDiscount?: FloatFilter<"order"> | number
    orderDiscountCode?: StringFilter<"order"> | string
    deliveryDiscountCode?: StringFilter<"order"> | string
    addressId?: IntFilter<"order"> | number
    addressData?: JsonFilter<"order">
    userData?: JsonFilter<"order">
    isReject?: BoolFilter<"order"> | boolean
    isActive?: BoolFilter<"order"> | boolean
    createdAt?: DateTimeFilter<"order"> | Date | string
    updatedAt?: DateTimeFilter<"order"> | Date | string
  }

  export type order_productUpsertWithWhereUniqueWithoutUserInput = {
    where: order_productWhereUniqueInput
    update: XOR<order_productUpdateWithoutUserInput, order_productUncheckedUpdateWithoutUserInput>
    create: XOR<order_productCreateWithoutUserInput, order_productUncheckedCreateWithoutUserInput>
  }

  export type order_productUpdateWithWhereUniqueWithoutUserInput = {
    where: order_productWhereUniqueInput
    data: XOR<order_productUpdateWithoutUserInput, order_productUncheckedUpdateWithoutUserInput>
  }

  export type order_productUpdateManyWithWhereWithoutUserInput = {
    where: order_productScalarWhereInput
    data: XOR<order_productUpdateManyMutationInput, order_productUncheckedUpdateManyWithoutUserInput>
  }

  export type order_productScalarWhereInput = {
    AND?: order_productScalarWhereInput | order_productScalarWhereInput[]
    OR?: order_productScalarWhereInput[]
    NOT?: order_productScalarWhereInput | order_productScalarWhereInput[]
    id?: IntFilter<"order_product"> | number
    userId?: IntFilter<"order_product"> | number
    productId?: IntFilter<"order_product"> | number
    orderId?: IntFilter<"order_product"> | number
    product_priceId?: IntFilter<"order_product"> | number
    qty?: IntFilter<"order_product"> | number
    price?: FloatFilter<"order_product"> | number
    productData?: JsonFilter<"order_product">
    isActive?: BoolFilter<"order_product"> | boolean
    createdAt?: DateTimeFilter<"order_product"> | Date | string
    updatedAt?: DateTimeFilter<"order_product"> | Date | string
  }

  export type userCreateWithoutUser_credit_transactionInput = {
    avatarPath?: string | null
    avatarSrc?: string | null
    fname?: string | null
    lname?: string | null
    fullname?: string | null
    email: string
    phone: string
    credit?: number
    point?: number
    lineId?: string | null
    baned?: boolean
    ipv4?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    address?: addressCreateNestedManyWithoutUserInput
    payment_transaction?: payment_transactionCreateNestedManyWithoutUserInput
    user_point_transaction?: user_point_transactionCreateNestedManyWithoutUserInput
    product_review?: product_reviewCreateNestedManyWithoutUserInput
    cart?: cartCreateNestedManyWithoutUserInput
    order?: orderCreateNestedManyWithoutUserInput
    order_product?: order_productCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutUser_credit_transactionInput = {
    id?: number
    avatarPath?: string | null
    avatarSrc?: string | null
    fname?: string | null
    lname?: string | null
    fullname?: string | null
    email: string
    phone: string
    credit?: number
    point?: number
    lineId?: string | null
    baned?: boolean
    ipv4?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    address?: addressUncheckedCreateNestedManyWithoutUserInput
    payment_transaction?: payment_transactionUncheckedCreateNestedManyWithoutUserInput
    user_point_transaction?: user_point_transactionUncheckedCreateNestedManyWithoutUserInput
    product_review?: product_reviewUncheckedCreateNestedManyWithoutUserInput
    cart?: cartUncheckedCreateNestedManyWithoutUserInput
    order?: orderUncheckedCreateNestedManyWithoutUserInput
    order_product?: order_productUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutUser_credit_transactionInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutUser_credit_transactionInput, userUncheckedCreateWithoutUser_credit_transactionInput>
  }

  export type adminCreateWithoutUser_credit_transactionInput = {
    userName: string
    fname?: string | null
    lname?: string | null
    fullname?: string | null
    role?: string
    permission?: NullableJsonNullValueInput | InputJsonValue
    email: string
    avatarPath?: string | null
    avatarSrc?: string | null
    phone: string
    refreshToken?: string | null
    password: string
    passwordRt?: string | null
    ipv4?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user_point_transaction?: user_point_transactionCreateNestedManyWithoutAdminInput
    product_review?: product_reviewCreateNestedManyWithoutAdminInput
    product?: productCreateNestedManyWithoutAdminInput
  }

  export type adminUncheckedCreateWithoutUser_credit_transactionInput = {
    id?: number
    userName: string
    fname?: string | null
    lname?: string | null
    fullname?: string | null
    role?: string
    permission?: NullableJsonNullValueInput | InputJsonValue
    email: string
    avatarPath?: string | null
    avatarSrc?: string | null
    phone: string
    refreshToken?: string | null
    password: string
    passwordRt?: string | null
    ipv4?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user_point_transaction?: user_point_transactionUncheckedCreateNestedManyWithoutAdminInput
    product_review?: product_reviewUncheckedCreateNestedManyWithoutAdminInput
    product?: productUncheckedCreateNestedManyWithoutAdminInput
  }

  export type adminCreateOrConnectWithoutUser_credit_transactionInput = {
    where: adminWhereUniqueInput
    create: XOR<adminCreateWithoutUser_credit_transactionInput, adminUncheckedCreateWithoutUser_credit_transactionInput>
  }

  export type userUpsertWithoutUser_credit_transactionInput = {
    update: XOR<userUpdateWithoutUser_credit_transactionInput, userUncheckedUpdateWithoutUser_credit_transactionInput>
    create: XOR<userCreateWithoutUser_credit_transactionInput, userUncheckedCreateWithoutUser_credit_transactionInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutUser_credit_transactionInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutUser_credit_transactionInput, userUncheckedUpdateWithoutUser_credit_transactionInput>
  }

  export type userUpdateWithoutUser_credit_transactionInput = {
    avatarPath?: NullableStringFieldUpdateOperationsInput | string | null
    avatarSrc?: NullableStringFieldUpdateOperationsInput | string | null
    fname?: NullableStringFieldUpdateOperationsInput | string | null
    lname?: NullableStringFieldUpdateOperationsInput | string | null
    fullname?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    credit?: FloatFieldUpdateOperationsInput | number
    point?: FloatFieldUpdateOperationsInput | number
    lineId?: NullableStringFieldUpdateOperationsInput | string | null
    baned?: BoolFieldUpdateOperationsInput | boolean
    ipv4?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: addressUpdateManyWithoutUserNestedInput
    payment_transaction?: payment_transactionUpdateManyWithoutUserNestedInput
    user_point_transaction?: user_point_transactionUpdateManyWithoutUserNestedInput
    product_review?: product_reviewUpdateManyWithoutUserNestedInput
    cart?: cartUpdateManyWithoutUserNestedInput
    order?: orderUpdateManyWithoutUserNestedInput
    order_product?: order_productUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutUser_credit_transactionInput = {
    id?: IntFieldUpdateOperationsInput | number
    avatarPath?: NullableStringFieldUpdateOperationsInput | string | null
    avatarSrc?: NullableStringFieldUpdateOperationsInput | string | null
    fname?: NullableStringFieldUpdateOperationsInput | string | null
    lname?: NullableStringFieldUpdateOperationsInput | string | null
    fullname?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    credit?: FloatFieldUpdateOperationsInput | number
    point?: FloatFieldUpdateOperationsInput | number
    lineId?: NullableStringFieldUpdateOperationsInput | string | null
    baned?: BoolFieldUpdateOperationsInput | boolean
    ipv4?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: addressUncheckedUpdateManyWithoutUserNestedInput
    payment_transaction?: payment_transactionUncheckedUpdateManyWithoutUserNestedInput
    user_point_transaction?: user_point_transactionUncheckedUpdateManyWithoutUserNestedInput
    product_review?: product_reviewUncheckedUpdateManyWithoutUserNestedInput
    cart?: cartUncheckedUpdateManyWithoutUserNestedInput
    order?: orderUncheckedUpdateManyWithoutUserNestedInput
    order_product?: order_productUncheckedUpdateManyWithoutUserNestedInput
  }

  export type adminUpsertWithoutUser_credit_transactionInput = {
    update: XOR<adminUpdateWithoutUser_credit_transactionInput, adminUncheckedUpdateWithoutUser_credit_transactionInput>
    create: XOR<adminCreateWithoutUser_credit_transactionInput, adminUncheckedCreateWithoutUser_credit_transactionInput>
    where?: adminWhereInput
  }

  export type adminUpdateToOneWithWhereWithoutUser_credit_transactionInput = {
    where?: adminWhereInput
    data: XOR<adminUpdateWithoutUser_credit_transactionInput, adminUncheckedUpdateWithoutUser_credit_transactionInput>
  }

  export type adminUpdateWithoutUser_credit_transactionInput = {
    userName?: StringFieldUpdateOperationsInput | string
    fname?: NullableStringFieldUpdateOperationsInput | string | null
    lname?: NullableStringFieldUpdateOperationsInput | string | null
    fullname?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    permission?: NullableJsonNullValueInput | InputJsonValue
    email?: StringFieldUpdateOperationsInput | string
    avatarPath?: NullableStringFieldUpdateOperationsInput | string | null
    avatarSrc?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    passwordRt?: NullableStringFieldUpdateOperationsInput | string | null
    ipv4?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user_point_transaction?: user_point_transactionUpdateManyWithoutAdminNestedInput
    product_review?: product_reviewUpdateManyWithoutAdminNestedInput
    product?: productUpdateManyWithoutAdminNestedInput
  }

  export type adminUncheckedUpdateWithoutUser_credit_transactionInput = {
    id?: IntFieldUpdateOperationsInput | number
    userName?: StringFieldUpdateOperationsInput | string
    fname?: NullableStringFieldUpdateOperationsInput | string | null
    lname?: NullableStringFieldUpdateOperationsInput | string | null
    fullname?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    permission?: NullableJsonNullValueInput | InputJsonValue
    email?: StringFieldUpdateOperationsInput | string
    avatarPath?: NullableStringFieldUpdateOperationsInput | string | null
    avatarSrc?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    passwordRt?: NullableStringFieldUpdateOperationsInput | string | null
    ipv4?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user_point_transaction?: user_point_transactionUncheckedUpdateManyWithoutAdminNestedInput
    product_review?: product_reviewUncheckedUpdateManyWithoutAdminNestedInput
    product?: productUncheckedUpdateManyWithoutAdminNestedInput
  }

  export type userCreateWithoutUser_point_transactionInput = {
    avatarPath?: string | null
    avatarSrc?: string | null
    fname?: string | null
    lname?: string | null
    fullname?: string | null
    email: string
    phone: string
    credit?: number
    point?: number
    lineId?: string | null
    baned?: boolean
    ipv4?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    address?: addressCreateNestedManyWithoutUserInput
    user_credit_transaction?: user_credit_transactionCreateNestedManyWithoutUserInput
    payment_transaction?: payment_transactionCreateNestedManyWithoutUserInput
    product_review?: product_reviewCreateNestedManyWithoutUserInput
    cart?: cartCreateNestedManyWithoutUserInput
    order?: orderCreateNestedManyWithoutUserInput
    order_product?: order_productCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutUser_point_transactionInput = {
    id?: number
    avatarPath?: string | null
    avatarSrc?: string | null
    fname?: string | null
    lname?: string | null
    fullname?: string | null
    email: string
    phone: string
    credit?: number
    point?: number
    lineId?: string | null
    baned?: boolean
    ipv4?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    address?: addressUncheckedCreateNestedManyWithoutUserInput
    user_credit_transaction?: user_credit_transactionUncheckedCreateNestedManyWithoutUserInput
    payment_transaction?: payment_transactionUncheckedCreateNestedManyWithoutUserInput
    product_review?: product_reviewUncheckedCreateNestedManyWithoutUserInput
    cart?: cartUncheckedCreateNestedManyWithoutUserInput
    order?: orderUncheckedCreateNestedManyWithoutUserInput
    order_product?: order_productUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutUser_point_transactionInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutUser_point_transactionInput, userUncheckedCreateWithoutUser_point_transactionInput>
  }

  export type adminCreateWithoutUser_point_transactionInput = {
    userName: string
    fname?: string | null
    lname?: string | null
    fullname?: string | null
    role?: string
    permission?: NullableJsonNullValueInput | InputJsonValue
    email: string
    avatarPath?: string | null
    avatarSrc?: string | null
    phone: string
    refreshToken?: string | null
    password: string
    passwordRt?: string | null
    ipv4?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user_credit_transaction?: user_credit_transactionCreateNestedManyWithoutAdminInput
    product_review?: product_reviewCreateNestedManyWithoutAdminInput
    product?: productCreateNestedManyWithoutAdminInput
  }

  export type adminUncheckedCreateWithoutUser_point_transactionInput = {
    id?: number
    userName: string
    fname?: string | null
    lname?: string | null
    fullname?: string | null
    role?: string
    permission?: NullableJsonNullValueInput | InputJsonValue
    email: string
    avatarPath?: string | null
    avatarSrc?: string | null
    phone: string
    refreshToken?: string | null
    password: string
    passwordRt?: string | null
    ipv4?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user_credit_transaction?: user_credit_transactionUncheckedCreateNestedManyWithoutAdminInput
    product_review?: product_reviewUncheckedCreateNestedManyWithoutAdminInput
    product?: productUncheckedCreateNestedManyWithoutAdminInput
  }

  export type adminCreateOrConnectWithoutUser_point_transactionInput = {
    where: adminWhereUniqueInput
    create: XOR<adminCreateWithoutUser_point_transactionInput, adminUncheckedCreateWithoutUser_point_transactionInput>
  }

  export type userUpsertWithoutUser_point_transactionInput = {
    update: XOR<userUpdateWithoutUser_point_transactionInput, userUncheckedUpdateWithoutUser_point_transactionInput>
    create: XOR<userCreateWithoutUser_point_transactionInput, userUncheckedCreateWithoutUser_point_transactionInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutUser_point_transactionInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutUser_point_transactionInput, userUncheckedUpdateWithoutUser_point_transactionInput>
  }

  export type userUpdateWithoutUser_point_transactionInput = {
    avatarPath?: NullableStringFieldUpdateOperationsInput | string | null
    avatarSrc?: NullableStringFieldUpdateOperationsInput | string | null
    fname?: NullableStringFieldUpdateOperationsInput | string | null
    lname?: NullableStringFieldUpdateOperationsInput | string | null
    fullname?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    credit?: FloatFieldUpdateOperationsInput | number
    point?: FloatFieldUpdateOperationsInput | number
    lineId?: NullableStringFieldUpdateOperationsInput | string | null
    baned?: BoolFieldUpdateOperationsInput | boolean
    ipv4?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: addressUpdateManyWithoutUserNestedInput
    user_credit_transaction?: user_credit_transactionUpdateManyWithoutUserNestedInput
    payment_transaction?: payment_transactionUpdateManyWithoutUserNestedInput
    product_review?: product_reviewUpdateManyWithoutUserNestedInput
    cart?: cartUpdateManyWithoutUserNestedInput
    order?: orderUpdateManyWithoutUserNestedInput
    order_product?: order_productUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutUser_point_transactionInput = {
    id?: IntFieldUpdateOperationsInput | number
    avatarPath?: NullableStringFieldUpdateOperationsInput | string | null
    avatarSrc?: NullableStringFieldUpdateOperationsInput | string | null
    fname?: NullableStringFieldUpdateOperationsInput | string | null
    lname?: NullableStringFieldUpdateOperationsInput | string | null
    fullname?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    credit?: FloatFieldUpdateOperationsInput | number
    point?: FloatFieldUpdateOperationsInput | number
    lineId?: NullableStringFieldUpdateOperationsInput | string | null
    baned?: BoolFieldUpdateOperationsInput | boolean
    ipv4?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: addressUncheckedUpdateManyWithoutUserNestedInput
    user_credit_transaction?: user_credit_transactionUncheckedUpdateManyWithoutUserNestedInput
    payment_transaction?: payment_transactionUncheckedUpdateManyWithoutUserNestedInput
    product_review?: product_reviewUncheckedUpdateManyWithoutUserNestedInput
    cart?: cartUncheckedUpdateManyWithoutUserNestedInput
    order?: orderUncheckedUpdateManyWithoutUserNestedInput
    order_product?: order_productUncheckedUpdateManyWithoutUserNestedInput
  }

  export type adminUpsertWithoutUser_point_transactionInput = {
    update: XOR<adminUpdateWithoutUser_point_transactionInput, adminUncheckedUpdateWithoutUser_point_transactionInput>
    create: XOR<adminCreateWithoutUser_point_transactionInput, adminUncheckedCreateWithoutUser_point_transactionInput>
    where?: adminWhereInput
  }

  export type adminUpdateToOneWithWhereWithoutUser_point_transactionInput = {
    where?: adminWhereInput
    data: XOR<adminUpdateWithoutUser_point_transactionInput, adminUncheckedUpdateWithoutUser_point_transactionInput>
  }

  export type adminUpdateWithoutUser_point_transactionInput = {
    userName?: StringFieldUpdateOperationsInput | string
    fname?: NullableStringFieldUpdateOperationsInput | string | null
    lname?: NullableStringFieldUpdateOperationsInput | string | null
    fullname?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    permission?: NullableJsonNullValueInput | InputJsonValue
    email?: StringFieldUpdateOperationsInput | string
    avatarPath?: NullableStringFieldUpdateOperationsInput | string | null
    avatarSrc?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    passwordRt?: NullableStringFieldUpdateOperationsInput | string | null
    ipv4?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user_credit_transaction?: user_credit_transactionUpdateManyWithoutAdminNestedInput
    product_review?: product_reviewUpdateManyWithoutAdminNestedInput
    product?: productUpdateManyWithoutAdminNestedInput
  }

  export type adminUncheckedUpdateWithoutUser_point_transactionInput = {
    id?: IntFieldUpdateOperationsInput | number
    userName?: StringFieldUpdateOperationsInput | string
    fname?: NullableStringFieldUpdateOperationsInput | string | null
    lname?: NullableStringFieldUpdateOperationsInput | string | null
    fullname?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    permission?: NullableJsonNullValueInput | InputJsonValue
    email?: StringFieldUpdateOperationsInput | string
    avatarPath?: NullableStringFieldUpdateOperationsInput | string | null
    avatarSrc?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    passwordRt?: NullableStringFieldUpdateOperationsInput | string | null
    ipv4?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user_credit_transaction?: user_credit_transactionUncheckedUpdateManyWithoutAdminNestedInput
    product_review?: product_reviewUncheckedUpdateManyWithoutAdminNestedInput
    product?: productUncheckedUpdateManyWithoutAdminNestedInput
  }

  export type userCreateWithoutPayment_transactionInput = {
    avatarPath?: string | null
    avatarSrc?: string | null
    fname?: string | null
    lname?: string | null
    fullname?: string | null
    email: string
    phone: string
    credit?: number
    point?: number
    lineId?: string | null
    baned?: boolean
    ipv4?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    address?: addressCreateNestedManyWithoutUserInput
    user_credit_transaction?: user_credit_transactionCreateNestedManyWithoutUserInput
    user_point_transaction?: user_point_transactionCreateNestedManyWithoutUserInput
    product_review?: product_reviewCreateNestedManyWithoutUserInput
    cart?: cartCreateNestedManyWithoutUserInput
    order?: orderCreateNestedManyWithoutUserInput
    order_product?: order_productCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutPayment_transactionInput = {
    id?: number
    avatarPath?: string | null
    avatarSrc?: string | null
    fname?: string | null
    lname?: string | null
    fullname?: string | null
    email: string
    phone: string
    credit?: number
    point?: number
    lineId?: string | null
    baned?: boolean
    ipv4?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    address?: addressUncheckedCreateNestedManyWithoutUserInput
    user_credit_transaction?: user_credit_transactionUncheckedCreateNestedManyWithoutUserInput
    user_point_transaction?: user_point_transactionUncheckedCreateNestedManyWithoutUserInput
    product_review?: product_reviewUncheckedCreateNestedManyWithoutUserInput
    cart?: cartUncheckedCreateNestedManyWithoutUserInput
    order?: orderUncheckedCreateNestedManyWithoutUserInput
    order_product?: order_productUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutPayment_transactionInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutPayment_transactionInput, userUncheckedCreateWithoutPayment_transactionInput>
  }

  export type userUpsertWithoutPayment_transactionInput = {
    update: XOR<userUpdateWithoutPayment_transactionInput, userUncheckedUpdateWithoutPayment_transactionInput>
    create: XOR<userCreateWithoutPayment_transactionInput, userUncheckedCreateWithoutPayment_transactionInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutPayment_transactionInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutPayment_transactionInput, userUncheckedUpdateWithoutPayment_transactionInput>
  }

  export type userUpdateWithoutPayment_transactionInput = {
    avatarPath?: NullableStringFieldUpdateOperationsInput | string | null
    avatarSrc?: NullableStringFieldUpdateOperationsInput | string | null
    fname?: NullableStringFieldUpdateOperationsInput | string | null
    lname?: NullableStringFieldUpdateOperationsInput | string | null
    fullname?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    credit?: FloatFieldUpdateOperationsInput | number
    point?: FloatFieldUpdateOperationsInput | number
    lineId?: NullableStringFieldUpdateOperationsInput | string | null
    baned?: BoolFieldUpdateOperationsInput | boolean
    ipv4?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: addressUpdateManyWithoutUserNestedInput
    user_credit_transaction?: user_credit_transactionUpdateManyWithoutUserNestedInput
    user_point_transaction?: user_point_transactionUpdateManyWithoutUserNestedInput
    product_review?: product_reviewUpdateManyWithoutUserNestedInput
    cart?: cartUpdateManyWithoutUserNestedInput
    order?: orderUpdateManyWithoutUserNestedInput
    order_product?: order_productUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutPayment_transactionInput = {
    id?: IntFieldUpdateOperationsInput | number
    avatarPath?: NullableStringFieldUpdateOperationsInput | string | null
    avatarSrc?: NullableStringFieldUpdateOperationsInput | string | null
    fname?: NullableStringFieldUpdateOperationsInput | string | null
    lname?: NullableStringFieldUpdateOperationsInput | string | null
    fullname?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    credit?: FloatFieldUpdateOperationsInput | number
    point?: FloatFieldUpdateOperationsInput | number
    lineId?: NullableStringFieldUpdateOperationsInput | string | null
    baned?: BoolFieldUpdateOperationsInput | boolean
    ipv4?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: addressUncheckedUpdateManyWithoutUserNestedInput
    user_credit_transaction?: user_credit_transactionUncheckedUpdateManyWithoutUserNestedInput
    user_point_transaction?: user_point_transactionUncheckedUpdateManyWithoutUserNestedInput
    product_review?: product_reviewUncheckedUpdateManyWithoutUserNestedInput
    cart?: cartUncheckedUpdateManyWithoutUserNestedInput
    order?: orderUncheckedUpdateManyWithoutUserNestedInput
    order_product?: order_productUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userCreateWithoutAddressInput = {
    avatarPath?: string | null
    avatarSrc?: string | null
    fname?: string | null
    lname?: string | null
    fullname?: string | null
    email: string
    phone: string
    credit?: number
    point?: number
    lineId?: string | null
    baned?: boolean
    ipv4?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user_credit_transaction?: user_credit_transactionCreateNestedManyWithoutUserInput
    payment_transaction?: payment_transactionCreateNestedManyWithoutUserInput
    user_point_transaction?: user_point_transactionCreateNestedManyWithoutUserInput
    product_review?: product_reviewCreateNestedManyWithoutUserInput
    cart?: cartCreateNestedManyWithoutUserInput
    order?: orderCreateNestedManyWithoutUserInput
    order_product?: order_productCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutAddressInput = {
    id?: number
    avatarPath?: string | null
    avatarSrc?: string | null
    fname?: string | null
    lname?: string | null
    fullname?: string | null
    email: string
    phone: string
    credit?: number
    point?: number
    lineId?: string | null
    baned?: boolean
    ipv4?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user_credit_transaction?: user_credit_transactionUncheckedCreateNestedManyWithoutUserInput
    payment_transaction?: payment_transactionUncheckedCreateNestedManyWithoutUserInput
    user_point_transaction?: user_point_transactionUncheckedCreateNestedManyWithoutUserInput
    product_review?: product_reviewUncheckedCreateNestedManyWithoutUserInput
    cart?: cartUncheckedCreateNestedManyWithoutUserInput
    order?: orderUncheckedCreateNestedManyWithoutUserInput
    order_product?: order_productUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutAddressInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutAddressInput, userUncheckedCreateWithoutAddressInput>
  }

  export type orderCreateWithoutAddressInput = {
    statusNow?: string
    status: JsonNullValueInput | InputJsonValue
    paymentType: string
    paymentStatus?: string
    createUsing?: number
    pointUsing?: number
    orderPrice: number
    deliveryPrice: number
    netPrice: number
    orderDiscount: number
    deliveryDiscount: number
    orderDiscountCode: string
    deliveryDiscountCode: string
    addressData: JsonNullValueInput | InputJsonValue
    userData: JsonNullValueInput | InputJsonValue
    isReject?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: userCreateNestedOneWithoutOrderInput
    order_product?: order_productCreateNestedManyWithoutOrderInput
  }

  export type orderUncheckedCreateWithoutAddressInput = {
    id?: number
    userId: number
    statusNow?: string
    status: JsonNullValueInput | InputJsonValue
    paymentType: string
    paymentStatus?: string
    createUsing?: number
    pointUsing?: number
    orderPrice: number
    deliveryPrice: number
    netPrice: number
    orderDiscount: number
    deliveryDiscount: number
    orderDiscountCode: string
    deliveryDiscountCode: string
    addressData: JsonNullValueInput | InputJsonValue
    userData: JsonNullValueInput | InputJsonValue
    isReject?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    order_product?: order_productUncheckedCreateNestedManyWithoutOrderInput
  }

  export type orderCreateOrConnectWithoutAddressInput = {
    where: orderWhereUniqueInput
    create: XOR<orderCreateWithoutAddressInput, orderUncheckedCreateWithoutAddressInput>
  }

  export type orderCreateManyAddressInputEnvelope = {
    data: orderCreateManyAddressInput | orderCreateManyAddressInput[]
    skipDuplicates?: boolean
  }

  export type userUpsertWithoutAddressInput = {
    update: XOR<userUpdateWithoutAddressInput, userUncheckedUpdateWithoutAddressInput>
    create: XOR<userCreateWithoutAddressInput, userUncheckedCreateWithoutAddressInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutAddressInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutAddressInput, userUncheckedUpdateWithoutAddressInput>
  }

  export type userUpdateWithoutAddressInput = {
    avatarPath?: NullableStringFieldUpdateOperationsInput | string | null
    avatarSrc?: NullableStringFieldUpdateOperationsInput | string | null
    fname?: NullableStringFieldUpdateOperationsInput | string | null
    lname?: NullableStringFieldUpdateOperationsInput | string | null
    fullname?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    credit?: FloatFieldUpdateOperationsInput | number
    point?: FloatFieldUpdateOperationsInput | number
    lineId?: NullableStringFieldUpdateOperationsInput | string | null
    baned?: BoolFieldUpdateOperationsInput | boolean
    ipv4?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user_credit_transaction?: user_credit_transactionUpdateManyWithoutUserNestedInput
    payment_transaction?: payment_transactionUpdateManyWithoutUserNestedInput
    user_point_transaction?: user_point_transactionUpdateManyWithoutUserNestedInput
    product_review?: product_reviewUpdateManyWithoutUserNestedInput
    cart?: cartUpdateManyWithoutUserNestedInput
    order?: orderUpdateManyWithoutUserNestedInput
    order_product?: order_productUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutAddressInput = {
    id?: IntFieldUpdateOperationsInput | number
    avatarPath?: NullableStringFieldUpdateOperationsInput | string | null
    avatarSrc?: NullableStringFieldUpdateOperationsInput | string | null
    fname?: NullableStringFieldUpdateOperationsInput | string | null
    lname?: NullableStringFieldUpdateOperationsInput | string | null
    fullname?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    credit?: FloatFieldUpdateOperationsInput | number
    point?: FloatFieldUpdateOperationsInput | number
    lineId?: NullableStringFieldUpdateOperationsInput | string | null
    baned?: BoolFieldUpdateOperationsInput | boolean
    ipv4?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user_credit_transaction?: user_credit_transactionUncheckedUpdateManyWithoutUserNestedInput
    payment_transaction?: payment_transactionUncheckedUpdateManyWithoutUserNestedInput
    user_point_transaction?: user_point_transactionUncheckedUpdateManyWithoutUserNestedInput
    product_review?: product_reviewUncheckedUpdateManyWithoutUserNestedInput
    cart?: cartUncheckedUpdateManyWithoutUserNestedInput
    order?: orderUncheckedUpdateManyWithoutUserNestedInput
    order_product?: order_productUncheckedUpdateManyWithoutUserNestedInput
  }

  export type orderUpsertWithWhereUniqueWithoutAddressInput = {
    where: orderWhereUniqueInput
    update: XOR<orderUpdateWithoutAddressInput, orderUncheckedUpdateWithoutAddressInput>
    create: XOR<orderCreateWithoutAddressInput, orderUncheckedCreateWithoutAddressInput>
  }

  export type orderUpdateWithWhereUniqueWithoutAddressInput = {
    where: orderWhereUniqueInput
    data: XOR<orderUpdateWithoutAddressInput, orderUncheckedUpdateWithoutAddressInput>
  }

  export type orderUpdateManyWithWhereWithoutAddressInput = {
    where: orderScalarWhereInput
    data: XOR<orderUpdateManyMutationInput, orderUncheckedUpdateManyWithoutAddressInput>
  }

  export type productCreateWithoutBrandInput = {
    name: string
    shortName?: string | null
    detail?: string | null
    isDiscount?: boolean
    discountPercent: number
    minPrice: number
    maxPrice: number
    slug: string
    cardImgPath: string
    cardImgSrc: string
    optionFirst?: string | null
    optionSecond?: string | null
    isWholesale?: boolean
    rating?: number
    sold?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    admin: adminCreateNestedOneWithoutProductInput
    product_image?: product_imageCreateNestedManyWithoutProductInput
    product_spec?: product_specCreateNestedManyWithoutProductInput
    product_detail?: product_detailCreateNestedManyWithoutProductInput
    product_option_first?: product_option_firstCreateNestedManyWithoutProductInput
    product_option_second?: product_option_secondCreateNestedManyWithoutProductInput
    product_price?: product_priceCreateNestedManyWithoutProductInput
    product_wholesale?: product_wholesaleCreateNestedManyWithoutProductInput
    product_review?: product_reviewCreateNestedManyWithoutProductInput
    product_tag?: product_tagCreateNestedManyWithoutProductInput
    cart?: cartCreateNestedManyWithoutProductInput
    order_product?: order_productCreateNestedManyWithoutProductInput
  }

  export type productUncheckedCreateWithoutBrandInput = {
    id?: number
    adminId: number
    name: string
    shortName?: string | null
    detail?: string | null
    isDiscount?: boolean
    discountPercent: number
    minPrice: number
    maxPrice: number
    slug: string
    cardImgPath: string
    cardImgSrc: string
    optionFirst?: string | null
    optionSecond?: string | null
    isWholesale?: boolean
    rating?: number
    sold?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    product_image?: product_imageUncheckedCreateNestedManyWithoutProductInput
    product_spec?: product_specUncheckedCreateNestedManyWithoutProductInput
    product_detail?: product_detailUncheckedCreateNestedManyWithoutProductInput
    product_option_first?: product_option_firstUncheckedCreateNestedManyWithoutProductInput
    product_option_second?: product_option_secondUncheckedCreateNestedManyWithoutProductInput
    product_price?: product_priceUncheckedCreateNestedManyWithoutProductInput
    product_wholesale?: product_wholesaleUncheckedCreateNestedManyWithoutProductInput
    product_review?: product_reviewUncheckedCreateNestedManyWithoutProductInput
    product_tag?: product_tagUncheckedCreateNestedManyWithoutProductInput
    cart?: cartUncheckedCreateNestedManyWithoutProductInput
    order_product?: order_productUncheckedCreateNestedManyWithoutProductInput
  }

  export type productCreateOrConnectWithoutBrandInput = {
    where: productWhereUniqueInput
    create: XOR<productCreateWithoutBrandInput, productUncheckedCreateWithoutBrandInput>
  }

  export type productCreateManyBrandInputEnvelope = {
    data: productCreateManyBrandInput | productCreateManyBrandInput[]
    skipDuplicates?: boolean
  }

  export type productUpsertWithWhereUniqueWithoutBrandInput = {
    where: productWhereUniqueInput
    update: XOR<productUpdateWithoutBrandInput, productUncheckedUpdateWithoutBrandInput>
    create: XOR<productCreateWithoutBrandInput, productUncheckedCreateWithoutBrandInput>
  }

  export type productUpdateWithWhereUniqueWithoutBrandInput = {
    where: productWhereUniqueInput
    data: XOR<productUpdateWithoutBrandInput, productUncheckedUpdateWithoutBrandInput>
  }

  export type productUpdateManyWithWhereWithoutBrandInput = {
    where: productScalarWhereInput
    data: XOR<productUpdateManyMutationInput, productUncheckedUpdateManyWithoutBrandInput>
  }

  export type product_tagCreateWithoutTagInput = {
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    product: productCreateNestedOneWithoutProduct_tagInput
  }

  export type product_tagUncheckedCreateWithoutTagInput = {
    id?: number
    productId: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type product_tagCreateOrConnectWithoutTagInput = {
    where: product_tagWhereUniqueInput
    create: XOR<product_tagCreateWithoutTagInput, product_tagUncheckedCreateWithoutTagInput>
  }

  export type product_tagCreateManyTagInputEnvelope = {
    data: product_tagCreateManyTagInput | product_tagCreateManyTagInput[]
    skipDuplicates?: boolean
  }

  export type product_tagUpsertWithWhereUniqueWithoutTagInput = {
    where: product_tagWhereUniqueInput
    update: XOR<product_tagUpdateWithoutTagInput, product_tagUncheckedUpdateWithoutTagInput>
    create: XOR<product_tagCreateWithoutTagInput, product_tagUncheckedCreateWithoutTagInput>
  }

  export type product_tagUpdateWithWhereUniqueWithoutTagInput = {
    where: product_tagWhereUniqueInput
    data: XOR<product_tagUpdateWithoutTagInput, product_tagUncheckedUpdateWithoutTagInput>
  }

  export type product_tagUpdateManyWithWhereWithoutTagInput = {
    where: product_tagScalarWhereInput
    data: XOR<product_tagUpdateManyMutationInput, product_tagUncheckedUpdateManyWithoutTagInput>
  }

  export type product_tagScalarWhereInput = {
    AND?: product_tagScalarWhereInput | product_tagScalarWhereInput[]
    OR?: product_tagScalarWhereInput[]
    NOT?: product_tagScalarWhereInput | product_tagScalarWhereInput[]
    id?: IntFilter<"product_tag"> | number
    productId?: IntFilter<"product_tag"> | number
    tagId?: IntFilter<"product_tag"> | number
    isActive?: BoolFilter<"product_tag"> | boolean
    createdAt?: DateTimeFilter<"product_tag"> | Date | string
    updatedAt?: DateTimeFilter<"product_tag"> | Date | string
  }

  export type sub_categoryCreateWithoutCategoryInput = {
    name: string
    detail?: string | null
    imagePath?: string | null
    imageSrc?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type sub_categoryUncheckedCreateWithoutCategoryInput = {
    id?: number
    name: string
    detail?: string | null
    imagePath?: string | null
    imageSrc?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type sub_categoryCreateOrConnectWithoutCategoryInput = {
    where: sub_categoryWhereUniqueInput
    create: XOR<sub_categoryCreateWithoutCategoryInput, sub_categoryUncheckedCreateWithoutCategoryInput>
  }

  export type sub_categoryCreateManyCategoryInputEnvelope = {
    data: sub_categoryCreateManyCategoryInput | sub_categoryCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type sub_categoryUpsertWithWhereUniqueWithoutCategoryInput = {
    where: sub_categoryWhereUniqueInput
    update: XOR<sub_categoryUpdateWithoutCategoryInput, sub_categoryUncheckedUpdateWithoutCategoryInput>
    create: XOR<sub_categoryCreateWithoutCategoryInput, sub_categoryUncheckedCreateWithoutCategoryInput>
  }

  export type sub_categoryUpdateWithWhereUniqueWithoutCategoryInput = {
    where: sub_categoryWhereUniqueInput
    data: XOR<sub_categoryUpdateWithoutCategoryInput, sub_categoryUncheckedUpdateWithoutCategoryInput>
  }

  export type sub_categoryUpdateManyWithWhereWithoutCategoryInput = {
    where: sub_categoryScalarWhereInput
    data: XOR<sub_categoryUpdateManyMutationInput, sub_categoryUncheckedUpdateManyWithoutCategoryInput>
  }

  export type sub_categoryScalarWhereInput = {
    AND?: sub_categoryScalarWhereInput | sub_categoryScalarWhereInput[]
    OR?: sub_categoryScalarWhereInput[]
    NOT?: sub_categoryScalarWhereInput | sub_categoryScalarWhereInput[]
    id?: IntFilter<"sub_category"> | number
    categoryId?: IntFilter<"sub_category"> | number
    name?: StringFilter<"sub_category"> | string
    detail?: StringNullableFilter<"sub_category"> | string | null
    imagePath?: StringNullableFilter<"sub_category"> | string | null
    imageSrc?: StringNullableFilter<"sub_category"> | string | null
    isActive?: BoolFilter<"sub_category"> | boolean
    createdAt?: DateTimeFilter<"sub_category"> | Date | string
    updatedAt?: DateTimeFilter<"sub_category"> | Date | string
  }

  export type categoryCreateWithoutSub_categoryInput = {
    name: string
    detail?: string | null
    imagePath?: string | null
    imageSrc?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type categoryUncheckedCreateWithoutSub_categoryInput = {
    id?: number
    name: string
    detail?: string | null
    imagePath?: string | null
    imageSrc?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type categoryCreateOrConnectWithoutSub_categoryInput = {
    where: categoryWhereUniqueInput
    create: XOR<categoryCreateWithoutSub_categoryInput, categoryUncheckedCreateWithoutSub_categoryInput>
  }

  export type categoryUpsertWithoutSub_categoryInput = {
    update: XOR<categoryUpdateWithoutSub_categoryInput, categoryUncheckedUpdateWithoutSub_categoryInput>
    create: XOR<categoryCreateWithoutSub_categoryInput, categoryUncheckedCreateWithoutSub_categoryInput>
    where?: categoryWhereInput
  }

  export type categoryUpdateToOneWithWhereWithoutSub_categoryInput = {
    where?: categoryWhereInput
    data: XOR<categoryUpdateWithoutSub_categoryInput, categoryUncheckedUpdateWithoutSub_categoryInput>
  }

  export type categoryUpdateWithoutSub_categoryInput = {
    name?: StringFieldUpdateOperationsInput | string
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    imageSrc?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type categoryUncheckedUpdateWithoutSub_categoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    imageSrc?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type userCreateWithoutProduct_reviewInput = {
    avatarPath?: string | null
    avatarSrc?: string | null
    fname?: string | null
    lname?: string | null
    fullname?: string | null
    email: string
    phone: string
    credit?: number
    point?: number
    lineId?: string | null
    baned?: boolean
    ipv4?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    address?: addressCreateNestedManyWithoutUserInput
    user_credit_transaction?: user_credit_transactionCreateNestedManyWithoutUserInput
    payment_transaction?: payment_transactionCreateNestedManyWithoutUserInput
    user_point_transaction?: user_point_transactionCreateNestedManyWithoutUserInput
    cart?: cartCreateNestedManyWithoutUserInput
    order?: orderCreateNestedManyWithoutUserInput
    order_product?: order_productCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutProduct_reviewInput = {
    id?: number
    avatarPath?: string | null
    avatarSrc?: string | null
    fname?: string | null
    lname?: string | null
    fullname?: string | null
    email: string
    phone: string
    credit?: number
    point?: number
    lineId?: string | null
    baned?: boolean
    ipv4?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    address?: addressUncheckedCreateNestedManyWithoutUserInput
    user_credit_transaction?: user_credit_transactionUncheckedCreateNestedManyWithoutUserInput
    payment_transaction?: payment_transactionUncheckedCreateNestedManyWithoutUserInput
    user_point_transaction?: user_point_transactionUncheckedCreateNestedManyWithoutUserInput
    cart?: cartUncheckedCreateNestedManyWithoutUserInput
    order?: orderUncheckedCreateNestedManyWithoutUserInput
    order_product?: order_productUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutProduct_reviewInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutProduct_reviewInput, userUncheckedCreateWithoutProduct_reviewInput>
  }

  export type productCreateWithoutProduct_reviewInput = {
    name: string
    shortName?: string | null
    detail?: string | null
    isDiscount?: boolean
    discountPercent: number
    minPrice: number
    maxPrice: number
    slug: string
    cardImgPath: string
    cardImgSrc: string
    optionFirst?: string | null
    optionSecond?: string | null
    isWholesale?: boolean
    rating?: number
    sold?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    brand: brandCreateNestedOneWithoutProductInput
    admin: adminCreateNestedOneWithoutProductInput
    product_image?: product_imageCreateNestedManyWithoutProductInput
    product_spec?: product_specCreateNestedManyWithoutProductInput
    product_detail?: product_detailCreateNestedManyWithoutProductInput
    product_option_first?: product_option_firstCreateNestedManyWithoutProductInput
    product_option_second?: product_option_secondCreateNestedManyWithoutProductInput
    product_price?: product_priceCreateNestedManyWithoutProductInput
    product_wholesale?: product_wholesaleCreateNestedManyWithoutProductInput
    product_tag?: product_tagCreateNestedManyWithoutProductInput
    cart?: cartCreateNestedManyWithoutProductInput
    order_product?: order_productCreateNestedManyWithoutProductInput
  }

  export type productUncheckedCreateWithoutProduct_reviewInput = {
    id?: number
    brandId: number
    adminId: number
    name: string
    shortName?: string | null
    detail?: string | null
    isDiscount?: boolean
    discountPercent: number
    minPrice: number
    maxPrice: number
    slug: string
    cardImgPath: string
    cardImgSrc: string
    optionFirst?: string | null
    optionSecond?: string | null
    isWholesale?: boolean
    rating?: number
    sold?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    product_image?: product_imageUncheckedCreateNestedManyWithoutProductInput
    product_spec?: product_specUncheckedCreateNestedManyWithoutProductInput
    product_detail?: product_detailUncheckedCreateNestedManyWithoutProductInput
    product_option_first?: product_option_firstUncheckedCreateNestedManyWithoutProductInput
    product_option_second?: product_option_secondUncheckedCreateNestedManyWithoutProductInput
    product_price?: product_priceUncheckedCreateNestedManyWithoutProductInput
    product_wholesale?: product_wholesaleUncheckedCreateNestedManyWithoutProductInput
    product_tag?: product_tagUncheckedCreateNestedManyWithoutProductInput
    cart?: cartUncheckedCreateNestedManyWithoutProductInput
    order_product?: order_productUncheckedCreateNestedManyWithoutProductInput
  }

  export type productCreateOrConnectWithoutProduct_reviewInput = {
    where: productWhereUniqueInput
    create: XOR<productCreateWithoutProduct_reviewInput, productUncheckedCreateWithoutProduct_reviewInput>
  }

  export type adminCreateWithoutProduct_reviewInput = {
    userName: string
    fname?: string | null
    lname?: string | null
    fullname?: string | null
    role?: string
    permission?: NullableJsonNullValueInput | InputJsonValue
    email: string
    avatarPath?: string | null
    avatarSrc?: string | null
    phone: string
    refreshToken?: string | null
    password: string
    passwordRt?: string | null
    ipv4?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user_credit_transaction?: user_credit_transactionCreateNestedManyWithoutAdminInput
    user_point_transaction?: user_point_transactionCreateNestedManyWithoutAdminInput
    product?: productCreateNestedManyWithoutAdminInput
  }

  export type adminUncheckedCreateWithoutProduct_reviewInput = {
    id?: number
    userName: string
    fname?: string | null
    lname?: string | null
    fullname?: string | null
    role?: string
    permission?: NullableJsonNullValueInput | InputJsonValue
    email: string
    avatarPath?: string | null
    avatarSrc?: string | null
    phone: string
    refreshToken?: string | null
    password: string
    passwordRt?: string | null
    ipv4?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user_credit_transaction?: user_credit_transactionUncheckedCreateNestedManyWithoutAdminInput
    user_point_transaction?: user_point_transactionUncheckedCreateNestedManyWithoutAdminInput
    product?: productUncheckedCreateNestedManyWithoutAdminInput
  }

  export type adminCreateOrConnectWithoutProduct_reviewInput = {
    where: adminWhereUniqueInput
    create: XOR<adminCreateWithoutProduct_reviewInput, adminUncheckedCreateWithoutProduct_reviewInput>
  }

  export type userUpsertWithoutProduct_reviewInput = {
    update: XOR<userUpdateWithoutProduct_reviewInput, userUncheckedUpdateWithoutProduct_reviewInput>
    create: XOR<userCreateWithoutProduct_reviewInput, userUncheckedCreateWithoutProduct_reviewInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutProduct_reviewInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutProduct_reviewInput, userUncheckedUpdateWithoutProduct_reviewInput>
  }

  export type userUpdateWithoutProduct_reviewInput = {
    avatarPath?: NullableStringFieldUpdateOperationsInput | string | null
    avatarSrc?: NullableStringFieldUpdateOperationsInput | string | null
    fname?: NullableStringFieldUpdateOperationsInput | string | null
    lname?: NullableStringFieldUpdateOperationsInput | string | null
    fullname?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    credit?: FloatFieldUpdateOperationsInput | number
    point?: FloatFieldUpdateOperationsInput | number
    lineId?: NullableStringFieldUpdateOperationsInput | string | null
    baned?: BoolFieldUpdateOperationsInput | boolean
    ipv4?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: addressUpdateManyWithoutUserNestedInput
    user_credit_transaction?: user_credit_transactionUpdateManyWithoutUserNestedInput
    payment_transaction?: payment_transactionUpdateManyWithoutUserNestedInput
    user_point_transaction?: user_point_transactionUpdateManyWithoutUserNestedInput
    cart?: cartUpdateManyWithoutUserNestedInput
    order?: orderUpdateManyWithoutUserNestedInput
    order_product?: order_productUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutProduct_reviewInput = {
    id?: IntFieldUpdateOperationsInput | number
    avatarPath?: NullableStringFieldUpdateOperationsInput | string | null
    avatarSrc?: NullableStringFieldUpdateOperationsInput | string | null
    fname?: NullableStringFieldUpdateOperationsInput | string | null
    lname?: NullableStringFieldUpdateOperationsInput | string | null
    fullname?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    credit?: FloatFieldUpdateOperationsInput | number
    point?: FloatFieldUpdateOperationsInput | number
    lineId?: NullableStringFieldUpdateOperationsInput | string | null
    baned?: BoolFieldUpdateOperationsInput | boolean
    ipv4?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: addressUncheckedUpdateManyWithoutUserNestedInput
    user_credit_transaction?: user_credit_transactionUncheckedUpdateManyWithoutUserNestedInput
    payment_transaction?: payment_transactionUncheckedUpdateManyWithoutUserNestedInput
    user_point_transaction?: user_point_transactionUncheckedUpdateManyWithoutUserNestedInput
    cart?: cartUncheckedUpdateManyWithoutUserNestedInput
    order?: orderUncheckedUpdateManyWithoutUserNestedInput
    order_product?: order_productUncheckedUpdateManyWithoutUserNestedInput
  }

  export type productUpsertWithoutProduct_reviewInput = {
    update: XOR<productUpdateWithoutProduct_reviewInput, productUncheckedUpdateWithoutProduct_reviewInput>
    create: XOR<productCreateWithoutProduct_reviewInput, productUncheckedCreateWithoutProduct_reviewInput>
    where?: productWhereInput
  }

  export type productUpdateToOneWithWhereWithoutProduct_reviewInput = {
    where?: productWhereInput
    data: XOR<productUpdateWithoutProduct_reviewInput, productUncheckedUpdateWithoutProduct_reviewInput>
  }

  export type productUpdateWithoutProduct_reviewInput = {
    name?: StringFieldUpdateOperationsInput | string
    shortName?: NullableStringFieldUpdateOperationsInput | string | null
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    isDiscount?: BoolFieldUpdateOperationsInput | boolean
    discountPercent?: IntFieldUpdateOperationsInput | number
    minPrice?: FloatFieldUpdateOperationsInput | number
    maxPrice?: FloatFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    cardImgPath?: StringFieldUpdateOperationsInput | string
    cardImgSrc?: StringFieldUpdateOperationsInput | string
    optionFirst?: NullableStringFieldUpdateOperationsInput | string | null
    optionSecond?: NullableStringFieldUpdateOperationsInput | string | null
    isWholesale?: BoolFieldUpdateOperationsInput | boolean
    rating?: IntFieldUpdateOperationsInput | number
    sold?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    brand?: brandUpdateOneRequiredWithoutProductNestedInput
    admin?: adminUpdateOneRequiredWithoutProductNestedInput
    product_image?: product_imageUpdateManyWithoutProductNestedInput
    product_spec?: product_specUpdateManyWithoutProductNestedInput
    product_detail?: product_detailUpdateManyWithoutProductNestedInput
    product_option_first?: product_option_firstUpdateManyWithoutProductNestedInput
    product_option_second?: product_option_secondUpdateManyWithoutProductNestedInput
    product_price?: product_priceUpdateManyWithoutProductNestedInput
    product_wholesale?: product_wholesaleUpdateManyWithoutProductNestedInput
    product_tag?: product_tagUpdateManyWithoutProductNestedInput
    cart?: cartUpdateManyWithoutProductNestedInput
    order_product?: order_productUpdateManyWithoutProductNestedInput
  }

  export type productUncheckedUpdateWithoutProduct_reviewInput = {
    id?: IntFieldUpdateOperationsInput | number
    brandId?: IntFieldUpdateOperationsInput | number
    adminId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    shortName?: NullableStringFieldUpdateOperationsInput | string | null
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    isDiscount?: BoolFieldUpdateOperationsInput | boolean
    discountPercent?: IntFieldUpdateOperationsInput | number
    minPrice?: FloatFieldUpdateOperationsInput | number
    maxPrice?: FloatFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    cardImgPath?: StringFieldUpdateOperationsInput | string
    cardImgSrc?: StringFieldUpdateOperationsInput | string
    optionFirst?: NullableStringFieldUpdateOperationsInput | string | null
    optionSecond?: NullableStringFieldUpdateOperationsInput | string | null
    isWholesale?: BoolFieldUpdateOperationsInput | boolean
    rating?: IntFieldUpdateOperationsInput | number
    sold?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product_image?: product_imageUncheckedUpdateManyWithoutProductNestedInput
    product_spec?: product_specUncheckedUpdateManyWithoutProductNestedInput
    product_detail?: product_detailUncheckedUpdateManyWithoutProductNestedInput
    product_option_first?: product_option_firstUncheckedUpdateManyWithoutProductNestedInput
    product_option_second?: product_option_secondUncheckedUpdateManyWithoutProductNestedInput
    product_price?: product_priceUncheckedUpdateManyWithoutProductNestedInput
    product_wholesale?: product_wholesaleUncheckedUpdateManyWithoutProductNestedInput
    product_tag?: product_tagUncheckedUpdateManyWithoutProductNestedInput
    cart?: cartUncheckedUpdateManyWithoutProductNestedInput
    order_product?: order_productUncheckedUpdateManyWithoutProductNestedInput
  }

  export type adminUpsertWithoutProduct_reviewInput = {
    update: XOR<adminUpdateWithoutProduct_reviewInput, adminUncheckedUpdateWithoutProduct_reviewInput>
    create: XOR<adminCreateWithoutProduct_reviewInput, adminUncheckedCreateWithoutProduct_reviewInput>
    where?: adminWhereInput
  }

  export type adminUpdateToOneWithWhereWithoutProduct_reviewInput = {
    where?: adminWhereInput
    data: XOR<adminUpdateWithoutProduct_reviewInput, adminUncheckedUpdateWithoutProduct_reviewInput>
  }

  export type adminUpdateWithoutProduct_reviewInput = {
    userName?: StringFieldUpdateOperationsInput | string
    fname?: NullableStringFieldUpdateOperationsInput | string | null
    lname?: NullableStringFieldUpdateOperationsInput | string | null
    fullname?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    permission?: NullableJsonNullValueInput | InputJsonValue
    email?: StringFieldUpdateOperationsInput | string
    avatarPath?: NullableStringFieldUpdateOperationsInput | string | null
    avatarSrc?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    passwordRt?: NullableStringFieldUpdateOperationsInput | string | null
    ipv4?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user_credit_transaction?: user_credit_transactionUpdateManyWithoutAdminNestedInput
    user_point_transaction?: user_point_transactionUpdateManyWithoutAdminNestedInput
    product?: productUpdateManyWithoutAdminNestedInput
  }

  export type adminUncheckedUpdateWithoutProduct_reviewInput = {
    id?: IntFieldUpdateOperationsInput | number
    userName?: StringFieldUpdateOperationsInput | string
    fname?: NullableStringFieldUpdateOperationsInput | string | null
    lname?: NullableStringFieldUpdateOperationsInput | string | null
    fullname?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    permission?: NullableJsonNullValueInput | InputJsonValue
    email?: StringFieldUpdateOperationsInput | string
    avatarPath?: NullableStringFieldUpdateOperationsInput | string | null
    avatarSrc?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    passwordRt?: NullableStringFieldUpdateOperationsInput | string | null
    ipv4?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user_credit_transaction?: user_credit_transactionUncheckedUpdateManyWithoutAdminNestedInput
    user_point_transaction?: user_point_transactionUncheckedUpdateManyWithoutAdminNestedInput
    product?: productUncheckedUpdateManyWithoutAdminNestedInput
  }

  export type brandCreateWithoutProductInput = {
    name: string
    detail?: string | null
    imagePath?: string | null
    imageSrc?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type brandUncheckedCreateWithoutProductInput = {
    id?: number
    name: string
    detail?: string | null
    imagePath?: string | null
    imageSrc?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type brandCreateOrConnectWithoutProductInput = {
    where: brandWhereUniqueInput
    create: XOR<brandCreateWithoutProductInput, brandUncheckedCreateWithoutProductInput>
  }

  export type adminCreateWithoutProductInput = {
    userName: string
    fname?: string | null
    lname?: string | null
    fullname?: string | null
    role?: string
    permission?: NullableJsonNullValueInput | InputJsonValue
    email: string
    avatarPath?: string | null
    avatarSrc?: string | null
    phone: string
    refreshToken?: string | null
    password: string
    passwordRt?: string | null
    ipv4?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user_credit_transaction?: user_credit_transactionCreateNestedManyWithoutAdminInput
    user_point_transaction?: user_point_transactionCreateNestedManyWithoutAdminInput
    product_review?: product_reviewCreateNestedManyWithoutAdminInput
  }

  export type adminUncheckedCreateWithoutProductInput = {
    id?: number
    userName: string
    fname?: string | null
    lname?: string | null
    fullname?: string | null
    role?: string
    permission?: NullableJsonNullValueInput | InputJsonValue
    email: string
    avatarPath?: string | null
    avatarSrc?: string | null
    phone: string
    refreshToken?: string | null
    password: string
    passwordRt?: string | null
    ipv4?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user_credit_transaction?: user_credit_transactionUncheckedCreateNestedManyWithoutAdminInput
    user_point_transaction?: user_point_transactionUncheckedCreateNestedManyWithoutAdminInput
    product_review?: product_reviewUncheckedCreateNestedManyWithoutAdminInput
  }

  export type adminCreateOrConnectWithoutProductInput = {
    where: adminWhereUniqueInput
    create: XOR<adminCreateWithoutProductInput, adminUncheckedCreateWithoutProductInput>
  }

  export type product_imageCreateWithoutProductInput = {
    name: string
    path: string
    src: string
    sequence: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type product_imageUncheckedCreateWithoutProductInput = {
    id?: number
    name: string
    path: string
    src: string
    sequence: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type product_imageCreateOrConnectWithoutProductInput = {
    where: product_imageWhereUniqueInput
    create: XOR<product_imageCreateWithoutProductInput, product_imageUncheckedCreateWithoutProductInput>
  }

  export type product_imageCreateManyProductInputEnvelope = {
    data: product_imageCreateManyProductInput | product_imageCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type product_specCreateWithoutProductInput = {
    name: string
    data: JsonNullValueInput | InputJsonValue
  }

  export type product_specUncheckedCreateWithoutProductInput = {
    id?: number
    name: string
    data: JsonNullValueInput | InputJsonValue
  }

  export type product_specCreateOrConnectWithoutProductInput = {
    where: product_specWhereUniqueInput
    create: XOR<product_specCreateWithoutProductInput, product_specUncheckedCreateWithoutProductInput>
  }

  export type product_specCreateManyProductInputEnvelope = {
    data: product_specCreateManyProductInput | product_specCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type product_detailCreateWithoutProductInput = {
    name: string
    details?: string | null
    imagePath?: string | null
    imageSrc?: string | null
    videoPath?: string | null
    videoSrc?: string | null
    videoType?: string | null
    link?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type product_detailUncheckedCreateWithoutProductInput = {
    id?: number
    name: string
    details?: string | null
    imagePath?: string | null
    imageSrc?: string | null
    videoPath?: string | null
    videoSrc?: string | null
    videoType?: string | null
    link?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type product_detailCreateOrConnectWithoutProductInput = {
    where: product_detailWhereUniqueInput
    create: XOR<product_detailCreateWithoutProductInput, product_detailUncheckedCreateWithoutProductInput>
  }

  export type product_detailCreateManyProductInputEnvelope = {
    data: product_detailCreateManyProductInput | product_detailCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type product_option_firstCreateWithoutProductInput = {
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    product_price?: product_priceCreateNestedManyWithoutProduct_option_firstInput
  }

  export type product_option_firstUncheckedCreateWithoutProductInput = {
    id?: number
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    product_price?: product_priceUncheckedCreateNestedManyWithoutProduct_option_firstInput
  }

  export type product_option_firstCreateOrConnectWithoutProductInput = {
    where: product_option_firstWhereUniqueInput
    create: XOR<product_option_firstCreateWithoutProductInput, product_option_firstUncheckedCreateWithoutProductInput>
  }

  export type product_option_firstCreateManyProductInputEnvelope = {
    data: product_option_firstCreateManyProductInput | product_option_firstCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type product_option_secondCreateWithoutProductInput = {
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    product_price?: product_priceCreateNestedManyWithoutProduct_option_secondInput
  }

  export type product_option_secondUncheckedCreateWithoutProductInput = {
    id?: number
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    product_price?: product_priceUncheckedCreateNestedManyWithoutProduct_option_secondInput
  }

  export type product_option_secondCreateOrConnectWithoutProductInput = {
    where: product_option_secondWhereUniqueInput
    create: XOR<product_option_secondCreateWithoutProductInput, product_option_secondUncheckedCreateWithoutProductInput>
  }

  export type product_option_secondCreateManyProductInputEnvelope = {
    data: product_option_secondCreateManyProductInput | product_option_secondCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type product_priceCreateWithoutProductInput = {
    price: number
    sku?: string | null
    isWholesale?: boolean
    product_option_first?: product_option_firstCreateNestedOneWithoutProduct_priceInput
    product_option_second?: product_option_secondCreateNestedOneWithoutProduct_priceInput
    cart?: cartCreateNestedManyWithoutProduct_priceInput
    order_product?: order_productCreateNestedManyWithoutProduct_priceInput
  }

  export type product_priceUncheckedCreateWithoutProductInput = {
    id?: number
    product_option_firstId?: number | null
    product_option_secondId?: number | null
    price: number
    sku?: string | null
    isWholesale?: boolean
    cart?: cartUncheckedCreateNestedManyWithoutProduct_priceInput
    order_product?: order_productUncheckedCreateNestedManyWithoutProduct_priceInput
  }

  export type product_priceCreateOrConnectWithoutProductInput = {
    where: product_priceWhereUniqueInput
    create: XOR<product_priceCreateWithoutProductInput, product_priceUncheckedCreateWithoutProductInput>
  }

  export type product_priceCreateManyProductInputEnvelope = {
    data: product_priceCreateManyProductInput | product_priceCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type product_wholesaleCreateWithoutProductInput = {
    min: number
    price: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type product_wholesaleUncheckedCreateWithoutProductInput = {
    id?: number
    min: number
    price: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type product_wholesaleCreateOrConnectWithoutProductInput = {
    where: product_wholesaleWhereUniqueInput
    create: XOR<product_wholesaleCreateWithoutProductInput, product_wholesaleUncheckedCreateWithoutProductInput>
  }

  export type product_wholesaleCreateManyProductInputEnvelope = {
    data: product_wholesaleCreateManyProductInput | product_wholesaleCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type product_reviewCreateWithoutProductInput = {
    detail?: string | null
    rating?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: userCreateNestedOneWithoutProduct_reviewInput
    admin: adminCreateNestedOneWithoutProduct_reviewInput
  }

  export type product_reviewUncheckedCreateWithoutProductInput = {
    id?: number
    userId: number
    adminId: number
    detail?: string | null
    rating?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type product_reviewCreateOrConnectWithoutProductInput = {
    where: product_reviewWhereUniqueInput
    create: XOR<product_reviewCreateWithoutProductInput, product_reviewUncheckedCreateWithoutProductInput>
  }

  export type product_reviewCreateManyProductInputEnvelope = {
    data: product_reviewCreateManyProductInput | product_reviewCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type product_tagCreateWithoutProductInput = {
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tag: tagCreateNestedOneWithoutProduct_tagInput
  }

  export type product_tagUncheckedCreateWithoutProductInput = {
    id?: number
    tagId: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type product_tagCreateOrConnectWithoutProductInput = {
    where: product_tagWhereUniqueInput
    create: XOR<product_tagCreateWithoutProductInput, product_tagUncheckedCreateWithoutProductInput>
  }

  export type product_tagCreateManyProductInputEnvelope = {
    data: product_tagCreateManyProductInput | product_tagCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type cartCreateWithoutProductInput = {
    qty: number
    price: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: userCreateNestedOneWithoutCartInput
    product_price: product_priceCreateNestedOneWithoutCartInput
  }

  export type cartUncheckedCreateWithoutProductInput = {
    id?: number
    userId: number
    product_priceId: number
    qty: number
    price: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type cartCreateOrConnectWithoutProductInput = {
    where: cartWhereUniqueInput
    create: XOR<cartCreateWithoutProductInput, cartUncheckedCreateWithoutProductInput>
  }

  export type cartCreateManyProductInputEnvelope = {
    data: cartCreateManyProductInput | cartCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type order_productCreateWithoutProductInput = {
    qty: number
    price: number
    productData: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: userCreateNestedOneWithoutOrder_productInput
    order: orderCreateNestedOneWithoutOrder_productInput
    product_price: product_priceCreateNestedOneWithoutOrder_productInput
  }

  export type order_productUncheckedCreateWithoutProductInput = {
    id?: number
    userId: number
    orderId: number
    product_priceId: number
    qty: number
    price: number
    productData: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type order_productCreateOrConnectWithoutProductInput = {
    where: order_productWhereUniqueInput
    create: XOR<order_productCreateWithoutProductInput, order_productUncheckedCreateWithoutProductInput>
  }

  export type order_productCreateManyProductInputEnvelope = {
    data: order_productCreateManyProductInput | order_productCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type brandUpsertWithoutProductInput = {
    update: XOR<brandUpdateWithoutProductInput, brandUncheckedUpdateWithoutProductInput>
    create: XOR<brandCreateWithoutProductInput, brandUncheckedCreateWithoutProductInput>
    where?: brandWhereInput
  }

  export type brandUpdateToOneWithWhereWithoutProductInput = {
    where?: brandWhereInput
    data: XOR<brandUpdateWithoutProductInput, brandUncheckedUpdateWithoutProductInput>
  }

  export type brandUpdateWithoutProductInput = {
    name?: StringFieldUpdateOperationsInput | string
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    imageSrc?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type brandUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    imageSrc?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type adminUpsertWithoutProductInput = {
    update: XOR<adminUpdateWithoutProductInput, adminUncheckedUpdateWithoutProductInput>
    create: XOR<adminCreateWithoutProductInput, adminUncheckedCreateWithoutProductInput>
    where?: adminWhereInput
  }

  export type adminUpdateToOneWithWhereWithoutProductInput = {
    where?: adminWhereInput
    data: XOR<adminUpdateWithoutProductInput, adminUncheckedUpdateWithoutProductInput>
  }

  export type adminUpdateWithoutProductInput = {
    userName?: StringFieldUpdateOperationsInput | string
    fname?: NullableStringFieldUpdateOperationsInput | string | null
    lname?: NullableStringFieldUpdateOperationsInput | string | null
    fullname?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    permission?: NullableJsonNullValueInput | InputJsonValue
    email?: StringFieldUpdateOperationsInput | string
    avatarPath?: NullableStringFieldUpdateOperationsInput | string | null
    avatarSrc?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    passwordRt?: NullableStringFieldUpdateOperationsInput | string | null
    ipv4?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user_credit_transaction?: user_credit_transactionUpdateManyWithoutAdminNestedInput
    user_point_transaction?: user_point_transactionUpdateManyWithoutAdminNestedInput
    product_review?: product_reviewUpdateManyWithoutAdminNestedInput
  }

  export type adminUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    userName?: StringFieldUpdateOperationsInput | string
    fname?: NullableStringFieldUpdateOperationsInput | string | null
    lname?: NullableStringFieldUpdateOperationsInput | string | null
    fullname?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    permission?: NullableJsonNullValueInput | InputJsonValue
    email?: StringFieldUpdateOperationsInput | string
    avatarPath?: NullableStringFieldUpdateOperationsInput | string | null
    avatarSrc?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    passwordRt?: NullableStringFieldUpdateOperationsInput | string | null
    ipv4?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user_credit_transaction?: user_credit_transactionUncheckedUpdateManyWithoutAdminNestedInput
    user_point_transaction?: user_point_transactionUncheckedUpdateManyWithoutAdminNestedInput
    product_review?: product_reviewUncheckedUpdateManyWithoutAdminNestedInput
  }

  export type product_imageUpsertWithWhereUniqueWithoutProductInput = {
    where: product_imageWhereUniqueInput
    update: XOR<product_imageUpdateWithoutProductInput, product_imageUncheckedUpdateWithoutProductInput>
    create: XOR<product_imageCreateWithoutProductInput, product_imageUncheckedCreateWithoutProductInput>
  }

  export type product_imageUpdateWithWhereUniqueWithoutProductInput = {
    where: product_imageWhereUniqueInput
    data: XOR<product_imageUpdateWithoutProductInput, product_imageUncheckedUpdateWithoutProductInput>
  }

  export type product_imageUpdateManyWithWhereWithoutProductInput = {
    where: product_imageScalarWhereInput
    data: XOR<product_imageUpdateManyMutationInput, product_imageUncheckedUpdateManyWithoutProductInput>
  }

  export type product_imageScalarWhereInput = {
    AND?: product_imageScalarWhereInput | product_imageScalarWhereInput[]
    OR?: product_imageScalarWhereInput[]
    NOT?: product_imageScalarWhereInput | product_imageScalarWhereInput[]
    id?: IntFilter<"product_image"> | number
    name?: StringFilter<"product_image"> | string
    path?: StringFilter<"product_image"> | string
    src?: StringFilter<"product_image"> | string
    sequence?: IntFilter<"product_image"> | number
    productId?: IntFilter<"product_image"> | number
    isActive?: BoolFilter<"product_image"> | boolean
    createdAt?: DateTimeFilter<"product_image"> | Date | string
    updatedAt?: DateTimeFilter<"product_image"> | Date | string
  }

  export type product_specUpsertWithWhereUniqueWithoutProductInput = {
    where: product_specWhereUniqueInput
    update: XOR<product_specUpdateWithoutProductInput, product_specUncheckedUpdateWithoutProductInput>
    create: XOR<product_specCreateWithoutProductInput, product_specUncheckedCreateWithoutProductInput>
  }

  export type product_specUpdateWithWhereUniqueWithoutProductInput = {
    where: product_specWhereUniqueInput
    data: XOR<product_specUpdateWithoutProductInput, product_specUncheckedUpdateWithoutProductInput>
  }

  export type product_specUpdateManyWithWhereWithoutProductInput = {
    where: product_specScalarWhereInput
    data: XOR<product_specUpdateManyMutationInput, product_specUncheckedUpdateManyWithoutProductInput>
  }

  export type product_specScalarWhereInput = {
    AND?: product_specScalarWhereInput | product_specScalarWhereInput[]
    OR?: product_specScalarWhereInput[]
    NOT?: product_specScalarWhereInput | product_specScalarWhereInput[]
    id?: IntFilter<"product_spec"> | number
    name?: StringFilter<"product_spec"> | string
    data?: JsonFilter<"product_spec">
    productId?: IntFilter<"product_spec"> | number
  }

  export type product_detailUpsertWithWhereUniqueWithoutProductInput = {
    where: product_detailWhereUniqueInput
    update: XOR<product_detailUpdateWithoutProductInput, product_detailUncheckedUpdateWithoutProductInput>
    create: XOR<product_detailCreateWithoutProductInput, product_detailUncheckedCreateWithoutProductInput>
  }

  export type product_detailUpdateWithWhereUniqueWithoutProductInput = {
    where: product_detailWhereUniqueInput
    data: XOR<product_detailUpdateWithoutProductInput, product_detailUncheckedUpdateWithoutProductInput>
  }

  export type product_detailUpdateManyWithWhereWithoutProductInput = {
    where: product_detailScalarWhereInput
    data: XOR<product_detailUpdateManyMutationInput, product_detailUncheckedUpdateManyWithoutProductInput>
  }

  export type product_detailScalarWhereInput = {
    AND?: product_detailScalarWhereInput | product_detailScalarWhereInput[]
    OR?: product_detailScalarWhereInput[]
    NOT?: product_detailScalarWhereInput | product_detailScalarWhereInput[]
    id?: IntFilter<"product_detail"> | number
    productId?: IntFilter<"product_detail"> | number
    name?: StringFilter<"product_detail"> | string
    details?: StringNullableFilter<"product_detail"> | string | null
    imagePath?: StringNullableFilter<"product_detail"> | string | null
    imageSrc?: StringNullableFilter<"product_detail"> | string | null
    videoPath?: StringNullableFilter<"product_detail"> | string | null
    videoSrc?: StringNullableFilter<"product_detail"> | string | null
    videoType?: StringNullableFilter<"product_detail"> | string | null
    link?: StringNullableFilter<"product_detail"> | string | null
    isActive?: BoolFilter<"product_detail"> | boolean
    createdAt?: DateTimeFilter<"product_detail"> | Date | string
    updatedAt?: DateTimeFilter<"product_detail"> | Date | string
  }

  export type product_option_firstUpsertWithWhereUniqueWithoutProductInput = {
    where: product_option_firstWhereUniqueInput
    update: XOR<product_option_firstUpdateWithoutProductInput, product_option_firstUncheckedUpdateWithoutProductInput>
    create: XOR<product_option_firstCreateWithoutProductInput, product_option_firstUncheckedCreateWithoutProductInput>
  }

  export type product_option_firstUpdateWithWhereUniqueWithoutProductInput = {
    where: product_option_firstWhereUniqueInput
    data: XOR<product_option_firstUpdateWithoutProductInput, product_option_firstUncheckedUpdateWithoutProductInput>
  }

  export type product_option_firstUpdateManyWithWhereWithoutProductInput = {
    where: product_option_firstScalarWhereInput
    data: XOR<product_option_firstUpdateManyMutationInput, product_option_firstUncheckedUpdateManyWithoutProductInput>
  }

  export type product_option_firstScalarWhereInput = {
    AND?: product_option_firstScalarWhereInput | product_option_firstScalarWhereInput[]
    OR?: product_option_firstScalarWhereInput[]
    NOT?: product_option_firstScalarWhereInput | product_option_firstScalarWhereInput[]
    id?: IntFilter<"product_option_first"> | number
    productId?: IntFilter<"product_option_first"> | number
    name?: StringFilter<"product_option_first"> | string
    isActive?: BoolFilter<"product_option_first"> | boolean
    createdAt?: DateTimeFilter<"product_option_first"> | Date | string
    updatedAt?: DateTimeFilter<"product_option_first"> | Date | string
  }

  export type product_option_secondUpsertWithWhereUniqueWithoutProductInput = {
    where: product_option_secondWhereUniqueInput
    update: XOR<product_option_secondUpdateWithoutProductInput, product_option_secondUncheckedUpdateWithoutProductInput>
    create: XOR<product_option_secondCreateWithoutProductInput, product_option_secondUncheckedCreateWithoutProductInput>
  }

  export type product_option_secondUpdateWithWhereUniqueWithoutProductInput = {
    where: product_option_secondWhereUniqueInput
    data: XOR<product_option_secondUpdateWithoutProductInput, product_option_secondUncheckedUpdateWithoutProductInput>
  }

  export type product_option_secondUpdateManyWithWhereWithoutProductInput = {
    where: product_option_secondScalarWhereInput
    data: XOR<product_option_secondUpdateManyMutationInput, product_option_secondUncheckedUpdateManyWithoutProductInput>
  }

  export type product_option_secondScalarWhereInput = {
    AND?: product_option_secondScalarWhereInput | product_option_secondScalarWhereInput[]
    OR?: product_option_secondScalarWhereInput[]
    NOT?: product_option_secondScalarWhereInput | product_option_secondScalarWhereInput[]
    id?: IntFilter<"product_option_second"> | number
    productId?: IntFilter<"product_option_second"> | number
    name?: StringFilter<"product_option_second"> | string
    isActive?: BoolFilter<"product_option_second"> | boolean
    createdAt?: DateTimeFilter<"product_option_second"> | Date | string
    updatedAt?: DateTimeFilter<"product_option_second"> | Date | string
  }

  export type product_priceUpsertWithWhereUniqueWithoutProductInput = {
    where: product_priceWhereUniqueInput
    update: XOR<product_priceUpdateWithoutProductInput, product_priceUncheckedUpdateWithoutProductInput>
    create: XOR<product_priceCreateWithoutProductInput, product_priceUncheckedCreateWithoutProductInput>
  }

  export type product_priceUpdateWithWhereUniqueWithoutProductInput = {
    where: product_priceWhereUniqueInput
    data: XOR<product_priceUpdateWithoutProductInput, product_priceUncheckedUpdateWithoutProductInput>
  }

  export type product_priceUpdateManyWithWhereWithoutProductInput = {
    where: product_priceScalarWhereInput
    data: XOR<product_priceUpdateManyMutationInput, product_priceUncheckedUpdateManyWithoutProductInput>
  }

  export type product_priceScalarWhereInput = {
    AND?: product_priceScalarWhereInput | product_priceScalarWhereInput[]
    OR?: product_priceScalarWhereInput[]
    NOT?: product_priceScalarWhereInput | product_priceScalarWhereInput[]
    id?: IntFilter<"product_price"> | number
    productId?: IntFilter<"product_price"> | number
    product_option_firstId?: IntNullableFilter<"product_price"> | number | null
    product_option_secondId?: IntNullableFilter<"product_price"> | number | null
    price?: FloatFilter<"product_price"> | number
    sku?: StringNullableFilter<"product_price"> | string | null
    isWholesale?: BoolFilter<"product_price"> | boolean
  }

  export type product_wholesaleUpsertWithWhereUniqueWithoutProductInput = {
    where: product_wholesaleWhereUniqueInput
    update: XOR<product_wholesaleUpdateWithoutProductInput, product_wholesaleUncheckedUpdateWithoutProductInput>
    create: XOR<product_wholesaleCreateWithoutProductInput, product_wholesaleUncheckedCreateWithoutProductInput>
  }

  export type product_wholesaleUpdateWithWhereUniqueWithoutProductInput = {
    where: product_wholesaleWhereUniqueInput
    data: XOR<product_wholesaleUpdateWithoutProductInput, product_wholesaleUncheckedUpdateWithoutProductInput>
  }

  export type product_wholesaleUpdateManyWithWhereWithoutProductInput = {
    where: product_wholesaleScalarWhereInput
    data: XOR<product_wholesaleUpdateManyMutationInput, product_wholesaleUncheckedUpdateManyWithoutProductInput>
  }

  export type product_wholesaleScalarWhereInput = {
    AND?: product_wholesaleScalarWhereInput | product_wholesaleScalarWhereInput[]
    OR?: product_wholesaleScalarWhereInput[]
    NOT?: product_wholesaleScalarWhereInput | product_wholesaleScalarWhereInput[]
    id?: IntFilter<"product_wholesale"> | number
    productId?: IntFilter<"product_wholesale"> | number
    min?: IntFilter<"product_wholesale"> | number
    price?: FloatFilter<"product_wholesale"> | number
    isActive?: BoolFilter<"product_wholesale"> | boolean
    createdAt?: DateTimeFilter<"product_wholesale"> | Date | string
    updatedAt?: DateTimeFilter<"product_wholesale"> | Date | string
  }

  export type product_reviewUpsertWithWhereUniqueWithoutProductInput = {
    where: product_reviewWhereUniqueInput
    update: XOR<product_reviewUpdateWithoutProductInput, product_reviewUncheckedUpdateWithoutProductInput>
    create: XOR<product_reviewCreateWithoutProductInput, product_reviewUncheckedCreateWithoutProductInput>
  }

  export type product_reviewUpdateWithWhereUniqueWithoutProductInput = {
    where: product_reviewWhereUniqueInput
    data: XOR<product_reviewUpdateWithoutProductInput, product_reviewUncheckedUpdateWithoutProductInput>
  }

  export type product_reviewUpdateManyWithWhereWithoutProductInput = {
    where: product_reviewScalarWhereInput
    data: XOR<product_reviewUpdateManyMutationInput, product_reviewUncheckedUpdateManyWithoutProductInput>
  }

  export type product_tagUpsertWithWhereUniqueWithoutProductInput = {
    where: product_tagWhereUniqueInput
    update: XOR<product_tagUpdateWithoutProductInput, product_tagUncheckedUpdateWithoutProductInput>
    create: XOR<product_tagCreateWithoutProductInput, product_tagUncheckedCreateWithoutProductInput>
  }

  export type product_tagUpdateWithWhereUniqueWithoutProductInput = {
    where: product_tagWhereUniqueInput
    data: XOR<product_tagUpdateWithoutProductInput, product_tagUncheckedUpdateWithoutProductInput>
  }

  export type product_tagUpdateManyWithWhereWithoutProductInput = {
    where: product_tagScalarWhereInput
    data: XOR<product_tagUpdateManyMutationInput, product_tagUncheckedUpdateManyWithoutProductInput>
  }

  export type cartUpsertWithWhereUniqueWithoutProductInput = {
    where: cartWhereUniqueInput
    update: XOR<cartUpdateWithoutProductInput, cartUncheckedUpdateWithoutProductInput>
    create: XOR<cartCreateWithoutProductInput, cartUncheckedCreateWithoutProductInput>
  }

  export type cartUpdateWithWhereUniqueWithoutProductInput = {
    where: cartWhereUniqueInput
    data: XOR<cartUpdateWithoutProductInput, cartUncheckedUpdateWithoutProductInput>
  }

  export type cartUpdateManyWithWhereWithoutProductInput = {
    where: cartScalarWhereInput
    data: XOR<cartUpdateManyMutationInput, cartUncheckedUpdateManyWithoutProductInput>
  }

  export type order_productUpsertWithWhereUniqueWithoutProductInput = {
    where: order_productWhereUniqueInput
    update: XOR<order_productUpdateWithoutProductInput, order_productUncheckedUpdateWithoutProductInput>
    create: XOR<order_productCreateWithoutProductInput, order_productUncheckedCreateWithoutProductInput>
  }

  export type order_productUpdateWithWhereUniqueWithoutProductInput = {
    where: order_productWhereUniqueInput
    data: XOR<order_productUpdateWithoutProductInput, order_productUncheckedUpdateWithoutProductInput>
  }

  export type order_productUpdateManyWithWhereWithoutProductInput = {
    where: order_productScalarWhereInput
    data: XOR<order_productUpdateManyMutationInput, order_productUncheckedUpdateManyWithoutProductInput>
  }

  export type productCreateWithoutProduct_tagInput = {
    name: string
    shortName?: string | null
    detail?: string | null
    isDiscount?: boolean
    discountPercent: number
    minPrice: number
    maxPrice: number
    slug: string
    cardImgPath: string
    cardImgSrc: string
    optionFirst?: string | null
    optionSecond?: string | null
    isWholesale?: boolean
    rating?: number
    sold?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    brand: brandCreateNestedOneWithoutProductInput
    admin: adminCreateNestedOneWithoutProductInput
    product_image?: product_imageCreateNestedManyWithoutProductInput
    product_spec?: product_specCreateNestedManyWithoutProductInput
    product_detail?: product_detailCreateNestedManyWithoutProductInput
    product_option_first?: product_option_firstCreateNestedManyWithoutProductInput
    product_option_second?: product_option_secondCreateNestedManyWithoutProductInput
    product_price?: product_priceCreateNestedManyWithoutProductInput
    product_wholesale?: product_wholesaleCreateNestedManyWithoutProductInput
    product_review?: product_reviewCreateNestedManyWithoutProductInput
    cart?: cartCreateNestedManyWithoutProductInput
    order_product?: order_productCreateNestedManyWithoutProductInput
  }

  export type productUncheckedCreateWithoutProduct_tagInput = {
    id?: number
    brandId: number
    adminId: number
    name: string
    shortName?: string | null
    detail?: string | null
    isDiscount?: boolean
    discountPercent: number
    minPrice: number
    maxPrice: number
    slug: string
    cardImgPath: string
    cardImgSrc: string
    optionFirst?: string | null
    optionSecond?: string | null
    isWholesale?: boolean
    rating?: number
    sold?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    product_image?: product_imageUncheckedCreateNestedManyWithoutProductInput
    product_spec?: product_specUncheckedCreateNestedManyWithoutProductInput
    product_detail?: product_detailUncheckedCreateNestedManyWithoutProductInput
    product_option_first?: product_option_firstUncheckedCreateNestedManyWithoutProductInput
    product_option_second?: product_option_secondUncheckedCreateNestedManyWithoutProductInput
    product_price?: product_priceUncheckedCreateNestedManyWithoutProductInput
    product_wholesale?: product_wholesaleUncheckedCreateNestedManyWithoutProductInput
    product_review?: product_reviewUncheckedCreateNestedManyWithoutProductInput
    cart?: cartUncheckedCreateNestedManyWithoutProductInput
    order_product?: order_productUncheckedCreateNestedManyWithoutProductInput
  }

  export type productCreateOrConnectWithoutProduct_tagInput = {
    where: productWhereUniqueInput
    create: XOR<productCreateWithoutProduct_tagInput, productUncheckedCreateWithoutProduct_tagInput>
  }

  export type tagCreateWithoutProduct_tagInput = {
    name: string
    detail?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type tagUncheckedCreateWithoutProduct_tagInput = {
    id?: number
    name: string
    detail?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type tagCreateOrConnectWithoutProduct_tagInput = {
    where: tagWhereUniqueInput
    create: XOR<tagCreateWithoutProduct_tagInput, tagUncheckedCreateWithoutProduct_tagInput>
  }

  export type productUpsertWithoutProduct_tagInput = {
    update: XOR<productUpdateWithoutProduct_tagInput, productUncheckedUpdateWithoutProduct_tagInput>
    create: XOR<productCreateWithoutProduct_tagInput, productUncheckedCreateWithoutProduct_tagInput>
    where?: productWhereInput
  }

  export type productUpdateToOneWithWhereWithoutProduct_tagInput = {
    where?: productWhereInput
    data: XOR<productUpdateWithoutProduct_tagInput, productUncheckedUpdateWithoutProduct_tagInput>
  }

  export type productUpdateWithoutProduct_tagInput = {
    name?: StringFieldUpdateOperationsInput | string
    shortName?: NullableStringFieldUpdateOperationsInput | string | null
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    isDiscount?: BoolFieldUpdateOperationsInput | boolean
    discountPercent?: IntFieldUpdateOperationsInput | number
    minPrice?: FloatFieldUpdateOperationsInput | number
    maxPrice?: FloatFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    cardImgPath?: StringFieldUpdateOperationsInput | string
    cardImgSrc?: StringFieldUpdateOperationsInput | string
    optionFirst?: NullableStringFieldUpdateOperationsInput | string | null
    optionSecond?: NullableStringFieldUpdateOperationsInput | string | null
    isWholesale?: BoolFieldUpdateOperationsInput | boolean
    rating?: IntFieldUpdateOperationsInput | number
    sold?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    brand?: brandUpdateOneRequiredWithoutProductNestedInput
    admin?: adminUpdateOneRequiredWithoutProductNestedInput
    product_image?: product_imageUpdateManyWithoutProductNestedInput
    product_spec?: product_specUpdateManyWithoutProductNestedInput
    product_detail?: product_detailUpdateManyWithoutProductNestedInput
    product_option_first?: product_option_firstUpdateManyWithoutProductNestedInput
    product_option_second?: product_option_secondUpdateManyWithoutProductNestedInput
    product_price?: product_priceUpdateManyWithoutProductNestedInput
    product_wholesale?: product_wholesaleUpdateManyWithoutProductNestedInput
    product_review?: product_reviewUpdateManyWithoutProductNestedInput
    cart?: cartUpdateManyWithoutProductNestedInput
    order_product?: order_productUpdateManyWithoutProductNestedInput
  }

  export type productUncheckedUpdateWithoutProduct_tagInput = {
    id?: IntFieldUpdateOperationsInput | number
    brandId?: IntFieldUpdateOperationsInput | number
    adminId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    shortName?: NullableStringFieldUpdateOperationsInput | string | null
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    isDiscount?: BoolFieldUpdateOperationsInput | boolean
    discountPercent?: IntFieldUpdateOperationsInput | number
    minPrice?: FloatFieldUpdateOperationsInput | number
    maxPrice?: FloatFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    cardImgPath?: StringFieldUpdateOperationsInput | string
    cardImgSrc?: StringFieldUpdateOperationsInput | string
    optionFirst?: NullableStringFieldUpdateOperationsInput | string | null
    optionSecond?: NullableStringFieldUpdateOperationsInput | string | null
    isWholesale?: BoolFieldUpdateOperationsInput | boolean
    rating?: IntFieldUpdateOperationsInput | number
    sold?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product_image?: product_imageUncheckedUpdateManyWithoutProductNestedInput
    product_spec?: product_specUncheckedUpdateManyWithoutProductNestedInput
    product_detail?: product_detailUncheckedUpdateManyWithoutProductNestedInput
    product_option_first?: product_option_firstUncheckedUpdateManyWithoutProductNestedInput
    product_option_second?: product_option_secondUncheckedUpdateManyWithoutProductNestedInput
    product_price?: product_priceUncheckedUpdateManyWithoutProductNestedInput
    product_wholesale?: product_wholesaleUncheckedUpdateManyWithoutProductNestedInput
    product_review?: product_reviewUncheckedUpdateManyWithoutProductNestedInput
    cart?: cartUncheckedUpdateManyWithoutProductNestedInput
    order_product?: order_productUncheckedUpdateManyWithoutProductNestedInput
  }

  export type tagUpsertWithoutProduct_tagInput = {
    update: XOR<tagUpdateWithoutProduct_tagInput, tagUncheckedUpdateWithoutProduct_tagInput>
    create: XOR<tagCreateWithoutProduct_tagInput, tagUncheckedCreateWithoutProduct_tagInput>
    where?: tagWhereInput
  }

  export type tagUpdateToOneWithWhereWithoutProduct_tagInput = {
    where?: tagWhereInput
    data: XOR<tagUpdateWithoutProduct_tagInput, tagUncheckedUpdateWithoutProduct_tagInput>
  }

  export type tagUpdateWithoutProduct_tagInput = {
    name?: StringFieldUpdateOperationsInput | string
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tagUncheckedUpdateWithoutProduct_tagInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type productCreateWithoutProduct_wholesaleInput = {
    name: string
    shortName?: string | null
    detail?: string | null
    isDiscount?: boolean
    discountPercent: number
    minPrice: number
    maxPrice: number
    slug: string
    cardImgPath: string
    cardImgSrc: string
    optionFirst?: string | null
    optionSecond?: string | null
    isWholesale?: boolean
    rating?: number
    sold?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    brand: brandCreateNestedOneWithoutProductInput
    admin: adminCreateNestedOneWithoutProductInput
    product_image?: product_imageCreateNestedManyWithoutProductInput
    product_spec?: product_specCreateNestedManyWithoutProductInput
    product_detail?: product_detailCreateNestedManyWithoutProductInput
    product_option_first?: product_option_firstCreateNestedManyWithoutProductInput
    product_option_second?: product_option_secondCreateNestedManyWithoutProductInput
    product_price?: product_priceCreateNestedManyWithoutProductInput
    product_review?: product_reviewCreateNestedManyWithoutProductInput
    product_tag?: product_tagCreateNestedManyWithoutProductInput
    cart?: cartCreateNestedManyWithoutProductInput
    order_product?: order_productCreateNestedManyWithoutProductInput
  }

  export type productUncheckedCreateWithoutProduct_wholesaleInput = {
    id?: number
    brandId: number
    adminId: number
    name: string
    shortName?: string | null
    detail?: string | null
    isDiscount?: boolean
    discountPercent: number
    minPrice: number
    maxPrice: number
    slug: string
    cardImgPath: string
    cardImgSrc: string
    optionFirst?: string | null
    optionSecond?: string | null
    isWholesale?: boolean
    rating?: number
    sold?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    product_image?: product_imageUncheckedCreateNestedManyWithoutProductInput
    product_spec?: product_specUncheckedCreateNestedManyWithoutProductInput
    product_detail?: product_detailUncheckedCreateNestedManyWithoutProductInput
    product_option_first?: product_option_firstUncheckedCreateNestedManyWithoutProductInput
    product_option_second?: product_option_secondUncheckedCreateNestedManyWithoutProductInput
    product_price?: product_priceUncheckedCreateNestedManyWithoutProductInput
    product_review?: product_reviewUncheckedCreateNestedManyWithoutProductInput
    product_tag?: product_tagUncheckedCreateNestedManyWithoutProductInput
    cart?: cartUncheckedCreateNestedManyWithoutProductInput
    order_product?: order_productUncheckedCreateNestedManyWithoutProductInput
  }

  export type productCreateOrConnectWithoutProduct_wholesaleInput = {
    where: productWhereUniqueInput
    create: XOR<productCreateWithoutProduct_wholesaleInput, productUncheckedCreateWithoutProduct_wholesaleInput>
  }

  export type productUpsertWithoutProduct_wholesaleInput = {
    update: XOR<productUpdateWithoutProduct_wholesaleInput, productUncheckedUpdateWithoutProduct_wholesaleInput>
    create: XOR<productCreateWithoutProduct_wholesaleInput, productUncheckedCreateWithoutProduct_wholesaleInput>
    where?: productWhereInput
  }

  export type productUpdateToOneWithWhereWithoutProduct_wholesaleInput = {
    where?: productWhereInput
    data: XOR<productUpdateWithoutProduct_wholesaleInput, productUncheckedUpdateWithoutProduct_wholesaleInput>
  }

  export type productUpdateWithoutProduct_wholesaleInput = {
    name?: StringFieldUpdateOperationsInput | string
    shortName?: NullableStringFieldUpdateOperationsInput | string | null
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    isDiscount?: BoolFieldUpdateOperationsInput | boolean
    discountPercent?: IntFieldUpdateOperationsInput | number
    minPrice?: FloatFieldUpdateOperationsInput | number
    maxPrice?: FloatFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    cardImgPath?: StringFieldUpdateOperationsInput | string
    cardImgSrc?: StringFieldUpdateOperationsInput | string
    optionFirst?: NullableStringFieldUpdateOperationsInput | string | null
    optionSecond?: NullableStringFieldUpdateOperationsInput | string | null
    isWholesale?: BoolFieldUpdateOperationsInput | boolean
    rating?: IntFieldUpdateOperationsInput | number
    sold?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    brand?: brandUpdateOneRequiredWithoutProductNestedInput
    admin?: adminUpdateOneRequiredWithoutProductNestedInput
    product_image?: product_imageUpdateManyWithoutProductNestedInput
    product_spec?: product_specUpdateManyWithoutProductNestedInput
    product_detail?: product_detailUpdateManyWithoutProductNestedInput
    product_option_first?: product_option_firstUpdateManyWithoutProductNestedInput
    product_option_second?: product_option_secondUpdateManyWithoutProductNestedInput
    product_price?: product_priceUpdateManyWithoutProductNestedInput
    product_review?: product_reviewUpdateManyWithoutProductNestedInput
    product_tag?: product_tagUpdateManyWithoutProductNestedInput
    cart?: cartUpdateManyWithoutProductNestedInput
    order_product?: order_productUpdateManyWithoutProductNestedInput
  }

  export type productUncheckedUpdateWithoutProduct_wholesaleInput = {
    id?: IntFieldUpdateOperationsInput | number
    brandId?: IntFieldUpdateOperationsInput | number
    adminId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    shortName?: NullableStringFieldUpdateOperationsInput | string | null
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    isDiscount?: BoolFieldUpdateOperationsInput | boolean
    discountPercent?: IntFieldUpdateOperationsInput | number
    minPrice?: FloatFieldUpdateOperationsInput | number
    maxPrice?: FloatFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    cardImgPath?: StringFieldUpdateOperationsInput | string
    cardImgSrc?: StringFieldUpdateOperationsInput | string
    optionFirst?: NullableStringFieldUpdateOperationsInput | string | null
    optionSecond?: NullableStringFieldUpdateOperationsInput | string | null
    isWholesale?: BoolFieldUpdateOperationsInput | boolean
    rating?: IntFieldUpdateOperationsInput | number
    sold?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product_image?: product_imageUncheckedUpdateManyWithoutProductNestedInput
    product_spec?: product_specUncheckedUpdateManyWithoutProductNestedInput
    product_detail?: product_detailUncheckedUpdateManyWithoutProductNestedInput
    product_option_first?: product_option_firstUncheckedUpdateManyWithoutProductNestedInput
    product_option_second?: product_option_secondUncheckedUpdateManyWithoutProductNestedInput
    product_price?: product_priceUncheckedUpdateManyWithoutProductNestedInput
    product_review?: product_reviewUncheckedUpdateManyWithoutProductNestedInput
    product_tag?: product_tagUncheckedUpdateManyWithoutProductNestedInput
    cart?: cartUncheckedUpdateManyWithoutProductNestedInput
    order_product?: order_productUncheckedUpdateManyWithoutProductNestedInput
  }

  export type productCreateWithoutProduct_option_firstInput = {
    name: string
    shortName?: string | null
    detail?: string | null
    isDiscount?: boolean
    discountPercent: number
    minPrice: number
    maxPrice: number
    slug: string
    cardImgPath: string
    cardImgSrc: string
    optionFirst?: string | null
    optionSecond?: string | null
    isWholesale?: boolean
    rating?: number
    sold?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    brand: brandCreateNestedOneWithoutProductInput
    admin: adminCreateNestedOneWithoutProductInput
    product_image?: product_imageCreateNestedManyWithoutProductInput
    product_spec?: product_specCreateNestedManyWithoutProductInput
    product_detail?: product_detailCreateNestedManyWithoutProductInput
    product_option_second?: product_option_secondCreateNestedManyWithoutProductInput
    product_price?: product_priceCreateNestedManyWithoutProductInput
    product_wholesale?: product_wholesaleCreateNestedManyWithoutProductInput
    product_review?: product_reviewCreateNestedManyWithoutProductInput
    product_tag?: product_tagCreateNestedManyWithoutProductInput
    cart?: cartCreateNestedManyWithoutProductInput
    order_product?: order_productCreateNestedManyWithoutProductInput
  }

  export type productUncheckedCreateWithoutProduct_option_firstInput = {
    id?: number
    brandId: number
    adminId: number
    name: string
    shortName?: string | null
    detail?: string | null
    isDiscount?: boolean
    discountPercent: number
    minPrice: number
    maxPrice: number
    slug: string
    cardImgPath: string
    cardImgSrc: string
    optionFirst?: string | null
    optionSecond?: string | null
    isWholesale?: boolean
    rating?: number
    sold?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    product_image?: product_imageUncheckedCreateNestedManyWithoutProductInput
    product_spec?: product_specUncheckedCreateNestedManyWithoutProductInput
    product_detail?: product_detailUncheckedCreateNestedManyWithoutProductInput
    product_option_second?: product_option_secondUncheckedCreateNestedManyWithoutProductInput
    product_price?: product_priceUncheckedCreateNestedManyWithoutProductInput
    product_wholesale?: product_wholesaleUncheckedCreateNestedManyWithoutProductInput
    product_review?: product_reviewUncheckedCreateNestedManyWithoutProductInput
    product_tag?: product_tagUncheckedCreateNestedManyWithoutProductInput
    cart?: cartUncheckedCreateNestedManyWithoutProductInput
    order_product?: order_productUncheckedCreateNestedManyWithoutProductInput
  }

  export type productCreateOrConnectWithoutProduct_option_firstInput = {
    where: productWhereUniqueInput
    create: XOR<productCreateWithoutProduct_option_firstInput, productUncheckedCreateWithoutProduct_option_firstInput>
  }

  export type product_priceCreateWithoutProduct_option_firstInput = {
    price: number
    sku?: string | null
    isWholesale?: boolean
    product: productCreateNestedOneWithoutProduct_priceInput
    product_option_second?: product_option_secondCreateNestedOneWithoutProduct_priceInput
    cart?: cartCreateNestedManyWithoutProduct_priceInput
    order_product?: order_productCreateNestedManyWithoutProduct_priceInput
  }

  export type product_priceUncheckedCreateWithoutProduct_option_firstInput = {
    id?: number
    productId: number
    product_option_secondId?: number | null
    price: number
    sku?: string | null
    isWholesale?: boolean
    cart?: cartUncheckedCreateNestedManyWithoutProduct_priceInput
    order_product?: order_productUncheckedCreateNestedManyWithoutProduct_priceInput
  }

  export type product_priceCreateOrConnectWithoutProduct_option_firstInput = {
    where: product_priceWhereUniqueInput
    create: XOR<product_priceCreateWithoutProduct_option_firstInput, product_priceUncheckedCreateWithoutProduct_option_firstInput>
  }

  export type product_priceCreateManyProduct_option_firstInputEnvelope = {
    data: product_priceCreateManyProduct_option_firstInput | product_priceCreateManyProduct_option_firstInput[]
    skipDuplicates?: boolean
  }

  export type productUpsertWithoutProduct_option_firstInput = {
    update: XOR<productUpdateWithoutProduct_option_firstInput, productUncheckedUpdateWithoutProduct_option_firstInput>
    create: XOR<productCreateWithoutProduct_option_firstInput, productUncheckedCreateWithoutProduct_option_firstInput>
    where?: productWhereInput
  }

  export type productUpdateToOneWithWhereWithoutProduct_option_firstInput = {
    where?: productWhereInput
    data: XOR<productUpdateWithoutProduct_option_firstInput, productUncheckedUpdateWithoutProduct_option_firstInput>
  }

  export type productUpdateWithoutProduct_option_firstInput = {
    name?: StringFieldUpdateOperationsInput | string
    shortName?: NullableStringFieldUpdateOperationsInput | string | null
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    isDiscount?: BoolFieldUpdateOperationsInput | boolean
    discountPercent?: IntFieldUpdateOperationsInput | number
    minPrice?: FloatFieldUpdateOperationsInput | number
    maxPrice?: FloatFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    cardImgPath?: StringFieldUpdateOperationsInput | string
    cardImgSrc?: StringFieldUpdateOperationsInput | string
    optionFirst?: NullableStringFieldUpdateOperationsInput | string | null
    optionSecond?: NullableStringFieldUpdateOperationsInput | string | null
    isWholesale?: BoolFieldUpdateOperationsInput | boolean
    rating?: IntFieldUpdateOperationsInput | number
    sold?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    brand?: brandUpdateOneRequiredWithoutProductNestedInput
    admin?: adminUpdateOneRequiredWithoutProductNestedInput
    product_image?: product_imageUpdateManyWithoutProductNestedInput
    product_spec?: product_specUpdateManyWithoutProductNestedInput
    product_detail?: product_detailUpdateManyWithoutProductNestedInput
    product_option_second?: product_option_secondUpdateManyWithoutProductNestedInput
    product_price?: product_priceUpdateManyWithoutProductNestedInput
    product_wholesale?: product_wholesaleUpdateManyWithoutProductNestedInput
    product_review?: product_reviewUpdateManyWithoutProductNestedInput
    product_tag?: product_tagUpdateManyWithoutProductNestedInput
    cart?: cartUpdateManyWithoutProductNestedInput
    order_product?: order_productUpdateManyWithoutProductNestedInput
  }

  export type productUncheckedUpdateWithoutProduct_option_firstInput = {
    id?: IntFieldUpdateOperationsInput | number
    brandId?: IntFieldUpdateOperationsInput | number
    adminId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    shortName?: NullableStringFieldUpdateOperationsInput | string | null
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    isDiscount?: BoolFieldUpdateOperationsInput | boolean
    discountPercent?: IntFieldUpdateOperationsInput | number
    minPrice?: FloatFieldUpdateOperationsInput | number
    maxPrice?: FloatFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    cardImgPath?: StringFieldUpdateOperationsInput | string
    cardImgSrc?: StringFieldUpdateOperationsInput | string
    optionFirst?: NullableStringFieldUpdateOperationsInput | string | null
    optionSecond?: NullableStringFieldUpdateOperationsInput | string | null
    isWholesale?: BoolFieldUpdateOperationsInput | boolean
    rating?: IntFieldUpdateOperationsInput | number
    sold?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product_image?: product_imageUncheckedUpdateManyWithoutProductNestedInput
    product_spec?: product_specUncheckedUpdateManyWithoutProductNestedInput
    product_detail?: product_detailUncheckedUpdateManyWithoutProductNestedInput
    product_option_second?: product_option_secondUncheckedUpdateManyWithoutProductNestedInput
    product_price?: product_priceUncheckedUpdateManyWithoutProductNestedInput
    product_wholesale?: product_wholesaleUncheckedUpdateManyWithoutProductNestedInput
    product_review?: product_reviewUncheckedUpdateManyWithoutProductNestedInput
    product_tag?: product_tagUncheckedUpdateManyWithoutProductNestedInput
    cart?: cartUncheckedUpdateManyWithoutProductNestedInput
    order_product?: order_productUncheckedUpdateManyWithoutProductNestedInput
  }

  export type product_priceUpsertWithWhereUniqueWithoutProduct_option_firstInput = {
    where: product_priceWhereUniqueInput
    update: XOR<product_priceUpdateWithoutProduct_option_firstInput, product_priceUncheckedUpdateWithoutProduct_option_firstInput>
    create: XOR<product_priceCreateWithoutProduct_option_firstInput, product_priceUncheckedCreateWithoutProduct_option_firstInput>
  }

  export type product_priceUpdateWithWhereUniqueWithoutProduct_option_firstInput = {
    where: product_priceWhereUniqueInput
    data: XOR<product_priceUpdateWithoutProduct_option_firstInput, product_priceUncheckedUpdateWithoutProduct_option_firstInput>
  }

  export type product_priceUpdateManyWithWhereWithoutProduct_option_firstInput = {
    where: product_priceScalarWhereInput
    data: XOR<product_priceUpdateManyMutationInput, product_priceUncheckedUpdateManyWithoutProduct_option_firstInput>
  }

  export type productCreateWithoutProduct_option_secondInput = {
    name: string
    shortName?: string | null
    detail?: string | null
    isDiscount?: boolean
    discountPercent: number
    minPrice: number
    maxPrice: number
    slug: string
    cardImgPath: string
    cardImgSrc: string
    optionFirst?: string | null
    optionSecond?: string | null
    isWholesale?: boolean
    rating?: number
    sold?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    brand: brandCreateNestedOneWithoutProductInput
    admin: adminCreateNestedOneWithoutProductInput
    product_image?: product_imageCreateNestedManyWithoutProductInput
    product_spec?: product_specCreateNestedManyWithoutProductInput
    product_detail?: product_detailCreateNestedManyWithoutProductInput
    product_option_first?: product_option_firstCreateNestedManyWithoutProductInput
    product_price?: product_priceCreateNestedManyWithoutProductInput
    product_wholesale?: product_wholesaleCreateNestedManyWithoutProductInput
    product_review?: product_reviewCreateNestedManyWithoutProductInput
    product_tag?: product_tagCreateNestedManyWithoutProductInput
    cart?: cartCreateNestedManyWithoutProductInput
    order_product?: order_productCreateNestedManyWithoutProductInput
  }

  export type productUncheckedCreateWithoutProduct_option_secondInput = {
    id?: number
    brandId: number
    adminId: number
    name: string
    shortName?: string | null
    detail?: string | null
    isDiscount?: boolean
    discountPercent: number
    minPrice: number
    maxPrice: number
    slug: string
    cardImgPath: string
    cardImgSrc: string
    optionFirst?: string | null
    optionSecond?: string | null
    isWholesale?: boolean
    rating?: number
    sold?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    product_image?: product_imageUncheckedCreateNestedManyWithoutProductInput
    product_spec?: product_specUncheckedCreateNestedManyWithoutProductInput
    product_detail?: product_detailUncheckedCreateNestedManyWithoutProductInput
    product_option_first?: product_option_firstUncheckedCreateNestedManyWithoutProductInput
    product_price?: product_priceUncheckedCreateNestedManyWithoutProductInput
    product_wholesale?: product_wholesaleUncheckedCreateNestedManyWithoutProductInput
    product_review?: product_reviewUncheckedCreateNestedManyWithoutProductInput
    product_tag?: product_tagUncheckedCreateNestedManyWithoutProductInput
    cart?: cartUncheckedCreateNestedManyWithoutProductInput
    order_product?: order_productUncheckedCreateNestedManyWithoutProductInput
  }

  export type productCreateOrConnectWithoutProduct_option_secondInput = {
    where: productWhereUniqueInput
    create: XOR<productCreateWithoutProduct_option_secondInput, productUncheckedCreateWithoutProduct_option_secondInput>
  }

  export type product_priceCreateWithoutProduct_option_secondInput = {
    price: number
    sku?: string | null
    isWholesale?: boolean
    product: productCreateNestedOneWithoutProduct_priceInput
    product_option_first?: product_option_firstCreateNestedOneWithoutProduct_priceInput
    cart?: cartCreateNestedManyWithoutProduct_priceInput
    order_product?: order_productCreateNestedManyWithoutProduct_priceInput
  }

  export type product_priceUncheckedCreateWithoutProduct_option_secondInput = {
    id?: number
    productId: number
    product_option_firstId?: number | null
    price: number
    sku?: string | null
    isWholesale?: boolean
    cart?: cartUncheckedCreateNestedManyWithoutProduct_priceInput
    order_product?: order_productUncheckedCreateNestedManyWithoutProduct_priceInput
  }

  export type product_priceCreateOrConnectWithoutProduct_option_secondInput = {
    where: product_priceWhereUniqueInput
    create: XOR<product_priceCreateWithoutProduct_option_secondInput, product_priceUncheckedCreateWithoutProduct_option_secondInput>
  }

  export type product_priceCreateManyProduct_option_secondInputEnvelope = {
    data: product_priceCreateManyProduct_option_secondInput | product_priceCreateManyProduct_option_secondInput[]
    skipDuplicates?: boolean
  }

  export type productUpsertWithoutProduct_option_secondInput = {
    update: XOR<productUpdateWithoutProduct_option_secondInput, productUncheckedUpdateWithoutProduct_option_secondInput>
    create: XOR<productCreateWithoutProduct_option_secondInput, productUncheckedCreateWithoutProduct_option_secondInput>
    where?: productWhereInput
  }

  export type productUpdateToOneWithWhereWithoutProduct_option_secondInput = {
    where?: productWhereInput
    data: XOR<productUpdateWithoutProduct_option_secondInput, productUncheckedUpdateWithoutProduct_option_secondInput>
  }

  export type productUpdateWithoutProduct_option_secondInput = {
    name?: StringFieldUpdateOperationsInput | string
    shortName?: NullableStringFieldUpdateOperationsInput | string | null
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    isDiscount?: BoolFieldUpdateOperationsInput | boolean
    discountPercent?: IntFieldUpdateOperationsInput | number
    minPrice?: FloatFieldUpdateOperationsInput | number
    maxPrice?: FloatFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    cardImgPath?: StringFieldUpdateOperationsInput | string
    cardImgSrc?: StringFieldUpdateOperationsInput | string
    optionFirst?: NullableStringFieldUpdateOperationsInput | string | null
    optionSecond?: NullableStringFieldUpdateOperationsInput | string | null
    isWholesale?: BoolFieldUpdateOperationsInput | boolean
    rating?: IntFieldUpdateOperationsInput | number
    sold?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    brand?: brandUpdateOneRequiredWithoutProductNestedInput
    admin?: adminUpdateOneRequiredWithoutProductNestedInput
    product_image?: product_imageUpdateManyWithoutProductNestedInput
    product_spec?: product_specUpdateManyWithoutProductNestedInput
    product_detail?: product_detailUpdateManyWithoutProductNestedInput
    product_option_first?: product_option_firstUpdateManyWithoutProductNestedInput
    product_price?: product_priceUpdateManyWithoutProductNestedInput
    product_wholesale?: product_wholesaleUpdateManyWithoutProductNestedInput
    product_review?: product_reviewUpdateManyWithoutProductNestedInput
    product_tag?: product_tagUpdateManyWithoutProductNestedInput
    cart?: cartUpdateManyWithoutProductNestedInput
    order_product?: order_productUpdateManyWithoutProductNestedInput
  }

  export type productUncheckedUpdateWithoutProduct_option_secondInput = {
    id?: IntFieldUpdateOperationsInput | number
    brandId?: IntFieldUpdateOperationsInput | number
    adminId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    shortName?: NullableStringFieldUpdateOperationsInput | string | null
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    isDiscount?: BoolFieldUpdateOperationsInput | boolean
    discountPercent?: IntFieldUpdateOperationsInput | number
    minPrice?: FloatFieldUpdateOperationsInput | number
    maxPrice?: FloatFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    cardImgPath?: StringFieldUpdateOperationsInput | string
    cardImgSrc?: StringFieldUpdateOperationsInput | string
    optionFirst?: NullableStringFieldUpdateOperationsInput | string | null
    optionSecond?: NullableStringFieldUpdateOperationsInput | string | null
    isWholesale?: BoolFieldUpdateOperationsInput | boolean
    rating?: IntFieldUpdateOperationsInput | number
    sold?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product_image?: product_imageUncheckedUpdateManyWithoutProductNestedInput
    product_spec?: product_specUncheckedUpdateManyWithoutProductNestedInput
    product_detail?: product_detailUncheckedUpdateManyWithoutProductNestedInput
    product_option_first?: product_option_firstUncheckedUpdateManyWithoutProductNestedInput
    product_price?: product_priceUncheckedUpdateManyWithoutProductNestedInput
    product_wholesale?: product_wholesaleUncheckedUpdateManyWithoutProductNestedInput
    product_review?: product_reviewUncheckedUpdateManyWithoutProductNestedInput
    product_tag?: product_tagUncheckedUpdateManyWithoutProductNestedInput
    cart?: cartUncheckedUpdateManyWithoutProductNestedInput
    order_product?: order_productUncheckedUpdateManyWithoutProductNestedInput
  }

  export type product_priceUpsertWithWhereUniqueWithoutProduct_option_secondInput = {
    where: product_priceWhereUniqueInput
    update: XOR<product_priceUpdateWithoutProduct_option_secondInput, product_priceUncheckedUpdateWithoutProduct_option_secondInput>
    create: XOR<product_priceCreateWithoutProduct_option_secondInput, product_priceUncheckedCreateWithoutProduct_option_secondInput>
  }

  export type product_priceUpdateWithWhereUniqueWithoutProduct_option_secondInput = {
    where: product_priceWhereUniqueInput
    data: XOR<product_priceUpdateWithoutProduct_option_secondInput, product_priceUncheckedUpdateWithoutProduct_option_secondInput>
  }

  export type product_priceUpdateManyWithWhereWithoutProduct_option_secondInput = {
    where: product_priceScalarWhereInput
    data: XOR<product_priceUpdateManyMutationInput, product_priceUncheckedUpdateManyWithoutProduct_option_secondInput>
  }

  export type productCreateWithoutProduct_priceInput = {
    name: string
    shortName?: string | null
    detail?: string | null
    isDiscount?: boolean
    discountPercent: number
    minPrice: number
    maxPrice: number
    slug: string
    cardImgPath: string
    cardImgSrc: string
    optionFirst?: string | null
    optionSecond?: string | null
    isWholesale?: boolean
    rating?: number
    sold?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    brand: brandCreateNestedOneWithoutProductInput
    admin: adminCreateNestedOneWithoutProductInput
    product_image?: product_imageCreateNestedManyWithoutProductInput
    product_spec?: product_specCreateNestedManyWithoutProductInput
    product_detail?: product_detailCreateNestedManyWithoutProductInput
    product_option_first?: product_option_firstCreateNestedManyWithoutProductInput
    product_option_second?: product_option_secondCreateNestedManyWithoutProductInput
    product_wholesale?: product_wholesaleCreateNestedManyWithoutProductInput
    product_review?: product_reviewCreateNestedManyWithoutProductInput
    product_tag?: product_tagCreateNestedManyWithoutProductInput
    cart?: cartCreateNestedManyWithoutProductInput
    order_product?: order_productCreateNestedManyWithoutProductInput
  }

  export type productUncheckedCreateWithoutProduct_priceInput = {
    id?: number
    brandId: number
    adminId: number
    name: string
    shortName?: string | null
    detail?: string | null
    isDiscount?: boolean
    discountPercent: number
    minPrice: number
    maxPrice: number
    slug: string
    cardImgPath: string
    cardImgSrc: string
    optionFirst?: string | null
    optionSecond?: string | null
    isWholesale?: boolean
    rating?: number
    sold?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    product_image?: product_imageUncheckedCreateNestedManyWithoutProductInput
    product_spec?: product_specUncheckedCreateNestedManyWithoutProductInput
    product_detail?: product_detailUncheckedCreateNestedManyWithoutProductInput
    product_option_first?: product_option_firstUncheckedCreateNestedManyWithoutProductInput
    product_option_second?: product_option_secondUncheckedCreateNestedManyWithoutProductInput
    product_wholesale?: product_wholesaleUncheckedCreateNestedManyWithoutProductInput
    product_review?: product_reviewUncheckedCreateNestedManyWithoutProductInput
    product_tag?: product_tagUncheckedCreateNestedManyWithoutProductInput
    cart?: cartUncheckedCreateNestedManyWithoutProductInput
    order_product?: order_productUncheckedCreateNestedManyWithoutProductInput
  }

  export type productCreateOrConnectWithoutProduct_priceInput = {
    where: productWhereUniqueInput
    create: XOR<productCreateWithoutProduct_priceInput, productUncheckedCreateWithoutProduct_priceInput>
  }

  export type product_option_firstCreateWithoutProduct_priceInput = {
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    product: productCreateNestedOneWithoutProduct_option_firstInput
  }

  export type product_option_firstUncheckedCreateWithoutProduct_priceInput = {
    id?: number
    productId: number
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type product_option_firstCreateOrConnectWithoutProduct_priceInput = {
    where: product_option_firstWhereUniqueInput
    create: XOR<product_option_firstCreateWithoutProduct_priceInput, product_option_firstUncheckedCreateWithoutProduct_priceInput>
  }

  export type product_option_secondCreateWithoutProduct_priceInput = {
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    product: productCreateNestedOneWithoutProduct_option_secondInput
  }

  export type product_option_secondUncheckedCreateWithoutProduct_priceInput = {
    id?: number
    productId: number
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type product_option_secondCreateOrConnectWithoutProduct_priceInput = {
    where: product_option_secondWhereUniqueInput
    create: XOR<product_option_secondCreateWithoutProduct_priceInput, product_option_secondUncheckedCreateWithoutProduct_priceInput>
  }

  export type cartCreateWithoutProduct_priceInput = {
    qty: number
    price: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: userCreateNestedOneWithoutCartInput
    product: productCreateNestedOneWithoutCartInput
  }

  export type cartUncheckedCreateWithoutProduct_priceInput = {
    id?: number
    userId: number
    productId: number
    qty: number
    price: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type cartCreateOrConnectWithoutProduct_priceInput = {
    where: cartWhereUniqueInput
    create: XOR<cartCreateWithoutProduct_priceInput, cartUncheckedCreateWithoutProduct_priceInput>
  }

  export type cartCreateManyProduct_priceInputEnvelope = {
    data: cartCreateManyProduct_priceInput | cartCreateManyProduct_priceInput[]
    skipDuplicates?: boolean
  }

  export type order_productCreateWithoutProduct_priceInput = {
    qty: number
    price: number
    productData: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: userCreateNestedOneWithoutOrder_productInput
    product: productCreateNestedOneWithoutOrder_productInput
    order: orderCreateNestedOneWithoutOrder_productInput
  }

  export type order_productUncheckedCreateWithoutProduct_priceInput = {
    id?: number
    userId: number
    productId: number
    orderId: number
    qty: number
    price: number
    productData: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type order_productCreateOrConnectWithoutProduct_priceInput = {
    where: order_productWhereUniqueInput
    create: XOR<order_productCreateWithoutProduct_priceInput, order_productUncheckedCreateWithoutProduct_priceInput>
  }

  export type order_productCreateManyProduct_priceInputEnvelope = {
    data: order_productCreateManyProduct_priceInput | order_productCreateManyProduct_priceInput[]
    skipDuplicates?: boolean
  }

  export type productUpsertWithoutProduct_priceInput = {
    update: XOR<productUpdateWithoutProduct_priceInput, productUncheckedUpdateWithoutProduct_priceInput>
    create: XOR<productCreateWithoutProduct_priceInput, productUncheckedCreateWithoutProduct_priceInput>
    where?: productWhereInput
  }

  export type productUpdateToOneWithWhereWithoutProduct_priceInput = {
    where?: productWhereInput
    data: XOR<productUpdateWithoutProduct_priceInput, productUncheckedUpdateWithoutProduct_priceInput>
  }

  export type productUpdateWithoutProduct_priceInput = {
    name?: StringFieldUpdateOperationsInput | string
    shortName?: NullableStringFieldUpdateOperationsInput | string | null
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    isDiscount?: BoolFieldUpdateOperationsInput | boolean
    discountPercent?: IntFieldUpdateOperationsInput | number
    minPrice?: FloatFieldUpdateOperationsInput | number
    maxPrice?: FloatFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    cardImgPath?: StringFieldUpdateOperationsInput | string
    cardImgSrc?: StringFieldUpdateOperationsInput | string
    optionFirst?: NullableStringFieldUpdateOperationsInput | string | null
    optionSecond?: NullableStringFieldUpdateOperationsInput | string | null
    isWholesale?: BoolFieldUpdateOperationsInput | boolean
    rating?: IntFieldUpdateOperationsInput | number
    sold?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    brand?: brandUpdateOneRequiredWithoutProductNestedInput
    admin?: adminUpdateOneRequiredWithoutProductNestedInput
    product_image?: product_imageUpdateManyWithoutProductNestedInput
    product_spec?: product_specUpdateManyWithoutProductNestedInput
    product_detail?: product_detailUpdateManyWithoutProductNestedInput
    product_option_first?: product_option_firstUpdateManyWithoutProductNestedInput
    product_option_second?: product_option_secondUpdateManyWithoutProductNestedInput
    product_wholesale?: product_wholesaleUpdateManyWithoutProductNestedInput
    product_review?: product_reviewUpdateManyWithoutProductNestedInput
    product_tag?: product_tagUpdateManyWithoutProductNestedInput
    cart?: cartUpdateManyWithoutProductNestedInput
    order_product?: order_productUpdateManyWithoutProductNestedInput
  }

  export type productUncheckedUpdateWithoutProduct_priceInput = {
    id?: IntFieldUpdateOperationsInput | number
    brandId?: IntFieldUpdateOperationsInput | number
    adminId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    shortName?: NullableStringFieldUpdateOperationsInput | string | null
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    isDiscount?: BoolFieldUpdateOperationsInput | boolean
    discountPercent?: IntFieldUpdateOperationsInput | number
    minPrice?: FloatFieldUpdateOperationsInput | number
    maxPrice?: FloatFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    cardImgPath?: StringFieldUpdateOperationsInput | string
    cardImgSrc?: StringFieldUpdateOperationsInput | string
    optionFirst?: NullableStringFieldUpdateOperationsInput | string | null
    optionSecond?: NullableStringFieldUpdateOperationsInput | string | null
    isWholesale?: BoolFieldUpdateOperationsInput | boolean
    rating?: IntFieldUpdateOperationsInput | number
    sold?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product_image?: product_imageUncheckedUpdateManyWithoutProductNestedInput
    product_spec?: product_specUncheckedUpdateManyWithoutProductNestedInput
    product_detail?: product_detailUncheckedUpdateManyWithoutProductNestedInput
    product_option_first?: product_option_firstUncheckedUpdateManyWithoutProductNestedInput
    product_option_second?: product_option_secondUncheckedUpdateManyWithoutProductNestedInput
    product_wholesale?: product_wholesaleUncheckedUpdateManyWithoutProductNestedInput
    product_review?: product_reviewUncheckedUpdateManyWithoutProductNestedInput
    product_tag?: product_tagUncheckedUpdateManyWithoutProductNestedInput
    cart?: cartUncheckedUpdateManyWithoutProductNestedInput
    order_product?: order_productUncheckedUpdateManyWithoutProductNestedInput
  }

  export type product_option_firstUpsertWithoutProduct_priceInput = {
    update: XOR<product_option_firstUpdateWithoutProduct_priceInput, product_option_firstUncheckedUpdateWithoutProduct_priceInput>
    create: XOR<product_option_firstCreateWithoutProduct_priceInput, product_option_firstUncheckedCreateWithoutProduct_priceInput>
    where?: product_option_firstWhereInput
  }

  export type product_option_firstUpdateToOneWithWhereWithoutProduct_priceInput = {
    where?: product_option_firstWhereInput
    data: XOR<product_option_firstUpdateWithoutProduct_priceInput, product_option_firstUncheckedUpdateWithoutProduct_priceInput>
  }

  export type product_option_firstUpdateWithoutProduct_priceInput = {
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: productUpdateOneRequiredWithoutProduct_option_firstNestedInput
  }

  export type product_option_firstUncheckedUpdateWithoutProduct_priceInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type product_option_secondUpsertWithoutProduct_priceInput = {
    update: XOR<product_option_secondUpdateWithoutProduct_priceInput, product_option_secondUncheckedUpdateWithoutProduct_priceInput>
    create: XOR<product_option_secondCreateWithoutProduct_priceInput, product_option_secondUncheckedCreateWithoutProduct_priceInput>
    where?: product_option_secondWhereInput
  }

  export type product_option_secondUpdateToOneWithWhereWithoutProduct_priceInput = {
    where?: product_option_secondWhereInput
    data: XOR<product_option_secondUpdateWithoutProduct_priceInput, product_option_secondUncheckedUpdateWithoutProduct_priceInput>
  }

  export type product_option_secondUpdateWithoutProduct_priceInput = {
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: productUpdateOneRequiredWithoutProduct_option_secondNestedInput
  }

  export type product_option_secondUncheckedUpdateWithoutProduct_priceInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type cartUpsertWithWhereUniqueWithoutProduct_priceInput = {
    where: cartWhereUniqueInput
    update: XOR<cartUpdateWithoutProduct_priceInput, cartUncheckedUpdateWithoutProduct_priceInput>
    create: XOR<cartCreateWithoutProduct_priceInput, cartUncheckedCreateWithoutProduct_priceInput>
  }

  export type cartUpdateWithWhereUniqueWithoutProduct_priceInput = {
    where: cartWhereUniqueInput
    data: XOR<cartUpdateWithoutProduct_priceInput, cartUncheckedUpdateWithoutProduct_priceInput>
  }

  export type cartUpdateManyWithWhereWithoutProduct_priceInput = {
    where: cartScalarWhereInput
    data: XOR<cartUpdateManyMutationInput, cartUncheckedUpdateManyWithoutProduct_priceInput>
  }

  export type order_productUpsertWithWhereUniqueWithoutProduct_priceInput = {
    where: order_productWhereUniqueInput
    update: XOR<order_productUpdateWithoutProduct_priceInput, order_productUncheckedUpdateWithoutProduct_priceInput>
    create: XOR<order_productCreateWithoutProduct_priceInput, order_productUncheckedCreateWithoutProduct_priceInput>
  }

  export type order_productUpdateWithWhereUniqueWithoutProduct_priceInput = {
    where: order_productWhereUniqueInput
    data: XOR<order_productUpdateWithoutProduct_priceInput, order_productUncheckedUpdateWithoutProduct_priceInput>
  }

  export type order_productUpdateManyWithWhereWithoutProduct_priceInput = {
    where: order_productScalarWhereInput
    data: XOR<order_productUpdateManyMutationInput, order_productUncheckedUpdateManyWithoutProduct_priceInput>
  }

  export type productCreateWithoutProduct_detailInput = {
    name: string
    shortName?: string | null
    detail?: string | null
    isDiscount?: boolean
    discountPercent: number
    minPrice: number
    maxPrice: number
    slug: string
    cardImgPath: string
    cardImgSrc: string
    optionFirst?: string | null
    optionSecond?: string | null
    isWholesale?: boolean
    rating?: number
    sold?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    brand: brandCreateNestedOneWithoutProductInput
    admin: adminCreateNestedOneWithoutProductInput
    product_image?: product_imageCreateNestedManyWithoutProductInput
    product_spec?: product_specCreateNestedManyWithoutProductInput
    product_option_first?: product_option_firstCreateNestedManyWithoutProductInput
    product_option_second?: product_option_secondCreateNestedManyWithoutProductInput
    product_price?: product_priceCreateNestedManyWithoutProductInput
    product_wholesale?: product_wholesaleCreateNestedManyWithoutProductInput
    product_review?: product_reviewCreateNestedManyWithoutProductInput
    product_tag?: product_tagCreateNestedManyWithoutProductInput
    cart?: cartCreateNestedManyWithoutProductInput
    order_product?: order_productCreateNestedManyWithoutProductInput
  }

  export type productUncheckedCreateWithoutProduct_detailInput = {
    id?: number
    brandId: number
    adminId: number
    name: string
    shortName?: string | null
    detail?: string | null
    isDiscount?: boolean
    discountPercent: number
    minPrice: number
    maxPrice: number
    slug: string
    cardImgPath: string
    cardImgSrc: string
    optionFirst?: string | null
    optionSecond?: string | null
    isWholesale?: boolean
    rating?: number
    sold?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    product_image?: product_imageUncheckedCreateNestedManyWithoutProductInput
    product_spec?: product_specUncheckedCreateNestedManyWithoutProductInput
    product_option_first?: product_option_firstUncheckedCreateNestedManyWithoutProductInput
    product_option_second?: product_option_secondUncheckedCreateNestedManyWithoutProductInput
    product_price?: product_priceUncheckedCreateNestedManyWithoutProductInput
    product_wholesale?: product_wholesaleUncheckedCreateNestedManyWithoutProductInput
    product_review?: product_reviewUncheckedCreateNestedManyWithoutProductInput
    product_tag?: product_tagUncheckedCreateNestedManyWithoutProductInput
    cart?: cartUncheckedCreateNestedManyWithoutProductInput
    order_product?: order_productUncheckedCreateNestedManyWithoutProductInput
  }

  export type productCreateOrConnectWithoutProduct_detailInput = {
    where: productWhereUniqueInput
    create: XOR<productCreateWithoutProduct_detailInput, productUncheckedCreateWithoutProduct_detailInput>
  }

  export type productUpsertWithoutProduct_detailInput = {
    update: XOR<productUpdateWithoutProduct_detailInput, productUncheckedUpdateWithoutProduct_detailInput>
    create: XOR<productCreateWithoutProduct_detailInput, productUncheckedCreateWithoutProduct_detailInput>
    where?: productWhereInput
  }

  export type productUpdateToOneWithWhereWithoutProduct_detailInput = {
    where?: productWhereInput
    data: XOR<productUpdateWithoutProduct_detailInput, productUncheckedUpdateWithoutProduct_detailInput>
  }

  export type productUpdateWithoutProduct_detailInput = {
    name?: StringFieldUpdateOperationsInput | string
    shortName?: NullableStringFieldUpdateOperationsInput | string | null
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    isDiscount?: BoolFieldUpdateOperationsInput | boolean
    discountPercent?: IntFieldUpdateOperationsInput | number
    minPrice?: FloatFieldUpdateOperationsInput | number
    maxPrice?: FloatFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    cardImgPath?: StringFieldUpdateOperationsInput | string
    cardImgSrc?: StringFieldUpdateOperationsInput | string
    optionFirst?: NullableStringFieldUpdateOperationsInput | string | null
    optionSecond?: NullableStringFieldUpdateOperationsInput | string | null
    isWholesale?: BoolFieldUpdateOperationsInput | boolean
    rating?: IntFieldUpdateOperationsInput | number
    sold?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    brand?: brandUpdateOneRequiredWithoutProductNestedInput
    admin?: adminUpdateOneRequiredWithoutProductNestedInput
    product_image?: product_imageUpdateManyWithoutProductNestedInput
    product_spec?: product_specUpdateManyWithoutProductNestedInput
    product_option_first?: product_option_firstUpdateManyWithoutProductNestedInput
    product_option_second?: product_option_secondUpdateManyWithoutProductNestedInput
    product_price?: product_priceUpdateManyWithoutProductNestedInput
    product_wholesale?: product_wholesaleUpdateManyWithoutProductNestedInput
    product_review?: product_reviewUpdateManyWithoutProductNestedInput
    product_tag?: product_tagUpdateManyWithoutProductNestedInput
    cart?: cartUpdateManyWithoutProductNestedInput
    order_product?: order_productUpdateManyWithoutProductNestedInput
  }

  export type productUncheckedUpdateWithoutProduct_detailInput = {
    id?: IntFieldUpdateOperationsInput | number
    brandId?: IntFieldUpdateOperationsInput | number
    adminId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    shortName?: NullableStringFieldUpdateOperationsInput | string | null
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    isDiscount?: BoolFieldUpdateOperationsInput | boolean
    discountPercent?: IntFieldUpdateOperationsInput | number
    minPrice?: FloatFieldUpdateOperationsInput | number
    maxPrice?: FloatFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    cardImgPath?: StringFieldUpdateOperationsInput | string
    cardImgSrc?: StringFieldUpdateOperationsInput | string
    optionFirst?: NullableStringFieldUpdateOperationsInput | string | null
    optionSecond?: NullableStringFieldUpdateOperationsInput | string | null
    isWholesale?: BoolFieldUpdateOperationsInput | boolean
    rating?: IntFieldUpdateOperationsInput | number
    sold?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product_image?: product_imageUncheckedUpdateManyWithoutProductNestedInput
    product_spec?: product_specUncheckedUpdateManyWithoutProductNestedInput
    product_option_first?: product_option_firstUncheckedUpdateManyWithoutProductNestedInput
    product_option_second?: product_option_secondUncheckedUpdateManyWithoutProductNestedInput
    product_price?: product_priceUncheckedUpdateManyWithoutProductNestedInput
    product_wholesale?: product_wholesaleUncheckedUpdateManyWithoutProductNestedInput
    product_review?: product_reviewUncheckedUpdateManyWithoutProductNestedInput
    product_tag?: product_tagUncheckedUpdateManyWithoutProductNestedInput
    cart?: cartUncheckedUpdateManyWithoutProductNestedInput
    order_product?: order_productUncheckedUpdateManyWithoutProductNestedInput
  }

  export type productCreateWithoutProduct_imageInput = {
    name: string
    shortName?: string | null
    detail?: string | null
    isDiscount?: boolean
    discountPercent: number
    minPrice: number
    maxPrice: number
    slug: string
    cardImgPath: string
    cardImgSrc: string
    optionFirst?: string | null
    optionSecond?: string | null
    isWholesale?: boolean
    rating?: number
    sold?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    brand: brandCreateNestedOneWithoutProductInput
    admin: adminCreateNestedOneWithoutProductInput
    product_spec?: product_specCreateNestedManyWithoutProductInput
    product_detail?: product_detailCreateNestedManyWithoutProductInput
    product_option_first?: product_option_firstCreateNestedManyWithoutProductInput
    product_option_second?: product_option_secondCreateNestedManyWithoutProductInput
    product_price?: product_priceCreateNestedManyWithoutProductInput
    product_wholesale?: product_wholesaleCreateNestedManyWithoutProductInput
    product_review?: product_reviewCreateNestedManyWithoutProductInput
    product_tag?: product_tagCreateNestedManyWithoutProductInput
    cart?: cartCreateNestedManyWithoutProductInput
    order_product?: order_productCreateNestedManyWithoutProductInput
  }

  export type productUncheckedCreateWithoutProduct_imageInput = {
    id?: number
    brandId: number
    adminId: number
    name: string
    shortName?: string | null
    detail?: string | null
    isDiscount?: boolean
    discountPercent: number
    minPrice: number
    maxPrice: number
    slug: string
    cardImgPath: string
    cardImgSrc: string
    optionFirst?: string | null
    optionSecond?: string | null
    isWholesale?: boolean
    rating?: number
    sold?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    product_spec?: product_specUncheckedCreateNestedManyWithoutProductInput
    product_detail?: product_detailUncheckedCreateNestedManyWithoutProductInput
    product_option_first?: product_option_firstUncheckedCreateNestedManyWithoutProductInput
    product_option_second?: product_option_secondUncheckedCreateNestedManyWithoutProductInput
    product_price?: product_priceUncheckedCreateNestedManyWithoutProductInput
    product_wholesale?: product_wholesaleUncheckedCreateNestedManyWithoutProductInput
    product_review?: product_reviewUncheckedCreateNestedManyWithoutProductInput
    product_tag?: product_tagUncheckedCreateNestedManyWithoutProductInput
    cart?: cartUncheckedCreateNestedManyWithoutProductInput
    order_product?: order_productUncheckedCreateNestedManyWithoutProductInput
  }

  export type productCreateOrConnectWithoutProduct_imageInput = {
    where: productWhereUniqueInput
    create: XOR<productCreateWithoutProduct_imageInput, productUncheckedCreateWithoutProduct_imageInput>
  }

  export type productUpsertWithoutProduct_imageInput = {
    update: XOR<productUpdateWithoutProduct_imageInput, productUncheckedUpdateWithoutProduct_imageInput>
    create: XOR<productCreateWithoutProduct_imageInput, productUncheckedCreateWithoutProduct_imageInput>
    where?: productWhereInput
  }

  export type productUpdateToOneWithWhereWithoutProduct_imageInput = {
    where?: productWhereInput
    data: XOR<productUpdateWithoutProduct_imageInput, productUncheckedUpdateWithoutProduct_imageInput>
  }

  export type productUpdateWithoutProduct_imageInput = {
    name?: StringFieldUpdateOperationsInput | string
    shortName?: NullableStringFieldUpdateOperationsInput | string | null
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    isDiscount?: BoolFieldUpdateOperationsInput | boolean
    discountPercent?: IntFieldUpdateOperationsInput | number
    minPrice?: FloatFieldUpdateOperationsInput | number
    maxPrice?: FloatFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    cardImgPath?: StringFieldUpdateOperationsInput | string
    cardImgSrc?: StringFieldUpdateOperationsInput | string
    optionFirst?: NullableStringFieldUpdateOperationsInput | string | null
    optionSecond?: NullableStringFieldUpdateOperationsInput | string | null
    isWholesale?: BoolFieldUpdateOperationsInput | boolean
    rating?: IntFieldUpdateOperationsInput | number
    sold?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    brand?: brandUpdateOneRequiredWithoutProductNestedInput
    admin?: adminUpdateOneRequiredWithoutProductNestedInput
    product_spec?: product_specUpdateManyWithoutProductNestedInput
    product_detail?: product_detailUpdateManyWithoutProductNestedInput
    product_option_first?: product_option_firstUpdateManyWithoutProductNestedInput
    product_option_second?: product_option_secondUpdateManyWithoutProductNestedInput
    product_price?: product_priceUpdateManyWithoutProductNestedInput
    product_wholesale?: product_wholesaleUpdateManyWithoutProductNestedInput
    product_review?: product_reviewUpdateManyWithoutProductNestedInput
    product_tag?: product_tagUpdateManyWithoutProductNestedInput
    cart?: cartUpdateManyWithoutProductNestedInput
    order_product?: order_productUpdateManyWithoutProductNestedInput
  }

  export type productUncheckedUpdateWithoutProduct_imageInput = {
    id?: IntFieldUpdateOperationsInput | number
    brandId?: IntFieldUpdateOperationsInput | number
    adminId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    shortName?: NullableStringFieldUpdateOperationsInput | string | null
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    isDiscount?: BoolFieldUpdateOperationsInput | boolean
    discountPercent?: IntFieldUpdateOperationsInput | number
    minPrice?: FloatFieldUpdateOperationsInput | number
    maxPrice?: FloatFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    cardImgPath?: StringFieldUpdateOperationsInput | string
    cardImgSrc?: StringFieldUpdateOperationsInput | string
    optionFirst?: NullableStringFieldUpdateOperationsInput | string | null
    optionSecond?: NullableStringFieldUpdateOperationsInput | string | null
    isWholesale?: BoolFieldUpdateOperationsInput | boolean
    rating?: IntFieldUpdateOperationsInput | number
    sold?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product_spec?: product_specUncheckedUpdateManyWithoutProductNestedInput
    product_detail?: product_detailUncheckedUpdateManyWithoutProductNestedInput
    product_option_first?: product_option_firstUncheckedUpdateManyWithoutProductNestedInput
    product_option_second?: product_option_secondUncheckedUpdateManyWithoutProductNestedInput
    product_price?: product_priceUncheckedUpdateManyWithoutProductNestedInput
    product_wholesale?: product_wholesaleUncheckedUpdateManyWithoutProductNestedInput
    product_review?: product_reviewUncheckedUpdateManyWithoutProductNestedInput
    product_tag?: product_tagUncheckedUpdateManyWithoutProductNestedInput
    cart?: cartUncheckedUpdateManyWithoutProductNestedInput
    order_product?: order_productUncheckedUpdateManyWithoutProductNestedInput
  }

  export type productCreateWithoutProduct_specInput = {
    name: string
    shortName?: string | null
    detail?: string | null
    isDiscount?: boolean
    discountPercent: number
    minPrice: number
    maxPrice: number
    slug: string
    cardImgPath: string
    cardImgSrc: string
    optionFirst?: string | null
    optionSecond?: string | null
    isWholesale?: boolean
    rating?: number
    sold?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    brand: brandCreateNestedOneWithoutProductInput
    admin: adminCreateNestedOneWithoutProductInput
    product_image?: product_imageCreateNestedManyWithoutProductInput
    product_detail?: product_detailCreateNestedManyWithoutProductInput
    product_option_first?: product_option_firstCreateNestedManyWithoutProductInput
    product_option_second?: product_option_secondCreateNestedManyWithoutProductInput
    product_price?: product_priceCreateNestedManyWithoutProductInput
    product_wholesale?: product_wholesaleCreateNestedManyWithoutProductInput
    product_review?: product_reviewCreateNestedManyWithoutProductInput
    product_tag?: product_tagCreateNestedManyWithoutProductInput
    cart?: cartCreateNestedManyWithoutProductInput
    order_product?: order_productCreateNestedManyWithoutProductInput
  }

  export type productUncheckedCreateWithoutProduct_specInput = {
    id?: number
    brandId: number
    adminId: number
    name: string
    shortName?: string | null
    detail?: string | null
    isDiscount?: boolean
    discountPercent: number
    minPrice: number
    maxPrice: number
    slug: string
    cardImgPath: string
    cardImgSrc: string
    optionFirst?: string | null
    optionSecond?: string | null
    isWholesale?: boolean
    rating?: number
    sold?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    product_image?: product_imageUncheckedCreateNestedManyWithoutProductInput
    product_detail?: product_detailUncheckedCreateNestedManyWithoutProductInput
    product_option_first?: product_option_firstUncheckedCreateNestedManyWithoutProductInput
    product_option_second?: product_option_secondUncheckedCreateNestedManyWithoutProductInput
    product_price?: product_priceUncheckedCreateNestedManyWithoutProductInput
    product_wholesale?: product_wholesaleUncheckedCreateNestedManyWithoutProductInput
    product_review?: product_reviewUncheckedCreateNestedManyWithoutProductInput
    product_tag?: product_tagUncheckedCreateNestedManyWithoutProductInput
    cart?: cartUncheckedCreateNestedManyWithoutProductInput
    order_product?: order_productUncheckedCreateNestedManyWithoutProductInput
  }

  export type productCreateOrConnectWithoutProduct_specInput = {
    where: productWhereUniqueInput
    create: XOR<productCreateWithoutProduct_specInput, productUncheckedCreateWithoutProduct_specInput>
  }

  export type productUpsertWithoutProduct_specInput = {
    update: XOR<productUpdateWithoutProduct_specInput, productUncheckedUpdateWithoutProduct_specInput>
    create: XOR<productCreateWithoutProduct_specInput, productUncheckedCreateWithoutProduct_specInput>
    where?: productWhereInput
  }

  export type productUpdateToOneWithWhereWithoutProduct_specInput = {
    where?: productWhereInput
    data: XOR<productUpdateWithoutProduct_specInput, productUncheckedUpdateWithoutProduct_specInput>
  }

  export type productUpdateWithoutProduct_specInput = {
    name?: StringFieldUpdateOperationsInput | string
    shortName?: NullableStringFieldUpdateOperationsInput | string | null
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    isDiscount?: BoolFieldUpdateOperationsInput | boolean
    discountPercent?: IntFieldUpdateOperationsInput | number
    minPrice?: FloatFieldUpdateOperationsInput | number
    maxPrice?: FloatFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    cardImgPath?: StringFieldUpdateOperationsInput | string
    cardImgSrc?: StringFieldUpdateOperationsInput | string
    optionFirst?: NullableStringFieldUpdateOperationsInput | string | null
    optionSecond?: NullableStringFieldUpdateOperationsInput | string | null
    isWholesale?: BoolFieldUpdateOperationsInput | boolean
    rating?: IntFieldUpdateOperationsInput | number
    sold?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    brand?: brandUpdateOneRequiredWithoutProductNestedInput
    admin?: adminUpdateOneRequiredWithoutProductNestedInput
    product_image?: product_imageUpdateManyWithoutProductNestedInput
    product_detail?: product_detailUpdateManyWithoutProductNestedInput
    product_option_first?: product_option_firstUpdateManyWithoutProductNestedInput
    product_option_second?: product_option_secondUpdateManyWithoutProductNestedInput
    product_price?: product_priceUpdateManyWithoutProductNestedInput
    product_wholesale?: product_wholesaleUpdateManyWithoutProductNestedInput
    product_review?: product_reviewUpdateManyWithoutProductNestedInput
    product_tag?: product_tagUpdateManyWithoutProductNestedInput
    cart?: cartUpdateManyWithoutProductNestedInput
    order_product?: order_productUpdateManyWithoutProductNestedInput
  }

  export type productUncheckedUpdateWithoutProduct_specInput = {
    id?: IntFieldUpdateOperationsInput | number
    brandId?: IntFieldUpdateOperationsInput | number
    adminId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    shortName?: NullableStringFieldUpdateOperationsInput | string | null
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    isDiscount?: BoolFieldUpdateOperationsInput | boolean
    discountPercent?: IntFieldUpdateOperationsInput | number
    minPrice?: FloatFieldUpdateOperationsInput | number
    maxPrice?: FloatFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    cardImgPath?: StringFieldUpdateOperationsInput | string
    cardImgSrc?: StringFieldUpdateOperationsInput | string
    optionFirst?: NullableStringFieldUpdateOperationsInput | string | null
    optionSecond?: NullableStringFieldUpdateOperationsInput | string | null
    isWholesale?: BoolFieldUpdateOperationsInput | boolean
    rating?: IntFieldUpdateOperationsInput | number
    sold?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product_image?: product_imageUncheckedUpdateManyWithoutProductNestedInput
    product_detail?: product_detailUncheckedUpdateManyWithoutProductNestedInput
    product_option_first?: product_option_firstUncheckedUpdateManyWithoutProductNestedInput
    product_option_second?: product_option_secondUncheckedUpdateManyWithoutProductNestedInput
    product_price?: product_priceUncheckedUpdateManyWithoutProductNestedInput
    product_wholesale?: product_wholesaleUncheckedUpdateManyWithoutProductNestedInput
    product_review?: product_reviewUncheckedUpdateManyWithoutProductNestedInput
    product_tag?: product_tagUncheckedUpdateManyWithoutProductNestedInput
    cart?: cartUncheckedUpdateManyWithoutProductNestedInput
    order_product?: order_productUncheckedUpdateManyWithoutProductNestedInput
  }

  export type userCreateWithoutCartInput = {
    avatarPath?: string | null
    avatarSrc?: string | null
    fname?: string | null
    lname?: string | null
    fullname?: string | null
    email: string
    phone: string
    credit?: number
    point?: number
    lineId?: string | null
    baned?: boolean
    ipv4?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    address?: addressCreateNestedManyWithoutUserInput
    user_credit_transaction?: user_credit_transactionCreateNestedManyWithoutUserInput
    payment_transaction?: payment_transactionCreateNestedManyWithoutUserInput
    user_point_transaction?: user_point_transactionCreateNestedManyWithoutUserInput
    product_review?: product_reviewCreateNestedManyWithoutUserInput
    order?: orderCreateNestedManyWithoutUserInput
    order_product?: order_productCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutCartInput = {
    id?: number
    avatarPath?: string | null
    avatarSrc?: string | null
    fname?: string | null
    lname?: string | null
    fullname?: string | null
    email: string
    phone: string
    credit?: number
    point?: number
    lineId?: string | null
    baned?: boolean
    ipv4?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    address?: addressUncheckedCreateNestedManyWithoutUserInput
    user_credit_transaction?: user_credit_transactionUncheckedCreateNestedManyWithoutUserInput
    payment_transaction?: payment_transactionUncheckedCreateNestedManyWithoutUserInput
    user_point_transaction?: user_point_transactionUncheckedCreateNestedManyWithoutUserInput
    product_review?: product_reviewUncheckedCreateNestedManyWithoutUserInput
    order?: orderUncheckedCreateNestedManyWithoutUserInput
    order_product?: order_productUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutCartInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutCartInput, userUncheckedCreateWithoutCartInput>
  }

  export type productCreateWithoutCartInput = {
    name: string
    shortName?: string | null
    detail?: string | null
    isDiscount?: boolean
    discountPercent: number
    minPrice: number
    maxPrice: number
    slug: string
    cardImgPath: string
    cardImgSrc: string
    optionFirst?: string | null
    optionSecond?: string | null
    isWholesale?: boolean
    rating?: number
    sold?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    brand: brandCreateNestedOneWithoutProductInput
    admin: adminCreateNestedOneWithoutProductInput
    product_image?: product_imageCreateNestedManyWithoutProductInput
    product_spec?: product_specCreateNestedManyWithoutProductInput
    product_detail?: product_detailCreateNestedManyWithoutProductInput
    product_option_first?: product_option_firstCreateNestedManyWithoutProductInput
    product_option_second?: product_option_secondCreateNestedManyWithoutProductInput
    product_price?: product_priceCreateNestedManyWithoutProductInput
    product_wholesale?: product_wholesaleCreateNestedManyWithoutProductInput
    product_review?: product_reviewCreateNestedManyWithoutProductInput
    product_tag?: product_tagCreateNestedManyWithoutProductInput
    order_product?: order_productCreateNestedManyWithoutProductInput
  }

  export type productUncheckedCreateWithoutCartInput = {
    id?: number
    brandId: number
    adminId: number
    name: string
    shortName?: string | null
    detail?: string | null
    isDiscount?: boolean
    discountPercent: number
    minPrice: number
    maxPrice: number
    slug: string
    cardImgPath: string
    cardImgSrc: string
    optionFirst?: string | null
    optionSecond?: string | null
    isWholesale?: boolean
    rating?: number
    sold?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    product_image?: product_imageUncheckedCreateNestedManyWithoutProductInput
    product_spec?: product_specUncheckedCreateNestedManyWithoutProductInput
    product_detail?: product_detailUncheckedCreateNestedManyWithoutProductInput
    product_option_first?: product_option_firstUncheckedCreateNestedManyWithoutProductInput
    product_option_second?: product_option_secondUncheckedCreateNestedManyWithoutProductInput
    product_price?: product_priceUncheckedCreateNestedManyWithoutProductInput
    product_wholesale?: product_wholesaleUncheckedCreateNestedManyWithoutProductInput
    product_review?: product_reviewUncheckedCreateNestedManyWithoutProductInput
    product_tag?: product_tagUncheckedCreateNestedManyWithoutProductInput
    order_product?: order_productUncheckedCreateNestedManyWithoutProductInput
  }

  export type productCreateOrConnectWithoutCartInput = {
    where: productWhereUniqueInput
    create: XOR<productCreateWithoutCartInput, productUncheckedCreateWithoutCartInput>
  }

  export type product_priceCreateWithoutCartInput = {
    price: number
    sku?: string | null
    isWholesale?: boolean
    product: productCreateNestedOneWithoutProduct_priceInput
    product_option_first?: product_option_firstCreateNestedOneWithoutProduct_priceInput
    product_option_second?: product_option_secondCreateNestedOneWithoutProduct_priceInput
    order_product?: order_productCreateNestedManyWithoutProduct_priceInput
  }

  export type product_priceUncheckedCreateWithoutCartInput = {
    id?: number
    productId: number
    product_option_firstId?: number | null
    product_option_secondId?: number | null
    price: number
    sku?: string | null
    isWholesale?: boolean
    order_product?: order_productUncheckedCreateNestedManyWithoutProduct_priceInput
  }

  export type product_priceCreateOrConnectWithoutCartInput = {
    where: product_priceWhereUniqueInput
    create: XOR<product_priceCreateWithoutCartInput, product_priceUncheckedCreateWithoutCartInput>
  }

  export type userUpsertWithoutCartInput = {
    update: XOR<userUpdateWithoutCartInput, userUncheckedUpdateWithoutCartInput>
    create: XOR<userCreateWithoutCartInput, userUncheckedCreateWithoutCartInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutCartInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutCartInput, userUncheckedUpdateWithoutCartInput>
  }

  export type userUpdateWithoutCartInput = {
    avatarPath?: NullableStringFieldUpdateOperationsInput | string | null
    avatarSrc?: NullableStringFieldUpdateOperationsInput | string | null
    fname?: NullableStringFieldUpdateOperationsInput | string | null
    lname?: NullableStringFieldUpdateOperationsInput | string | null
    fullname?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    credit?: FloatFieldUpdateOperationsInput | number
    point?: FloatFieldUpdateOperationsInput | number
    lineId?: NullableStringFieldUpdateOperationsInput | string | null
    baned?: BoolFieldUpdateOperationsInput | boolean
    ipv4?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: addressUpdateManyWithoutUserNestedInput
    user_credit_transaction?: user_credit_transactionUpdateManyWithoutUserNestedInput
    payment_transaction?: payment_transactionUpdateManyWithoutUserNestedInput
    user_point_transaction?: user_point_transactionUpdateManyWithoutUserNestedInput
    product_review?: product_reviewUpdateManyWithoutUserNestedInput
    order?: orderUpdateManyWithoutUserNestedInput
    order_product?: order_productUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutCartInput = {
    id?: IntFieldUpdateOperationsInput | number
    avatarPath?: NullableStringFieldUpdateOperationsInput | string | null
    avatarSrc?: NullableStringFieldUpdateOperationsInput | string | null
    fname?: NullableStringFieldUpdateOperationsInput | string | null
    lname?: NullableStringFieldUpdateOperationsInput | string | null
    fullname?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    credit?: FloatFieldUpdateOperationsInput | number
    point?: FloatFieldUpdateOperationsInput | number
    lineId?: NullableStringFieldUpdateOperationsInput | string | null
    baned?: BoolFieldUpdateOperationsInput | boolean
    ipv4?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: addressUncheckedUpdateManyWithoutUserNestedInput
    user_credit_transaction?: user_credit_transactionUncheckedUpdateManyWithoutUserNestedInput
    payment_transaction?: payment_transactionUncheckedUpdateManyWithoutUserNestedInput
    user_point_transaction?: user_point_transactionUncheckedUpdateManyWithoutUserNestedInput
    product_review?: product_reviewUncheckedUpdateManyWithoutUserNestedInput
    order?: orderUncheckedUpdateManyWithoutUserNestedInput
    order_product?: order_productUncheckedUpdateManyWithoutUserNestedInput
  }

  export type productUpsertWithoutCartInput = {
    update: XOR<productUpdateWithoutCartInput, productUncheckedUpdateWithoutCartInput>
    create: XOR<productCreateWithoutCartInput, productUncheckedCreateWithoutCartInput>
    where?: productWhereInput
  }

  export type productUpdateToOneWithWhereWithoutCartInput = {
    where?: productWhereInput
    data: XOR<productUpdateWithoutCartInput, productUncheckedUpdateWithoutCartInput>
  }

  export type productUpdateWithoutCartInput = {
    name?: StringFieldUpdateOperationsInput | string
    shortName?: NullableStringFieldUpdateOperationsInput | string | null
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    isDiscount?: BoolFieldUpdateOperationsInput | boolean
    discountPercent?: IntFieldUpdateOperationsInput | number
    minPrice?: FloatFieldUpdateOperationsInput | number
    maxPrice?: FloatFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    cardImgPath?: StringFieldUpdateOperationsInput | string
    cardImgSrc?: StringFieldUpdateOperationsInput | string
    optionFirst?: NullableStringFieldUpdateOperationsInput | string | null
    optionSecond?: NullableStringFieldUpdateOperationsInput | string | null
    isWholesale?: BoolFieldUpdateOperationsInput | boolean
    rating?: IntFieldUpdateOperationsInput | number
    sold?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    brand?: brandUpdateOneRequiredWithoutProductNestedInput
    admin?: adminUpdateOneRequiredWithoutProductNestedInput
    product_image?: product_imageUpdateManyWithoutProductNestedInput
    product_spec?: product_specUpdateManyWithoutProductNestedInput
    product_detail?: product_detailUpdateManyWithoutProductNestedInput
    product_option_first?: product_option_firstUpdateManyWithoutProductNestedInput
    product_option_second?: product_option_secondUpdateManyWithoutProductNestedInput
    product_price?: product_priceUpdateManyWithoutProductNestedInput
    product_wholesale?: product_wholesaleUpdateManyWithoutProductNestedInput
    product_review?: product_reviewUpdateManyWithoutProductNestedInput
    product_tag?: product_tagUpdateManyWithoutProductNestedInput
    order_product?: order_productUpdateManyWithoutProductNestedInput
  }

  export type productUncheckedUpdateWithoutCartInput = {
    id?: IntFieldUpdateOperationsInput | number
    brandId?: IntFieldUpdateOperationsInput | number
    adminId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    shortName?: NullableStringFieldUpdateOperationsInput | string | null
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    isDiscount?: BoolFieldUpdateOperationsInput | boolean
    discountPercent?: IntFieldUpdateOperationsInput | number
    minPrice?: FloatFieldUpdateOperationsInput | number
    maxPrice?: FloatFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    cardImgPath?: StringFieldUpdateOperationsInput | string
    cardImgSrc?: StringFieldUpdateOperationsInput | string
    optionFirst?: NullableStringFieldUpdateOperationsInput | string | null
    optionSecond?: NullableStringFieldUpdateOperationsInput | string | null
    isWholesale?: BoolFieldUpdateOperationsInput | boolean
    rating?: IntFieldUpdateOperationsInput | number
    sold?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product_image?: product_imageUncheckedUpdateManyWithoutProductNestedInput
    product_spec?: product_specUncheckedUpdateManyWithoutProductNestedInput
    product_detail?: product_detailUncheckedUpdateManyWithoutProductNestedInput
    product_option_first?: product_option_firstUncheckedUpdateManyWithoutProductNestedInput
    product_option_second?: product_option_secondUncheckedUpdateManyWithoutProductNestedInput
    product_price?: product_priceUncheckedUpdateManyWithoutProductNestedInput
    product_wholesale?: product_wholesaleUncheckedUpdateManyWithoutProductNestedInput
    product_review?: product_reviewUncheckedUpdateManyWithoutProductNestedInput
    product_tag?: product_tagUncheckedUpdateManyWithoutProductNestedInput
    order_product?: order_productUncheckedUpdateManyWithoutProductNestedInput
  }

  export type product_priceUpsertWithoutCartInput = {
    update: XOR<product_priceUpdateWithoutCartInput, product_priceUncheckedUpdateWithoutCartInput>
    create: XOR<product_priceCreateWithoutCartInput, product_priceUncheckedCreateWithoutCartInput>
    where?: product_priceWhereInput
  }

  export type product_priceUpdateToOneWithWhereWithoutCartInput = {
    where?: product_priceWhereInput
    data: XOR<product_priceUpdateWithoutCartInput, product_priceUncheckedUpdateWithoutCartInput>
  }

  export type product_priceUpdateWithoutCartInput = {
    price?: FloatFieldUpdateOperationsInput | number
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    isWholesale?: BoolFieldUpdateOperationsInput | boolean
    product?: productUpdateOneRequiredWithoutProduct_priceNestedInput
    product_option_first?: product_option_firstUpdateOneWithoutProduct_priceNestedInput
    product_option_second?: product_option_secondUpdateOneWithoutProduct_priceNestedInput
    order_product?: order_productUpdateManyWithoutProduct_priceNestedInput
  }

  export type product_priceUncheckedUpdateWithoutCartInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    product_option_firstId?: NullableIntFieldUpdateOperationsInput | number | null
    product_option_secondId?: NullableIntFieldUpdateOperationsInput | number | null
    price?: FloatFieldUpdateOperationsInput | number
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    isWholesale?: BoolFieldUpdateOperationsInput | boolean
    order_product?: order_productUncheckedUpdateManyWithoutProduct_priceNestedInput
  }

  export type userCreateWithoutOrderInput = {
    avatarPath?: string | null
    avatarSrc?: string | null
    fname?: string | null
    lname?: string | null
    fullname?: string | null
    email: string
    phone: string
    credit?: number
    point?: number
    lineId?: string | null
    baned?: boolean
    ipv4?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    address?: addressCreateNestedManyWithoutUserInput
    user_credit_transaction?: user_credit_transactionCreateNestedManyWithoutUserInput
    payment_transaction?: payment_transactionCreateNestedManyWithoutUserInput
    user_point_transaction?: user_point_transactionCreateNestedManyWithoutUserInput
    product_review?: product_reviewCreateNestedManyWithoutUserInput
    cart?: cartCreateNestedManyWithoutUserInput
    order_product?: order_productCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutOrderInput = {
    id?: number
    avatarPath?: string | null
    avatarSrc?: string | null
    fname?: string | null
    lname?: string | null
    fullname?: string | null
    email: string
    phone: string
    credit?: number
    point?: number
    lineId?: string | null
    baned?: boolean
    ipv4?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    address?: addressUncheckedCreateNestedManyWithoutUserInput
    user_credit_transaction?: user_credit_transactionUncheckedCreateNestedManyWithoutUserInput
    payment_transaction?: payment_transactionUncheckedCreateNestedManyWithoutUserInput
    user_point_transaction?: user_point_transactionUncheckedCreateNestedManyWithoutUserInput
    product_review?: product_reviewUncheckedCreateNestedManyWithoutUserInput
    cart?: cartUncheckedCreateNestedManyWithoutUserInput
    order_product?: order_productUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutOrderInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutOrderInput, userUncheckedCreateWithoutOrderInput>
  }

  export type addressCreateWithoutOrderInput = {
    default?: boolean
    addressName: string
    details?: string | null
    remarks?: string | null
    receiverFname: string
    receiverLname: string
    receiverFullname: string
    receiverPhone: string
    houseNo: string
    villageNo?: string | null
    road?: string | null
    province: string
    district: string
    subDistrict: string
    postCode: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: userCreateNestedOneWithoutAddressInput
  }

  export type addressUncheckedCreateWithoutOrderInput = {
    id?: number
    userId: number
    default?: boolean
    addressName: string
    details?: string | null
    remarks?: string | null
    receiverFname: string
    receiverLname: string
    receiverFullname: string
    receiverPhone: string
    houseNo: string
    villageNo?: string | null
    road?: string | null
    province: string
    district: string
    subDistrict: string
    postCode: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type addressCreateOrConnectWithoutOrderInput = {
    where: addressWhereUniqueInput
    create: XOR<addressCreateWithoutOrderInput, addressUncheckedCreateWithoutOrderInput>
  }

  export type order_productCreateWithoutOrderInput = {
    qty: number
    price: number
    productData: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: userCreateNestedOneWithoutOrder_productInput
    product: productCreateNestedOneWithoutOrder_productInput
    product_price: product_priceCreateNestedOneWithoutOrder_productInput
  }

  export type order_productUncheckedCreateWithoutOrderInput = {
    id?: number
    userId: number
    productId: number
    product_priceId: number
    qty: number
    price: number
    productData: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type order_productCreateOrConnectWithoutOrderInput = {
    where: order_productWhereUniqueInput
    create: XOR<order_productCreateWithoutOrderInput, order_productUncheckedCreateWithoutOrderInput>
  }

  export type order_productCreateManyOrderInputEnvelope = {
    data: order_productCreateManyOrderInput | order_productCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type userUpsertWithoutOrderInput = {
    update: XOR<userUpdateWithoutOrderInput, userUncheckedUpdateWithoutOrderInput>
    create: XOR<userCreateWithoutOrderInput, userUncheckedCreateWithoutOrderInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutOrderInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutOrderInput, userUncheckedUpdateWithoutOrderInput>
  }

  export type userUpdateWithoutOrderInput = {
    avatarPath?: NullableStringFieldUpdateOperationsInput | string | null
    avatarSrc?: NullableStringFieldUpdateOperationsInput | string | null
    fname?: NullableStringFieldUpdateOperationsInput | string | null
    lname?: NullableStringFieldUpdateOperationsInput | string | null
    fullname?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    credit?: FloatFieldUpdateOperationsInput | number
    point?: FloatFieldUpdateOperationsInput | number
    lineId?: NullableStringFieldUpdateOperationsInput | string | null
    baned?: BoolFieldUpdateOperationsInput | boolean
    ipv4?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: addressUpdateManyWithoutUserNestedInput
    user_credit_transaction?: user_credit_transactionUpdateManyWithoutUserNestedInput
    payment_transaction?: payment_transactionUpdateManyWithoutUserNestedInput
    user_point_transaction?: user_point_transactionUpdateManyWithoutUserNestedInput
    product_review?: product_reviewUpdateManyWithoutUserNestedInput
    cart?: cartUpdateManyWithoutUserNestedInput
    order_product?: order_productUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    avatarPath?: NullableStringFieldUpdateOperationsInput | string | null
    avatarSrc?: NullableStringFieldUpdateOperationsInput | string | null
    fname?: NullableStringFieldUpdateOperationsInput | string | null
    lname?: NullableStringFieldUpdateOperationsInput | string | null
    fullname?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    credit?: FloatFieldUpdateOperationsInput | number
    point?: FloatFieldUpdateOperationsInput | number
    lineId?: NullableStringFieldUpdateOperationsInput | string | null
    baned?: BoolFieldUpdateOperationsInput | boolean
    ipv4?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: addressUncheckedUpdateManyWithoutUserNestedInput
    user_credit_transaction?: user_credit_transactionUncheckedUpdateManyWithoutUserNestedInput
    payment_transaction?: payment_transactionUncheckedUpdateManyWithoutUserNestedInput
    user_point_transaction?: user_point_transactionUncheckedUpdateManyWithoutUserNestedInput
    product_review?: product_reviewUncheckedUpdateManyWithoutUserNestedInput
    cart?: cartUncheckedUpdateManyWithoutUserNestedInput
    order_product?: order_productUncheckedUpdateManyWithoutUserNestedInput
  }

  export type addressUpsertWithoutOrderInput = {
    update: XOR<addressUpdateWithoutOrderInput, addressUncheckedUpdateWithoutOrderInput>
    create: XOR<addressCreateWithoutOrderInput, addressUncheckedCreateWithoutOrderInput>
    where?: addressWhereInput
  }

  export type addressUpdateToOneWithWhereWithoutOrderInput = {
    where?: addressWhereInput
    data: XOR<addressUpdateWithoutOrderInput, addressUncheckedUpdateWithoutOrderInput>
  }

  export type addressUpdateWithoutOrderInput = {
    default?: BoolFieldUpdateOperationsInput | boolean
    addressName?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    receiverFname?: StringFieldUpdateOperationsInput | string
    receiverLname?: StringFieldUpdateOperationsInput | string
    receiverFullname?: StringFieldUpdateOperationsInput | string
    receiverPhone?: StringFieldUpdateOperationsInput | string
    houseNo?: StringFieldUpdateOperationsInput | string
    villageNo?: NullableStringFieldUpdateOperationsInput | string | null
    road?: NullableStringFieldUpdateOperationsInput | string | null
    province?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    subDistrict?: StringFieldUpdateOperationsInput | string
    postCode?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: userUpdateOneRequiredWithoutAddressNestedInput
  }

  export type addressUncheckedUpdateWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    default?: BoolFieldUpdateOperationsInput | boolean
    addressName?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    receiverFname?: StringFieldUpdateOperationsInput | string
    receiverLname?: StringFieldUpdateOperationsInput | string
    receiverFullname?: StringFieldUpdateOperationsInput | string
    receiverPhone?: StringFieldUpdateOperationsInput | string
    houseNo?: StringFieldUpdateOperationsInput | string
    villageNo?: NullableStringFieldUpdateOperationsInput | string | null
    road?: NullableStringFieldUpdateOperationsInput | string | null
    province?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    subDistrict?: StringFieldUpdateOperationsInput | string
    postCode?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type order_productUpsertWithWhereUniqueWithoutOrderInput = {
    where: order_productWhereUniqueInput
    update: XOR<order_productUpdateWithoutOrderInput, order_productUncheckedUpdateWithoutOrderInput>
    create: XOR<order_productCreateWithoutOrderInput, order_productUncheckedCreateWithoutOrderInput>
  }

  export type order_productUpdateWithWhereUniqueWithoutOrderInput = {
    where: order_productWhereUniqueInput
    data: XOR<order_productUpdateWithoutOrderInput, order_productUncheckedUpdateWithoutOrderInput>
  }

  export type order_productUpdateManyWithWhereWithoutOrderInput = {
    where: order_productScalarWhereInput
    data: XOR<order_productUpdateManyMutationInput, order_productUncheckedUpdateManyWithoutOrderInput>
  }

  export type userCreateWithoutOrder_productInput = {
    avatarPath?: string | null
    avatarSrc?: string | null
    fname?: string | null
    lname?: string | null
    fullname?: string | null
    email: string
    phone: string
    credit?: number
    point?: number
    lineId?: string | null
    baned?: boolean
    ipv4?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    address?: addressCreateNestedManyWithoutUserInput
    user_credit_transaction?: user_credit_transactionCreateNestedManyWithoutUserInput
    payment_transaction?: payment_transactionCreateNestedManyWithoutUserInput
    user_point_transaction?: user_point_transactionCreateNestedManyWithoutUserInput
    product_review?: product_reviewCreateNestedManyWithoutUserInput
    cart?: cartCreateNestedManyWithoutUserInput
    order?: orderCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutOrder_productInput = {
    id?: number
    avatarPath?: string | null
    avatarSrc?: string | null
    fname?: string | null
    lname?: string | null
    fullname?: string | null
    email: string
    phone: string
    credit?: number
    point?: number
    lineId?: string | null
    baned?: boolean
    ipv4?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    address?: addressUncheckedCreateNestedManyWithoutUserInput
    user_credit_transaction?: user_credit_transactionUncheckedCreateNestedManyWithoutUserInput
    payment_transaction?: payment_transactionUncheckedCreateNestedManyWithoutUserInput
    user_point_transaction?: user_point_transactionUncheckedCreateNestedManyWithoutUserInput
    product_review?: product_reviewUncheckedCreateNestedManyWithoutUserInput
    cart?: cartUncheckedCreateNestedManyWithoutUserInput
    order?: orderUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutOrder_productInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutOrder_productInput, userUncheckedCreateWithoutOrder_productInput>
  }

  export type productCreateWithoutOrder_productInput = {
    name: string
    shortName?: string | null
    detail?: string | null
    isDiscount?: boolean
    discountPercent: number
    minPrice: number
    maxPrice: number
    slug: string
    cardImgPath: string
    cardImgSrc: string
    optionFirst?: string | null
    optionSecond?: string | null
    isWholesale?: boolean
    rating?: number
    sold?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    brand: brandCreateNestedOneWithoutProductInput
    admin: adminCreateNestedOneWithoutProductInput
    product_image?: product_imageCreateNestedManyWithoutProductInput
    product_spec?: product_specCreateNestedManyWithoutProductInput
    product_detail?: product_detailCreateNestedManyWithoutProductInput
    product_option_first?: product_option_firstCreateNestedManyWithoutProductInput
    product_option_second?: product_option_secondCreateNestedManyWithoutProductInput
    product_price?: product_priceCreateNestedManyWithoutProductInput
    product_wholesale?: product_wholesaleCreateNestedManyWithoutProductInput
    product_review?: product_reviewCreateNestedManyWithoutProductInput
    product_tag?: product_tagCreateNestedManyWithoutProductInput
    cart?: cartCreateNestedManyWithoutProductInput
  }

  export type productUncheckedCreateWithoutOrder_productInput = {
    id?: number
    brandId: number
    adminId: number
    name: string
    shortName?: string | null
    detail?: string | null
    isDiscount?: boolean
    discountPercent: number
    minPrice: number
    maxPrice: number
    slug: string
    cardImgPath: string
    cardImgSrc: string
    optionFirst?: string | null
    optionSecond?: string | null
    isWholesale?: boolean
    rating?: number
    sold?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    product_image?: product_imageUncheckedCreateNestedManyWithoutProductInput
    product_spec?: product_specUncheckedCreateNestedManyWithoutProductInput
    product_detail?: product_detailUncheckedCreateNestedManyWithoutProductInput
    product_option_first?: product_option_firstUncheckedCreateNestedManyWithoutProductInput
    product_option_second?: product_option_secondUncheckedCreateNestedManyWithoutProductInput
    product_price?: product_priceUncheckedCreateNestedManyWithoutProductInput
    product_wholesale?: product_wholesaleUncheckedCreateNestedManyWithoutProductInput
    product_review?: product_reviewUncheckedCreateNestedManyWithoutProductInput
    product_tag?: product_tagUncheckedCreateNestedManyWithoutProductInput
    cart?: cartUncheckedCreateNestedManyWithoutProductInput
  }

  export type productCreateOrConnectWithoutOrder_productInput = {
    where: productWhereUniqueInput
    create: XOR<productCreateWithoutOrder_productInput, productUncheckedCreateWithoutOrder_productInput>
  }

  export type orderCreateWithoutOrder_productInput = {
    statusNow?: string
    status: JsonNullValueInput | InputJsonValue
    paymentType: string
    paymentStatus?: string
    createUsing?: number
    pointUsing?: number
    orderPrice: number
    deliveryPrice: number
    netPrice: number
    orderDiscount: number
    deliveryDiscount: number
    orderDiscountCode: string
    deliveryDiscountCode: string
    addressData: JsonNullValueInput | InputJsonValue
    userData: JsonNullValueInput | InputJsonValue
    isReject?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: userCreateNestedOneWithoutOrderInput
    address: addressCreateNestedOneWithoutOrderInput
  }

  export type orderUncheckedCreateWithoutOrder_productInput = {
    id?: number
    userId: number
    statusNow?: string
    status: JsonNullValueInput | InputJsonValue
    paymentType: string
    paymentStatus?: string
    createUsing?: number
    pointUsing?: number
    orderPrice: number
    deliveryPrice: number
    netPrice: number
    orderDiscount: number
    deliveryDiscount: number
    orderDiscountCode: string
    deliveryDiscountCode: string
    addressId: number
    addressData: JsonNullValueInput | InputJsonValue
    userData: JsonNullValueInput | InputJsonValue
    isReject?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type orderCreateOrConnectWithoutOrder_productInput = {
    where: orderWhereUniqueInput
    create: XOR<orderCreateWithoutOrder_productInput, orderUncheckedCreateWithoutOrder_productInput>
  }

  export type product_priceCreateWithoutOrder_productInput = {
    price: number
    sku?: string | null
    isWholesale?: boolean
    product: productCreateNestedOneWithoutProduct_priceInput
    product_option_first?: product_option_firstCreateNestedOneWithoutProduct_priceInput
    product_option_second?: product_option_secondCreateNestedOneWithoutProduct_priceInput
    cart?: cartCreateNestedManyWithoutProduct_priceInput
  }

  export type product_priceUncheckedCreateWithoutOrder_productInput = {
    id?: number
    productId: number
    product_option_firstId?: number | null
    product_option_secondId?: number | null
    price: number
    sku?: string | null
    isWholesale?: boolean
    cart?: cartUncheckedCreateNestedManyWithoutProduct_priceInput
  }

  export type product_priceCreateOrConnectWithoutOrder_productInput = {
    where: product_priceWhereUniqueInput
    create: XOR<product_priceCreateWithoutOrder_productInput, product_priceUncheckedCreateWithoutOrder_productInput>
  }

  export type userUpsertWithoutOrder_productInput = {
    update: XOR<userUpdateWithoutOrder_productInput, userUncheckedUpdateWithoutOrder_productInput>
    create: XOR<userCreateWithoutOrder_productInput, userUncheckedCreateWithoutOrder_productInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutOrder_productInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutOrder_productInput, userUncheckedUpdateWithoutOrder_productInput>
  }

  export type userUpdateWithoutOrder_productInput = {
    avatarPath?: NullableStringFieldUpdateOperationsInput | string | null
    avatarSrc?: NullableStringFieldUpdateOperationsInput | string | null
    fname?: NullableStringFieldUpdateOperationsInput | string | null
    lname?: NullableStringFieldUpdateOperationsInput | string | null
    fullname?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    credit?: FloatFieldUpdateOperationsInput | number
    point?: FloatFieldUpdateOperationsInput | number
    lineId?: NullableStringFieldUpdateOperationsInput | string | null
    baned?: BoolFieldUpdateOperationsInput | boolean
    ipv4?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: addressUpdateManyWithoutUserNestedInput
    user_credit_transaction?: user_credit_transactionUpdateManyWithoutUserNestedInput
    payment_transaction?: payment_transactionUpdateManyWithoutUserNestedInput
    user_point_transaction?: user_point_transactionUpdateManyWithoutUserNestedInput
    product_review?: product_reviewUpdateManyWithoutUserNestedInput
    cart?: cartUpdateManyWithoutUserNestedInput
    order?: orderUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutOrder_productInput = {
    id?: IntFieldUpdateOperationsInput | number
    avatarPath?: NullableStringFieldUpdateOperationsInput | string | null
    avatarSrc?: NullableStringFieldUpdateOperationsInput | string | null
    fname?: NullableStringFieldUpdateOperationsInput | string | null
    lname?: NullableStringFieldUpdateOperationsInput | string | null
    fullname?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    credit?: FloatFieldUpdateOperationsInput | number
    point?: FloatFieldUpdateOperationsInput | number
    lineId?: NullableStringFieldUpdateOperationsInput | string | null
    baned?: BoolFieldUpdateOperationsInput | boolean
    ipv4?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: addressUncheckedUpdateManyWithoutUserNestedInput
    user_credit_transaction?: user_credit_transactionUncheckedUpdateManyWithoutUserNestedInput
    payment_transaction?: payment_transactionUncheckedUpdateManyWithoutUserNestedInput
    user_point_transaction?: user_point_transactionUncheckedUpdateManyWithoutUserNestedInput
    product_review?: product_reviewUncheckedUpdateManyWithoutUserNestedInput
    cart?: cartUncheckedUpdateManyWithoutUserNestedInput
    order?: orderUncheckedUpdateManyWithoutUserNestedInput
  }

  export type productUpsertWithoutOrder_productInput = {
    update: XOR<productUpdateWithoutOrder_productInput, productUncheckedUpdateWithoutOrder_productInput>
    create: XOR<productCreateWithoutOrder_productInput, productUncheckedCreateWithoutOrder_productInput>
    where?: productWhereInput
  }

  export type productUpdateToOneWithWhereWithoutOrder_productInput = {
    where?: productWhereInput
    data: XOR<productUpdateWithoutOrder_productInput, productUncheckedUpdateWithoutOrder_productInput>
  }

  export type productUpdateWithoutOrder_productInput = {
    name?: StringFieldUpdateOperationsInput | string
    shortName?: NullableStringFieldUpdateOperationsInput | string | null
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    isDiscount?: BoolFieldUpdateOperationsInput | boolean
    discountPercent?: IntFieldUpdateOperationsInput | number
    minPrice?: FloatFieldUpdateOperationsInput | number
    maxPrice?: FloatFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    cardImgPath?: StringFieldUpdateOperationsInput | string
    cardImgSrc?: StringFieldUpdateOperationsInput | string
    optionFirst?: NullableStringFieldUpdateOperationsInput | string | null
    optionSecond?: NullableStringFieldUpdateOperationsInput | string | null
    isWholesale?: BoolFieldUpdateOperationsInput | boolean
    rating?: IntFieldUpdateOperationsInput | number
    sold?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    brand?: brandUpdateOneRequiredWithoutProductNestedInput
    admin?: adminUpdateOneRequiredWithoutProductNestedInput
    product_image?: product_imageUpdateManyWithoutProductNestedInput
    product_spec?: product_specUpdateManyWithoutProductNestedInput
    product_detail?: product_detailUpdateManyWithoutProductNestedInput
    product_option_first?: product_option_firstUpdateManyWithoutProductNestedInput
    product_option_second?: product_option_secondUpdateManyWithoutProductNestedInput
    product_price?: product_priceUpdateManyWithoutProductNestedInput
    product_wholesale?: product_wholesaleUpdateManyWithoutProductNestedInput
    product_review?: product_reviewUpdateManyWithoutProductNestedInput
    product_tag?: product_tagUpdateManyWithoutProductNestedInput
    cart?: cartUpdateManyWithoutProductNestedInput
  }

  export type productUncheckedUpdateWithoutOrder_productInput = {
    id?: IntFieldUpdateOperationsInput | number
    brandId?: IntFieldUpdateOperationsInput | number
    adminId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    shortName?: NullableStringFieldUpdateOperationsInput | string | null
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    isDiscount?: BoolFieldUpdateOperationsInput | boolean
    discountPercent?: IntFieldUpdateOperationsInput | number
    minPrice?: FloatFieldUpdateOperationsInput | number
    maxPrice?: FloatFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    cardImgPath?: StringFieldUpdateOperationsInput | string
    cardImgSrc?: StringFieldUpdateOperationsInput | string
    optionFirst?: NullableStringFieldUpdateOperationsInput | string | null
    optionSecond?: NullableStringFieldUpdateOperationsInput | string | null
    isWholesale?: BoolFieldUpdateOperationsInput | boolean
    rating?: IntFieldUpdateOperationsInput | number
    sold?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product_image?: product_imageUncheckedUpdateManyWithoutProductNestedInput
    product_spec?: product_specUncheckedUpdateManyWithoutProductNestedInput
    product_detail?: product_detailUncheckedUpdateManyWithoutProductNestedInput
    product_option_first?: product_option_firstUncheckedUpdateManyWithoutProductNestedInput
    product_option_second?: product_option_secondUncheckedUpdateManyWithoutProductNestedInput
    product_price?: product_priceUncheckedUpdateManyWithoutProductNestedInput
    product_wholesale?: product_wholesaleUncheckedUpdateManyWithoutProductNestedInput
    product_review?: product_reviewUncheckedUpdateManyWithoutProductNestedInput
    product_tag?: product_tagUncheckedUpdateManyWithoutProductNestedInput
    cart?: cartUncheckedUpdateManyWithoutProductNestedInput
  }

  export type orderUpsertWithoutOrder_productInput = {
    update: XOR<orderUpdateWithoutOrder_productInput, orderUncheckedUpdateWithoutOrder_productInput>
    create: XOR<orderCreateWithoutOrder_productInput, orderUncheckedCreateWithoutOrder_productInput>
    where?: orderWhereInput
  }

  export type orderUpdateToOneWithWhereWithoutOrder_productInput = {
    where?: orderWhereInput
    data: XOR<orderUpdateWithoutOrder_productInput, orderUncheckedUpdateWithoutOrder_productInput>
  }

  export type orderUpdateWithoutOrder_productInput = {
    statusNow?: StringFieldUpdateOperationsInput | string
    status?: JsonNullValueInput | InputJsonValue
    paymentType?: StringFieldUpdateOperationsInput | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    createUsing?: FloatFieldUpdateOperationsInput | number
    pointUsing?: FloatFieldUpdateOperationsInput | number
    orderPrice?: FloatFieldUpdateOperationsInput | number
    deliveryPrice?: FloatFieldUpdateOperationsInput | number
    netPrice?: FloatFieldUpdateOperationsInput | number
    orderDiscount?: FloatFieldUpdateOperationsInput | number
    deliveryDiscount?: FloatFieldUpdateOperationsInput | number
    orderDiscountCode?: StringFieldUpdateOperationsInput | string
    deliveryDiscountCode?: StringFieldUpdateOperationsInput | string
    addressData?: JsonNullValueInput | InputJsonValue
    userData?: JsonNullValueInput | InputJsonValue
    isReject?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: userUpdateOneRequiredWithoutOrderNestedInput
    address?: addressUpdateOneRequiredWithoutOrderNestedInput
  }

  export type orderUncheckedUpdateWithoutOrder_productInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    statusNow?: StringFieldUpdateOperationsInput | string
    status?: JsonNullValueInput | InputJsonValue
    paymentType?: StringFieldUpdateOperationsInput | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    createUsing?: FloatFieldUpdateOperationsInput | number
    pointUsing?: FloatFieldUpdateOperationsInput | number
    orderPrice?: FloatFieldUpdateOperationsInput | number
    deliveryPrice?: FloatFieldUpdateOperationsInput | number
    netPrice?: FloatFieldUpdateOperationsInput | number
    orderDiscount?: FloatFieldUpdateOperationsInput | number
    deliveryDiscount?: FloatFieldUpdateOperationsInput | number
    orderDiscountCode?: StringFieldUpdateOperationsInput | string
    deliveryDiscountCode?: StringFieldUpdateOperationsInput | string
    addressId?: IntFieldUpdateOperationsInput | number
    addressData?: JsonNullValueInput | InputJsonValue
    userData?: JsonNullValueInput | InputJsonValue
    isReject?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type product_priceUpsertWithoutOrder_productInput = {
    update: XOR<product_priceUpdateWithoutOrder_productInput, product_priceUncheckedUpdateWithoutOrder_productInput>
    create: XOR<product_priceCreateWithoutOrder_productInput, product_priceUncheckedCreateWithoutOrder_productInput>
    where?: product_priceWhereInput
  }

  export type product_priceUpdateToOneWithWhereWithoutOrder_productInput = {
    where?: product_priceWhereInput
    data: XOR<product_priceUpdateWithoutOrder_productInput, product_priceUncheckedUpdateWithoutOrder_productInput>
  }

  export type product_priceUpdateWithoutOrder_productInput = {
    price?: FloatFieldUpdateOperationsInput | number
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    isWholesale?: BoolFieldUpdateOperationsInput | boolean
    product?: productUpdateOneRequiredWithoutProduct_priceNestedInput
    product_option_first?: product_option_firstUpdateOneWithoutProduct_priceNestedInput
    product_option_second?: product_option_secondUpdateOneWithoutProduct_priceNestedInput
    cart?: cartUpdateManyWithoutProduct_priceNestedInput
  }

  export type product_priceUncheckedUpdateWithoutOrder_productInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    product_option_firstId?: NullableIntFieldUpdateOperationsInput | number | null
    product_option_secondId?: NullableIntFieldUpdateOperationsInput | number | null
    price?: FloatFieldUpdateOperationsInput | number
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    isWholesale?: BoolFieldUpdateOperationsInput | boolean
    cart?: cartUncheckedUpdateManyWithoutProduct_priceNestedInput
  }

  export type user_credit_transactionCreateManyAdminInput = {
    id?: number
    userId: number
    updateBy: string
    updateType: string
    beforeUpdate: number
    afterUpdate: number
    credit: number
    remark?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type user_point_transactionCreateManyAdminInput = {
    id?: number
    userId: number
    updateBy: string
    updateType: string
    beforeUpdate: number
    afterUpdate: number
    point: number
    remark?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type product_reviewCreateManyAdminInput = {
    id?: number
    userId: number
    productId: number
    detail?: string | null
    rating?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type productCreateManyAdminInput = {
    id?: number
    brandId: number
    name: string
    shortName?: string | null
    detail?: string | null
    isDiscount?: boolean
    discountPercent: number
    minPrice: number
    maxPrice: number
    slug: string
    cardImgPath: string
    cardImgSrc: string
    optionFirst?: string | null
    optionSecond?: string | null
    isWholesale?: boolean
    rating?: number
    sold?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type user_credit_transactionUpdateWithoutAdminInput = {
    updateBy?: StringFieldUpdateOperationsInput | string
    updateType?: StringFieldUpdateOperationsInput | string
    beforeUpdate?: FloatFieldUpdateOperationsInput | number
    afterUpdate?: FloatFieldUpdateOperationsInput | number
    credit?: FloatFieldUpdateOperationsInput | number
    remark?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: userUpdateOneRequiredWithoutUser_credit_transactionNestedInput
  }

  export type user_credit_transactionUncheckedUpdateWithoutAdminInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    updateBy?: StringFieldUpdateOperationsInput | string
    updateType?: StringFieldUpdateOperationsInput | string
    beforeUpdate?: FloatFieldUpdateOperationsInput | number
    afterUpdate?: FloatFieldUpdateOperationsInput | number
    credit?: FloatFieldUpdateOperationsInput | number
    remark?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_credit_transactionUncheckedUpdateManyWithoutAdminInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    updateBy?: StringFieldUpdateOperationsInput | string
    updateType?: StringFieldUpdateOperationsInput | string
    beforeUpdate?: FloatFieldUpdateOperationsInput | number
    afterUpdate?: FloatFieldUpdateOperationsInput | number
    credit?: FloatFieldUpdateOperationsInput | number
    remark?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_point_transactionUpdateWithoutAdminInput = {
    updateBy?: StringFieldUpdateOperationsInput | string
    updateType?: StringFieldUpdateOperationsInput | string
    beforeUpdate?: FloatFieldUpdateOperationsInput | number
    afterUpdate?: FloatFieldUpdateOperationsInput | number
    point?: FloatFieldUpdateOperationsInput | number
    remark?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: userUpdateOneRequiredWithoutUser_point_transactionNestedInput
  }

  export type user_point_transactionUncheckedUpdateWithoutAdminInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    updateBy?: StringFieldUpdateOperationsInput | string
    updateType?: StringFieldUpdateOperationsInput | string
    beforeUpdate?: FloatFieldUpdateOperationsInput | number
    afterUpdate?: FloatFieldUpdateOperationsInput | number
    point?: FloatFieldUpdateOperationsInput | number
    remark?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_point_transactionUncheckedUpdateManyWithoutAdminInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    updateBy?: StringFieldUpdateOperationsInput | string
    updateType?: StringFieldUpdateOperationsInput | string
    beforeUpdate?: FloatFieldUpdateOperationsInput | number
    afterUpdate?: FloatFieldUpdateOperationsInput | number
    point?: FloatFieldUpdateOperationsInput | number
    remark?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type product_reviewUpdateWithoutAdminInput = {
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: userUpdateOneRequiredWithoutProduct_reviewNestedInput
    product?: productUpdateOneRequiredWithoutProduct_reviewNestedInput
  }

  export type product_reviewUncheckedUpdateWithoutAdminInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type product_reviewUncheckedUpdateManyWithoutAdminInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type productUpdateWithoutAdminInput = {
    name?: StringFieldUpdateOperationsInput | string
    shortName?: NullableStringFieldUpdateOperationsInput | string | null
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    isDiscount?: BoolFieldUpdateOperationsInput | boolean
    discountPercent?: IntFieldUpdateOperationsInput | number
    minPrice?: FloatFieldUpdateOperationsInput | number
    maxPrice?: FloatFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    cardImgPath?: StringFieldUpdateOperationsInput | string
    cardImgSrc?: StringFieldUpdateOperationsInput | string
    optionFirst?: NullableStringFieldUpdateOperationsInput | string | null
    optionSecond?: NullableStringFieldUpdateOperationsInput | string | null
    isWholesale?: BoolFieldUpdateOperationsInput | boolean
    rating?: IntFieldUpdateOperationsInput | number
    sold?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    brand?: brandUpdateOneRequiredWithoutProductNestedInput
    product_image?: product_imageUpdateManyWithoutProductNestedInput
    product_spec?: product_specUpdateManyWithoutProductNestedInput
    product_detail?: product_detailUpdateManyWithoutProductNestedInput
    product_option_first?: product_option_firstUpdateManyWithoutProductNestedInput
    product_option_second?: product_option_secondUpdateManyWithoutProductNestedInput
    product_price?: product_priceUpdateManyWithoutProductNestedInput
    product_wholesale?: product_wholesaleUpdateManyWithoutProductNestedInput
    product_review?: product_reviewUpdateManyWithoutProductNestedInput
    product_tag?: product_tagUpdateManyWithoutProductNestedInput
    cart?: cartUpdateManyWithoutProductNestedInput
    order_product?: order_productUpdateManyWithoutProductNestedInput
  }

  export type productUncheckedUpdateWithoutAdminInput = {
    id?: IntFieldUpdateOperationsInput | number
    brandId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    shortName?: NullableStringFieldUpdateOperationsInput | string | null
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    isDiscount?: BoolFieldUpdateOperationsInput | boolean
    discountPercent?: IntFieldUpdateOperationsInput | number
    minPrice?: FloatFieldUpdateOperationsInput | number
    maxPrice?: FloatFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    cardImgPath?: StringFieldUpdateOperationsInput | string
    cardImgSrc?: StringFieldUpdateOperationsInput | string
    optionFirst?: NullableStringFieldUpdateOperationsInput | string | null
    optionSecond?: NullableStringFieldUpdateOperationsInput | string | null
    isWholesale?: BoolFieldUpdateOperationsInput | boolean
    rating?: IntFieldUpdateOperationsInput | number
    sold?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product_image?: product_imageUncheckedUpdateManyWithoutProductNestedInput
    product_spec?: product_specUncheckedUpdateManyWithoutProductNestedInput
    product_detail?: product_detailUncheckedUpdateManyWithoutProductNestedInput
    product_option_first?: product_option_firstUncheckedUpdateManyWithoutProductNestedInput
    product_option_second?: product_option_secondUncheckedUpdateManyWithoutProductNestedInput
    product_price?: product_priceUncheckedUpdateManyWithoutProductNestedInput
    product_wholesale?: product_wholesaleUncheckedUpdateManyWithoutProductNestedInput
    product_review?: product_reviewUncheckedUpdateManyWithoutProductNestedInput
    product_tag?: product_tagUncheckedUpdateManyWithoutProductNestedInput
    cart?: cartUncheckedUpdateManyWithoutProductNestedInput
    order_product?: order_productUncheckedUpdateManyWithoutProductNestedInput
  }

  export type productUncheckedUpdateManyWithoutAdminInput = {
    id?: IntFieldUpdateOperationsInput | number
    brandId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    shortName?: NullableStringFieldUpdateOperationsInput | string | null
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    isDiscount?: BoolFieldUpdateOperationsInput | boolean
    discountPercent?: IntFieldUpdateOperationsInput | number
    minPrice?: FloatFieldUpdateOperationsInput | number
    maxPrice?: FloatFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    cardImgPath?: StringFieldUpdateOperationsInput | string
    cardImgSrc?: StringFieldUpdateOperationsInput | string
    optionFirst?: NullableStringFieldUpdateOperationsInput | string | null
    optionSecond?: NullableStringFieldUpdateOperationsInput | string | null
    isWholesale?: BoolFieldUpdateOperationsInput | boolean
    rating?: IntFieldUpdateOperationsInput | number
    sold?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type addressCreateManyUserInput = {
    id?: number
    default?: boolean
    addressName: string
    details?: string | null
    remarks?: string | null
    receiverFname: string
    receiverLname: string
    receiverFullname: string
    receiverPhone: string
    houseNo: string
    villageNo?: string | null
    road?: string | null
    province: string
    district: string
    subDistrict: string
    postCode: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type user_credit_transactionCreateManyUserInput = {
    id?: number
    adminId?: number | null
    updateBy: string
    updateType: string
    beforeUpdate: number
    afterUpdate: number
    credit: number
    remark?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type payment_transactionCreateManyUserInput = {
    id?: number
    price: number
    refCode: string
    status?: string
    base64?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type user_point_transactionCreateManyUserInput = {
    id?: number
    adminId?: number | null
    updateBy: string
    updateType: string
    beforeUpdate: number
    afterUpdate: number
    point: number
    remark?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type product_reviewCreateManyUserInput = {
    id?: number
    productId: number
    adminId: number
    detail?: string | null
    rating?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type cartCreateManyUserInput = {
    id?: number
    productId: number
    product_priceId: number
    qty: number
    price: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type orderCreateManyUserInput = {
    id?: number
    statusNow?: string
    status: JsonNullValueInput | InputJsonValue
    paymentType: string
    paymentStatus?: string
    createUsing?: number
    pointUsing?: number
    orderPrice: number
    deliveryPrice: number
    netPrice: number
    orderDiscount: number
    deliveryDiscount: number
    orderDiscountCode: string
    deliveryDiscountCode: string
    addressId: number
    addressData: JsonNullValueInput | InputJsonValue
    userData: JsonNullValueInput | InputJsonValue
    isReject?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type order_productCreateManyUserInput = {
    id?: number
    productId: number
    orderId: number
    product_priceId: number
    qty: number
    price: number
    productData: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type addressUpdateWithoutUserInput = {
    default?: BoolFieldUpdateOperationsInput | boolean
    addressName?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    receiverFname?: StringFieldUpdateOperationsInput | string
    receiverLname?: StringFieldUpdateOperationsInput | string
    receiverFullname?: StringFieldUpdateOperationsInput | string
    receiverPhone?: StringFieldUpdateOperationsInput | string
    houseNo?: StringFieldUpdateOperationsInput | string
    villageNo?: NullableStringFieldUpdateOperationsInput | string | null
    road?: NullableStringFieldUpdateOperationsInput | string | null
    province?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    subDistrict?: StringFieldUpdateOperationsInput | string
    postCode?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: orderUpdateManyWithoutAddressNestedInput
  }

  export type addressUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    default?: BoolFieldUpdateOperationsInput | boolean
    addressName?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    receiverFname?: StringFieldUpdateOperationsInput | string
    receiverLname?: StringFieldUpdateOperationsInput | string
    receiverFullname?: StringFieldUpdateOperationsInput | string
    receiverPhone?: StringFieldUpdateOperationsInput | string
    houseNo?: StringFieldUpdateOperationsInput | string
    villageNo?: NullableStringFieldUpdateOperationsInput | string | null
    road?: NullableStringFieldUpdateOperationsInput | string | null
    province?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    subDistrict?: StringFieldUpdateOperationsInput | string
    postCode?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: orderUncheckedUpdateManyWithoutAddressNestedInput
  }

  export type addressUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    default?: BoolFieldUpdateOperationsInput | boolean
    addressName?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    receiverFname?: StringFieldUpdateOperationsInput | string
    receiverLname?: StringFieldUpdateOperationsInput | string
    receiverFullname?: StringFieldUpdateOperationsInput | string
    receiverPhone?: StringFieldUpdateOperationsInput | string
    houseNo?: StringFieldUpdateOperationsInput | string
    villageNo?: NullableStringFieldUpdateOperationsInput | string | null
    road?: NullableStringFieldUpdateOperationsInput | string | null
    province?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    subDistrict?: StringFieldUpdateOperationsInput | string
    postCode?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_credit_transactionUpdateWithoutUserInput = {
    updateBy?: StringFieldUpdateOperationsInput | string
    updateType?: StringFieldUpdateOperationsInput | string
    beforeUpdate?: FloatFieldUpdateOperationsInput | number
    afterUpdate?: FloatFieldUpdateOperationsInput | number
    credit?: FloatFieldUpdateOperationsInput | number
    remark?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: adminUpdateOneWithoutUser_credit_transactionNestedInput
  }

  export type user_credit_transactionUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    adminId?: NullableIntFieldUpdateOperationsInput | number | null
    updateBy?: StringFieldUpdateOperationsInput | string
    updateType?: StringFieldUpdateOperationsInput | string
    beforeUpdate?: FloatFieldUpdateOperationsInput | number
    afterUpdate?: FloatFieldUpdateOperationsInput | number
    credit?: FloatFieldUpdateOperationsInput | number
    remark?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_credit_transactionUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    adminId?: NullableIntFieldUpdateOperationsInput | number | null
    updateBy?: StringFieldUpdateOperationsInput | string
    updateType?: StringFieldUpdateOperationsInput | string
    beforeUpdate?: FloatFieldUpdateOperationsInput | number
    afterUpdate?: FloatFieldUpdateOperationsInput | number
    credit?: FloatFieldUpdateOperationsInput | number
    remark?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type payment_transactionUpdateWithoutUserInput = {
    price?: FloatFieldUpdateOperationsInput | number
    refCode?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    base64?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type payment_transactionUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    refCode?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    base64?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type payment_transactionUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    refCode?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    base64?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_point_transactionUpdateWithoutUserInput = {
    updateBy?: StringFieldUpdateOperationsInput | string
    updateType?: StringFieldUpdateOperationsInput | string
    beforeUpdate?: FloatFieldUpdateOperationsInput | number
    afterUpdate?: FloatFieldUpdateOperationsInput | number
    point?: FloatFieldUpdateOperationsInput | number
    remark?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: adminUpdateOneWithoutUser_point_transactionNestedInput
  }

  export type user_point_transactionUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    adminId?: NullableIntFieldUpdateOperationsInput | number | null
    updateBy?: StringFieldUpdateOperationsInput | string
    updateType?: StringFieldUpdateOperationsInput | string
    beforeUpdate?: FloatFieldUpdateOperationsInput | number
    afterUpdate?: FloatFieldUpdateOperationsInput | number
    point?: FloatFieldUpdateOperationsInput | number
    remark?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_point_transactionUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    adminId?: NullableIntFieldUpdateOperationsInput | number | null
    updateBy?: StringFieldUpdateOperationsInput | string
    updateType?: StringFieldUpdateOperationsInput | string
    beforeUpdate?: FloatFieldUpdateOperationsInput | number
    afterUpdate?: FloatFieldUpdateOperationsInput | number
    point?: FloatFieldUpdateOperationsInput | number
    remark?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type product_reviewUpdateWithoutUserInput = {
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: productUpdateOneRequiredWithoutProduct_reviewNestedInput
    admin?: adminUpdateOneRequiredWithoutProduct_reviewNestedInput
  }

  export type product_reviewUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    adminId?: IntFieldUpdateOperationsInput | number
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type product_reviewUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    adminId?: IntFieldUpdateOperationsInput | number
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type cartUpdateWithoutUserInput = {
    qty?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: productUpdateOneRequiredWithoutCartNestedInput
    product_price?: product_priceUpdateOneRequiredWithoutCartNestedInput
  }

  export type cartUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    product_priceId?: IntFieldUpdateOperationsInput | number
    qty?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type cartUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    product_priceId?: IntFieldUpdateOperationsInput | number
    qty?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type orderUpdateWithoutUserInput = {
    statusNow?: StringFieldUpdateOperationsInput | string
    status?: JsonNullValueInput | InputJsonValue
    paymentType?: StringFieldUpdateOperationsInput | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    createUsing?: FloatFieldUpdateOperationsInput | number
    pointUsing?: FloatFieldUpdateOperationsInput | number
    orderPrice?: FloatFieldUpdateOperationsInput | number
    deliveryPrice?: FloatFieldUpdateOperationsInput | number
    netPrice?: FloatFieldUpdateOperationsInput | number
    orderDiscount?: FloatFieldUpdateOperationsInput | number
    deliveryDiscount?: FloatFieldUpdateOperationsInput | number
    orderDiscountCode?: StringFieldUpdateOperationsInput | string
    deliveryDiscountCode?: StringFieldUpdateOperationsInput | string
    addressData?: JsonNullValueInput | InputJsonValue
    userData?: JsonNullValueInput | InputJsonValue
    isReject?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: addressUpdateOneRequiredWithoutOrderNestedInput
    order_product?: order_productUpdateManyWithoutOrderNestedInput
  }

  export type orderUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    statusNow?: StringFieldUpdateOperationsInput | string
    status?: JsonNullValueInput | InputJsonValue
    paymentType?: StringFieldUpdateOperationsInput | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    createUsing?: FloatFieldUpdateOperationsInput | number
    pointUsing?: FloatFieldUpdateOperationsInput | number
    orderPrice?: FloatFieldUpdateOperationsInput | number
    deliveryPrice?: FloatFieldUpdateOperationsInput | number
    netPrice?: FloatFieldUpdateOperationsInput | number
    orderDiscount?: FloatFieldUpdateOperationsInput | number
    deliveryDiscount?: FloatFieldUpdateOperationsInput | number
    orderDiscountCode?: StringFieldUpdateOperationsInput | string
    deliveryDiscountCode?: StringFieldUpdateOperationsInput | string
    addressId?: IntFieldUpdateOperationsInput | number
    addressData?: JsonNullValueInput | InputJsonValue
    userData?: JsonNullValueInput | InputJsonValue
    isReject?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order_product?: order_productUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type orderUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    statusNow?: StringFieldUpdateOperationsInput | string
    status?: JsonNullValueInput | InputJsonValue
    paymentType?: StringFieldUpdateOperationsInput | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    createUsing?: FloatFieldUpdateOperationsInput | number
    pointUsing?: FloatFieldUpdateOperationsInput | number
    orderPrice?: FloatFieldUpdateOperationsInput | number
    deliveryPrice?: FloatFieldUpdateOperationsInput | number
    netPrice?: FloatFieldUpdateOperationsInput | number
    orderDiscount?: FloatFieldUpdateOperationsInput | number
    deliveryDiscount?: FloatFieldUpdateOperationsInput | number
    orderDiscountCode?: StringFieldUpdateOperationsInput | string
    deliveryDiscountCode?: StringFieldUpdateOperationsInput | string
    addressId?: IntFieldUpdateOperationsInput | number
    addressData?: JsonNullValueInput | InputJsonValue
    userData?: JsonNullValueInput | InputJsonValue
    isReject?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type order_productUpdateWithoutUserInput = {
    qty?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    productData?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: productUpdateOneRequiredWithoutOrder_productNestedInput
    order?: orderUpdateOneRequiredWithoutOrder_productNestedInput
    product_price?: product_priceUpdateOneRequiredWithoutOrder_productNestedInput
  }

  export type order_productUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    product_priceId?: IntFieldUpdateOperationsInput | number
    qty?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    productData?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type order_productUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    product_priceId?: IntFieldUpdateOperationsInput | number
    qty?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    productData?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type orderCreateManyAddressInput = {
    id?: number
    userId: number
    statusNow?: string
    status: JsonNullValueInput | InputJsonValue
    paymentType: string
    paymentStatus?: string
    createUsing?: number
    pointUsing?: number
    orderPrice: number
    deliveryPrice: number
    netPrice: number
    orderDiscount: number
    deliveryDiscount: number
    orderDiscountCode: string
    deliveryDiscountCode: string
    addressData: JsonNullValueInput | InputJsonValue
    userData: JsonNullValueInput | InputJsonValue
    isReject?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type orderUpdateWithoutAddressInput = {
    statusNow?: StringFieldUpdateOperationsInput | string
    status?: JsonNullValueInput | InputJsonValue
    paymentType?: StringFieldUpdateOperationsInput | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    createUsing?: FloatFieldUpdateOperationsInput | number
    pointUsing?: FloatFieldUpdateOperationsInput | number
    orderPrice?: FloatFieldUpdateOperationsInput | number
    deliveryPrice?: FloatFieldUpdateOperationsInput | number
    netPrice?: FloatFieldUpdateOperationsInput | number
    orderDiscount?: FloatFieldUpdateOperationsInput | number
    deliveryDiscount?: FloatFieldUpdateOperationsInput | number
    orderDiscountCode?: StringFieldUpdateOperationsInput | string
    deliveryDiscountCode?: StringFieldUpdateOperationsInput | string
    addressData?: JsonNullValueInput | InputJsonValue
    userData?: JsonNullValueInput | InputJsonValue
    isReject?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: userUpdateOneRequiredWithoutOrderNestedInput
    order_product?: order_productUpdateManyWithoutOrderNestedInput
  }

  export type orderUncheckedUpdateWithoutAddressInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    statusNow?: StringFieldUpdateOperationsInput | string
    status?: JsonNullValueInput | InputJsonValue
    paymentType?: StringFieldUpdateOperationsInput | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    createUsing?: FloatFieldUpdateOperationsInput | number
    pointUsing?: FloatFieldUpdateOperationsInput | number
    orderPrice?: FloatFieldUpdateOperationsInput | number
    deliveryPrice?: FloatFieldUpdateOperationsInput | number
    netPrice?: FloatFieldUpdateOperationsInput | number
    orderDiscount?: FloatFieldUpdateOperationsInput | number
    deliveryDiscount?: FloatFieldUpdateOperationsInput | number
    orderDiscountCode?: StringFieldUpdateOperationsInput | string
    deliveryDiscountCode?: StringFieldUpdateOperationsInput | string
    addressData?: JsonNullValueInput | InputJsonValue
    userData?: JsonNullValueInput | InputJsonValue
    isReject?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order_product?: order_productUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type orderUncheckedUpdateManyWithoutAddressInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    statusNow?: StringFieldUpdateOperationsInput | string
    status?: JsonNullValueInput | InputJsonValue
    paymentType?: StringFieldUpdateOperationsInput | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    createUsing?: FloatFieldUpdateOperationsInput | number
    pointUsing?: FloatFieldUpdateOperationsInput | number
    orderPrice?: FloatFieldUpdateOperationsInput | number
    deliveryPrice?: FloatFieldUpdateOperationsInput | number
    netPrice?: FloatFieldUpdateOperationsInput | number
    orderDiscount?: FloatFieldUpdateOperationsInput | number
    deliveryDiscount?: FloatFieldUpdateOperationsInput | number
    orderDiscountCode?: StringFieldUpdateOperationsInput | string
    deliveryDiscountCode?: StringFieldUpdateOperationsInput | string
    addressData?: JsonNullValueInput | InputJsonValue
    userData?: JsonNullValueInput | InputJsonValue
    isReject?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type productCreateManyBrandInput = {
    id?: number
    adminId: number
    name: string
    shortName?: string | null
    detail?: string | null
    isDiscount?: boolean
    discountPercent: number
    minPrice: number
    maxPrice: number
    slug: string
    cardImgPath: string
    cardImgSrc: string
    optionFirst?: string | null
    optionSecond?: string | null
    isWholesale?: boolean
    rating?: number
    sold?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type productUpdateWithoutBrandInput = {
    name?: StringFieldUpdateOperationsInput | string
    shortName?: NullableStringFieldUpdateOperationsInput | string | null
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    isDiscount?: BoolFieldUpdateOperationsInput | boolean
    discountPercent?: IntFieldUpdateOperationsInput | number
    minPrice?: FloatFieldUpdateOperationsInput | number
    maxPrice?: FloatFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    cardImgPath?: StringFieldUpdateOperationsInput | string
    cardImgSrc?: StringFieldUpdateOperationsInput | string
    optionFirst?: NullableStringFieldUpdateOperationsInput | string | null
    optionSecond?: NullableStringFieldUpdateOperationsInput | string | null
    isWholesale?: BoolFieldUpdateOperationsInput | boolean
    rating?: IntFieldUpdateOperationsInput | number
    sold?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: adminUpdateOneRequiredWithoutProductNestedInput
    product_image?: product_imageUpdateManyWithoutProductNestedInput
    product_spec?: product_specUpdateManyWithoutProductNestedInput
    product_detail?: product_detailUpdateManyWithoutProductNestedInput
    product_option_first?: product_option_firstUpdateManyWithoutProductNestedInput
    product_option_second?: product_option_secondUpdateManyWithoutProductNestedInput
    product_price?: product_priceUpdateManyWithoutProductNestedInput
    product_wholesale?: product_wholesaleUpdateManyWithoutProductNestedInput
    product_review?: product_reviewUpdateManyWithoutProductNestedInput
    product_tag?: product_tagUpdateManyWithoutProductNestedInput
    cart?: cartUpdateManyWithoutProductNestedInput
    order_product?: order_productUpdateManyWithoutProductNestedInput
  }

  export type productUncheckedUpdateWithoutBrandInput = {
    id?: IntFieldUpdateOperationsInput | number
    adminId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    shortName?: NullableStringFieldUpdateOperationsInput | string | null
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    isDiscount?: BoolFieldUpdateOperationsInput | boolean
    discountPercent?: IntFieldUpdateOperationsInput | number
    minPrice?: FloatFieldUpdateOperationsInput | number
    maxPrice?: FloatFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    cardImgPath?: StringFieldUpdateOperationsInput | string
    cardImgSrc?: StringFieldUpdateOperationsInput | string
    optionFirst?: NullableStringFieldUpdateOperationsInput | string | null
    optionSecond?: NullableStringFieldUpdateOperationsInput | string | null
    isWholesale?: BoolFieldUpdateOperationsInput | boolean
    rating?: IntFieldUpdateOperationsInput | number
    sold?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product_image?: product_imageUncheckedUpdateManyWithoutProductNestedInput
    product_spec?: product_specUncheckedUpdateManyWithoutProductNestedInput
    product_detail?: product_detailUncheckedUpdateManyWithoutProductNestedInput
    product_option_first?: product_option_firstUncheckedUpdateManyWithoutProductNestedInput
    product_option_second?: product_option_secondUncheckedUpdateManyWithoutProductNestedInput
    product_price?: product_priceUncheckedUpdateManyWithoutProductNestedInput
    product_wholesale?: product_wholesaleUncheckedUpdateManyWithoutProductNestedInput
    product_review?: product_reviewUncheckedUpdateManyWithoutProductNestedInput
    product_tag?: product_tagUncheckedUpdateManyWithoutProductNestedInput
    cart?: cartUncheckedUpdateManyWithoutProductNestedInput
    order_product?: order_productUncheckedUpdateManyWithoutProductNestedInput
  }

  export type productUncheckedUpdateManyWithoutBrandInput = {
    id?: IntFieldUpdateOperationsInput | number
    adminId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    shortName?: NullableStringFieldUpdateOperationsInput | string | null
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    isDiscount?: BoolFieldUpdateOperationsInput | boolean
    discountPercent?: IntFieldUpdateOperationsInput | number
    minPrice?: FloatFieldUpdateOperationsInput | number
    maxPrice?: FloatFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    cardImgPath?: StringFieldUpdateOperationsInput | string
    cardImgSrc?: StringFieldUpdateOperationsInput | string
    optionFirst?: NullableStringFieldUpdateOperationsInput | string | null
    optionSecond?: NullableStringFieldUpdateOperationsInput | string | null
    isWholesale?: BoolFieldUpdateOperationsInput | boolean
    rating?: IntFieldUpdateOperationsInput | number
    sold?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type product_tagCreateManyTagInput = {
    id?: number
    productId: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type product_tagUpdateWithoutTagInput = {
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: productUpdateOneRequiredWithoutProduct_tagNestedInput
  }

  export type product_tagUncheckedUpdateWithoutTagInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type product_tagUncheckedUpdateManyWithoutTagInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type sub_categoryCreateManyCategoryInput = {
    id?: number
    name: string
    detail?: string | null
    imagePath?: string | null
    imageSrc?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type sub_categoryUpdateWithoutCategoryInput = {
    name?: StringFieldUpdateOperationsInput | string
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    imageSrc?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type sub_categoryUncheckedUpdateWithoutCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    imageSrc?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type sub_categoryUncheckedUpdateManyWithoutCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    imageSrc?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type product_imageCreateManyProductInput = {
    id?: number
    name: string
    path: string
    src: string
    sequence: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type product_specCreateManyProductInput = {
    id?: number
    name: string
    data: JsonNullValueInput | InputJsonValue
  }

  export type product_detailCreateManyProductInput = {
    id?: number
    name: string
    details?: string | null
    imagePath?: string | null
    imageSrc?: string | null
    videoPath?: string | null
    videoSrc?: string | null
    videoType?: string | null
    link?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type product_option_firstCreateManyProductInput = {
    id?: number
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type product_option_secondCreateManyProductInput = {
    id?: number
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type product_priceCreateManyProductInput = {
    id?: number
    product_option_firstId?: number | null
    product_option_secondId?: number | null
    price: number
    sku?: string | null
    isWholesale?: boolean
  }

  export type product_wholesaleCreateManyProductInput = {
    id?: number
    min: number
    price: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type product_reviewCreateManyProductInput = {
    id?: number
    userId: number
    adminId: number
    detail?: string | null
    rating?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type product_tagCreateManyProductInput = {
    id?: number
    tagId: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type cartCreateManyProductInput = {
    id?: number
    userId: number
    product_priceId: number
    qty: number
    price: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type order_productCreateManyProductInput = {
    id?: number
    userId: number
    orderId: number
    product_priceId: number
    qty: number
    price: number
    productData: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type product_imageUpdateWithoutProductInput = {
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    src?: StringFieldUpdateOperationsInput | string
    sequence?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type product_imageUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    src?: StringFieldUpdateOperationsInput | string
    sequence?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type product_imageUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    src?: StringFieldUpdateOperationsInput | string
    sequence?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type product_specUpdateWithoutProductInput = {
    name?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
  }

  export type product_specUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
  }

  export type product_specUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
  }

  export type product_detailUpdateWithoutProductInput = {
    name?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    imageSrc?: NullableStringFieldUpdateOperationsInput | string | null
    videoPath?: NullableStringFieldUpdateOperationsInput | string | null
    videoSrc?: NullableStringFieldUpdateOperationsInput | string | null
    videoType?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type product_detailUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    imageSrc?: NullableStringFieldUpdateOperationsInput | string | null
    videoPath?: NullableStringFieldUpdateOperationsInput | string | null
    videoSrc?: NullableStringFieldUpdateOperationsInput | string | null
    videoType?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type product_detailUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    imageSrc?: NullableStringFieldUpdateOperationsInput | string | null
    videoPath?: NullableStringFieldUpdateOperationsInput | string | null
    videoSrc?: NullableStringFieldUpdateOperationsInput | string | null
    videoType?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type product_option_firstUpdateWithoutProductInput = {
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product_price?: product_priceUpdateManyWithoutProduct_option_firstNestedInput
  }

  export type product_option_firstUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product_price?: product_priceUncheckedUpdateManyWithoutProduct_option_firstNestedInput
  }

  export type product_option_firstUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type product_option_secondUpdateWithoutProductInput = {
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product_price?: product_priceUpdateManyWithoutProduct_option_secondNestedInput
  }

  export type product_option_secondUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product_price?: product_priceUncheckedUpdateManyWithoutProduct_option_secondNestedInput
  }

  export type product_option_secondUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type product_priceUpdateWithoutProductInput = {
    price?: FloatFieldUpdateOperationsInput | number
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    isWholesale?: BoolFieldUpdateOperationsInput | boolean
    product_option_first?: product_option_firstUpdateOneWithoutProduct_priceNestedInput
    product_option_second?: product_option_secondUpdateOneWithoutProduct_priceNestedInput
    cart?: cartUpdateManyWithoutProduct_priceNestedInput
    order_product?: order_productUpdateManyWithoutProduct_priceNestedInput
  }

  export type product_priceUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    product_option_firstId?: NullableIntFieldUpdateOperationsInput | number | null
    product_option_secondId?: NullableIntFieldUpdateOperationsInput | number | null
    price?: FloatFieldUpdateOperationsInput | number
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    isWholesale?: BoolFieldUpdateOperationsInput | boolean
    cart?: cartUncheckedUpdateManyWithoutProduct_priceNestedInput
    order_product?: order_productUncheckedUpdateManyWithoutProduct_priceNestedInput
  }

  export type product_priceUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    product_option_firstId?: NullableIntFieldUpdateOperationsInput | number | null
    product_option_secondId?: NullableIntFieldUpdateOperationsInput | number | null
    price?: FloatFieldUpdateOperationsInput | number
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    isWholesale?: BoolFieldUpdateOperationsInput | boolean
  }

  export type product_wholesaleUpdateWithoutProductInput = {
    min?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type product_wholesaleUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    min?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type product_wholesaleUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    min?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type product_reviewUpdateWithoutProductInput = {
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: userUpdateOneRequiredWithoutProduct_reviewNestedInput
    admin?: adminUpdateOneRequiredWithoutProduct_reviewNestedInput
  }

  export type product_reviewUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    adminId?: IntFieldUpdateOperationsInput | number
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type product_reviewUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    adminId?: IntFieldUpdateOperationsInput | number
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type product_tagUpdateWithoutProductInput = {
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tag?: tagUpdateOneRequiredWithoutProduct_tagNestedInput
  }

  export type product_tagUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    tagId?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type product_tagUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    tagId?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type cartUpdateWithoutProductInput = {
    qty?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: userUpdateOneRequiredWithoutCartNestedInput
    product_price?: product_priceUpdateOneRequiredWithoutCartNestedInput
  }

  export type cartUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    product_priceId?: IntFieldUpdateOperationsInput | number
    qty?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type cartUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    product_priceId?: IntFieldUpdateOperationsInput | number
    qty?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type order_productUpdateWithoutProductInput = {
    qty?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    productData?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: userUpdateOneRequiredWithoutOrder_productNestedInput
    order?: orderUpdateOneRequiredWithoutOrder_productNestedInput
    product_price?: product_priceUpdateOneRequiredWithoutOrder_productNestedInput
  }

  export type order_productUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    product_priceId?: IntFieldUpdateOperationsInput | number
    qty?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    productData?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type order_productUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    product_priceId?: IntFieldUpdateOperationsInput | number
    qty?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    productData?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type product_priceCreateManyProduct_option_firstInput = {
    id?: number
    productId: number
    product_option_secondId?: number | null
    price: number
    sku?: string | null
    isWholesale?: boolean
  }

  export type product_priceUpdateWithoutProduct_option_firstInput = {
    price?: FloatFieldUpdateOperationsInput | number
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    isWholesale?: BoolFieldUpdateOperationsInput | boolean
    product?: productUpdateOneRequiredWithoutProduct_priceNestedInput
    product_option_second?: product_option_secondUpdateOneWithoutProduct_priceNestedInput
    cart?: cartUpdateManyWithoutProduct_priceNestedInput
    order_product?: order_productUpdateManyWithoutProduct_priceNestedInput
  }

  export type product_priceUncheckedUpdateWithoutProduct_option_firstInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    product_option_secondId?: NullableIntFieldUpdateOperationsInput | number | null
    price?: FloatFieldUpdateOperationsInput | number
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    isWholesale?: BoolFieldUpdateOperationsInput | boolean
    cart?: cartUncheckedUpdateManyWithoutProduct_priceNestedInput
    order_product?: order_productUncheckedUpdateManyWithoutProduct_priceNestedInput
  }

  export type product_priceUncheckedUpdateManyWithoutProduct_option_firstInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    product_option_secondId?: NullableIntFieldUpdateOperationsInput | number | null
    price?: FloatFieldUpdateOperationsInput | number
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    isWholesale?: BoolFieldUpdateOperationsInput | boolean
  }

  export type product_priceCreateManyProduct_option_secondInput = {
    id?: number
    productId: number
    product_option_firstId?: number | null
    price: number
    sku?: string | null
    isWholesale?: boolean
  }

  export type product_priceUpdateWithoutProduct_option_secondInput = {
    price?: FloatFieldUpdateOperationsInput | number
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    isWholesale?: BoolFieldUpdateOperationsInput | boolean
    product?: productUpdateOneRequiredWithoutProduct_priceNestedInput
    product_option_first?: product_option_firstUpdateOneWithoutProduct_priceNestedInput
    cart?: cartUpdateManyWithoutProduct_priceNestedInput
    order_product?: order_productUpdateManyWithoutProduct_priceNestedInput
  }

  export type product_priceUncheckedUpdateWithoutProduct_option_secondInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    product_option_firstId?: NullableIntFieldUpdateOperationsInput | number | null
    price?: FloatFieldUpdateOperationsInput | number
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    isWholesale?: BoolFieldUpdateOperationsInput | boolean
    cart?: cartUncheckedUpdateManyWithoutProduct_priceNestedInput
    order_product?: order_productUncheckedUpdateManyWithoutProduct_priceNestedInput
  }

  export type product_priceUncheckedUpdateManyWithoutProduct_option_secondInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    product_option_firstId?: NullableIntFieldUpdateOperationsInput | number | null
    price?: FloatFieldUpdateOperationsInput | number
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    isWholesale?: BoolFieldUpdateOperationsInput | boolean
  }

  export type cartCreateManyProduct_priceInput = {
    id?: number
    userId: number
    productId: number
    qty: number
    price: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type order_productCreateManyProduct_priceInput = {
    id?: number
    userId: number
    productId: number
    orderId: number
    qty: number
    price: number
    productData: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type cartUpdateWithoutProduct_priceInput = {
    qty?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: userUpdateOneRequiredWithoutCartNestedInput
    product?: productUpdateOneRequiredWithoutCartNestedInput
  }

  export type cartUncheckedUpdateWithoutProduct_priceInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    qty?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type cartUncheckedUpdateManyWithoutProduct_priceInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    qty?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type order_productUpdateWithoutProduct_priceInput = {
    qty?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    productData?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: userUpdateOneRequiredWithoutOrder_productNestedInput
    product?: productUpdateOneRequiredWithoutOrder_productNestedInput
    order?: orderUpdateOneRequiredWithoutOrder_productNestedInput
  }

  export type order_productUncheckedUpdateWithoutProduct_priceInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    qty?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    productData?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type order_productUncheckedUpdateManyWithoutProduct_priceInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    qty?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    productData?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type order_productCreateManyOrderInput = {
    id?: number
    userId: number
    productId: number
    product_priceId: number
    qty: number
    price: number
    productData: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type order_productUpdateWithoutOrderInput = {
    qty?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    productData?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: userUpdateOneRequiredWithoutOrder_productNestedInput
    product?: productUpdateOneRequiredWithoutOrder_productNestedInput
    product_price?: product_priceUpdateOneRequiredWithoutOrder_productNestedInput
  }

  export type order_productUncheckedUpdateWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    product_priceId?: IntFieldUpdateOperationsInput | number
    qty?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    productData?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type order_productUncheckedUpdateManyWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    product_priceId?: IntFieldUpdateOperationsInput | number
    qty?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    productData?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use AdminCountOutputTypeDefaultArgs instead
     */
    export type AdminCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AdminCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AddressCountOutputTypeDefaultArgs instead
     */
    export type AddressCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AddressCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BrandCountOutputTypeDefaultArgs instead
     */
    export type BrandCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BrandCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TagCountOutputTypeDefaultArgs instead
     */
    export type TagCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TagCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CategoryCountOutputTypeDefaultArgs instead
     */
    export type CategoryCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CategoryCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProductCountOutputTypeDefaultArgs instead
     */
    export type ProductCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProductCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Product_option_firstCountOutputTypeDefaultArgs instead
     */
    export type Product_option_firstCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Product_option_firstCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Product_option_secondCountOutputTypeDefaultArgs instead
     */
    export type Product_option_secondCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Product_option_secondCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Product_priceCountOutputTypeDefaultArgs instead
     */
    export type Product_priceCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Product_priceCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OrderCountOutputTypeDefaultArgs instead
     */
    export type OrderCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OrderCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use adminDefaultArgs instead
     */
    export type adminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = adminDefaultArgs<ExtArgs>
    /**
     * @deprecated Use userDefaultArgs instead
     */
    export type userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = userDefaultArgs<ExtArgs>
    /**
     * @deprecated Use user_credit_transactionDefaultArgs instead
     */
    export type user_credit_transactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = user_credit_transactionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use user_point_transactionDefaultArgs instead
     */
    export type user_point_transactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = user_point_transactionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use payment_transactionDefaultArgs instead
     */
    export type payment_transactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = payment_transactionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use addressDefaultArgs instead
     */
    export type addressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = addressDefaultArgs<ExtArgs>
    /**
     * @deprecated Use brandDefaultArgs instead
     */
    export type brandArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = brandDefaultArgs<ExtArgs>
    /**
     * @deprecated Use tagDefaultArgs instead
     */
    export type tagArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = tagDefaultArgs<ExtArgs>
    /**
     * @deprecated Use categoryDefaultArgs instead
     */
    export type categoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = categoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use sub_categoryDefaultArgs instead
     */
    export type sub_categoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = sub_categoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use product_reviewDefaultArgs instead
     */
    export type product_reviewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = product_reviewDefaultArgs<ExtArgs>
    /**
     * @deprecated Use review_imageDefaultArgs instead
     */
    export type review_imageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = review_imageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use productDefaultArgs instead
     */
    export type productArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = productDefaultArgs<ExtArgs>
    /**
     * @deprecated Use product_tagDefaultArgs instead
     */
    export type product_tagArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = product_tagDefaultArgs<ExtArgs>
    /**
     * @deprecated Use product_wholesaleDefaultArgs instead
     */
    export type product_wholesaleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = product_wholesaleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use product_option_firstDefaultArgs instead
     */
    export type product_option_firstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = product_option_firstDefaultArgs<ExtArgs>
    /**
     * @deprecated Use product_option_secondDefaultArgs instead
     */
    export type product_option_secondArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = product_option_secondDefaultArgs<ExtArgs>
    /**
     * @deprecated Use product_priceDefaultArgs instead
     */
    export type product_priceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = product_priceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use product_detailDefaultArgs instead
     */
    export type product_detailArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = product_detailDefaultArgs<ExtArgs>
    /**
     * @deprecated Use product_imageDefaultArgs instead
     */
    export type product_imageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = product_imageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use product_specDefaultArgs instead
     */
    export type product_specArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = product_specDefaultArgs<ExtArgs>
    /**
     * @deprecated Use cartDefaultArgs instead
     */
    export type cartArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = cartDefaultArgs<ExtArgs>
    /**
     * @deprecated Use orderDefaultArgs instead
     */
    export type orderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = orderDefaultArgs<ExtArgs>
    /**
     * @deprecated Use order_productDefaultArgs instead
     */
    export type order_productArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = order_productDefaultArgs<ExtArgs>
    /**
     * @deprecated Use settingDefaultArgs instead
     */
    export type settingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = settingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use setting_serviceDefaultArgs instead
     */
    export type setting_serviceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = setting_serviceDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}